var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except2)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// .wrangler/tmp/bundle-gS6WEs/checked-fetch.js
function checkURL(request3, init3) {
  const url = request3 instanceof URL ? request3 : new URL(
    (typeof request3 === "string" ? new Request(request3, init3) : request3).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-gS6WEs/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    __name(checkURL, "checkURL");
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request3, init3] = argArray;
        checkURL(request3, init3);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-clear$immediate.js
var init_virtual_unenv_global_polyfill_clear_immediate = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-clear$immediate.js"() {
    init_cloudflare();
    globalThis.clearImmediate = clearImmediateFallback;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/_internal/utils.mjs
function rawHeaders(headers) {
  const rawHeaders2 = [];
  for (const key in headers) {
    if (Array.isArray(headers[key])) {
      for (const h2 of headers[key]) {
        rawHeaders2.push(key, h2);
      }
    } else {
      rawHeaders2.push(key, headers[key]);
    }
  }
  return rawHeaders2;
}
function mergeFns(...functions) {
  return function(...args) {
    for (const fn3 of functions) {
      fn3(...args);
    }
  };
}
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
function notImplemented(name) {
  const fn3 = /* @__PURE__ */ __name(() => {
    throw createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn3, { __unenv__: true });
}
function notImplementedAsync(name) {
  const fn3 = notImplemented(name);
  fn3.__promisify__ = () => notImplemented(name + ".__promisify__");
  fn3.native = fn3;
  return fn3;
}
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/_internal/utils.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    __name(rawHeaders, "rawHeaders");
    __name(mergeFns, "mergeFns");
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedAsync, "notImplementedAsync");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/noop.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/internal/immediate.mjs
var Immediate;
var init_immediate = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/internal/immediate.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    Immediate = class {
      _onImmediate;
      _timeout;
      constructor(callback2, args) {
        this._onImmediate = callback2;
        if ("setTimeout" in globalThis) {
          this._timeout = setTimeout(callback2, 0, ...args);
        } else {
          callback2(...args);
        }
      }
      ref() {
        this._timeout?.ref();
        return this;
      }
      unref() {
        this._timeout?.unref();
        return this;
      }
      hasRef() {
        return this._timeout?.hasRef() ?? false;
      }
      [Symbol.dispose]() {
        if ("clearTimeout" in globalThis) {
          clearTimeout(this._timeout);
        }
      }
    };
    __name(Immediate, "Immediate");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/internal/set-immediate.mjs
function setImmediateFallbackPromises(value) {
  return new Promise((res) => {
    res(value);
  });
}
function setImmediateFallback(callback2, ...args) {
  return new Immediate(callback2, args);
}
function clearImmediateFallback(immediate) {
  immediate?.[Symbol.dispose]();
}
var init_set_immediate = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/internal/set-immediate.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_immediate();
    __name(setImmediateFallbackPromises, "setImmediateFallbackPromises");
    __name(setImmediateFallback, "setImmediateFallback");
    setImmediateFallback.__promisify__ = setImmediateFallbackPromises;
    __name(clearImmediateFallback, "clearImmediateFallback");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/$cloudflare.mjs
var init_cloudflare = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/timers/$cloudflare.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_set_immediate();
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-set$immediate.js
var init_virtual_unenv_global_polyfill_set_immediate = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-set$immediate.js"() {
    init_cloudflare();
    globalThis.setImmediate = setImmediateFallback;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/proxy.mjs
function createMock(name, overrides = {}) {
  fn.prototype.name = name;
  const props = {};
  return new Proxy(fn, {
    get(_target, prop) {
      if (prop === "caller") {
        return null;
      }
      if (prop === "__createMock__") {
        return createMock;
      }
      if (prop === "__unenv__") {
        return true;
      }
      if (prop in overrides) {
        return overrides[prop];
      }
      return props[prop] = props[prop] || createMock(`${name}.${prop.toString()}`);
    },
    apply(_target, _this, _args) {
      return createMock(`${name}()`);
    },
    construct(_target, _args, _newT) {
      return createMock(`[${name}]`);
    },
    // @ts-ignore (ES6-only - removed in ES7)
    // https://github.com/tc39/ecma262/issues/161
    enumerate() {
      return [];
    }
  });
}
var fn, proxy_default;
var init_proxy = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/proxy.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    fn = /* @__PURE__ */ __name(function() {
    }, "fn");
    __name(createMock, "createMock");
    proxy_default = createMock("mock");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/console/index.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, assert, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console;
var init_console = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/console/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_proxy();
    init_noop();
    init_utils();
    init_proxy();
    init_noop();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? notImplemented("console.createTask");
    assert = notImplemented("console.assert");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? proxy_default.__createMock__("console.Console");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/console/$cloudflare.mjs
var workerdConsole, assert2, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, cloudflare_default;
var init_cloudflare2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/console/$cloudflare.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert: assert2,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler: noop_default,
      _stdout,
      _stdoutErrorHandler: noop_default,
      _times: proxy_default
    });
    cloudflare_default = workerdConsole;
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-console.js
var init_virtual_unenv_global_polyfill_console = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-console.js"() {
    init_cloudflare2();
    globalThis.console = cloudflare_default;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_entry.mjs
var _supportedEntryTypes, _PerformanceEntry, PerformanceEntry, _PerformanceMark, PerformanceMark, _PerformanceMeasure, PerformanceMeasure, _PerformanceResourceTiming, PerformanceResourceTiming;
var init_entry = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_entry.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    _supportedEntryTypes = [
      "event",
      // PerformanceEntry
      "mark",
      // PerformanceMark
      "measure",
      // PerformanceMeasure
      "resource"
      // PerformanceResourceTiming
    ];
    _PerformanceEntry = class {
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || performance.now();
        this.detail = options?.detail;
      }
      get duration() {
        return performance.now() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    __name(_PerformanceEntry, "_PerformanceEntry");
    PerformanceEntry = globalThis.PerformanceEntry || _PerformanceEntry;
    _PerformanceMark = class extends _PerformanceEntry {
      entryType = "mark";
    };
    __name(_PerformanceMark, "_PerformanceMark");
    PerformanceMark = globalThis.PerformanceMark || _PerformanceMark;
    _PerformanceMeasure = class extends _PerformanceEntry {
      entryType = "measure";
    };
    __name(_PerformanceMeasure, "_PerformanceMeasure");
    PerformanceMeasure = globalThis.PerformanceMeasure || _PerformanceMeasure;
    _PerformanceResourceTiming = class extends _PerformanceEntry {
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
    };
    __name(_PerformanceResourceTiming, "_PerformanceResourceTiming");
    PerformanceResourceTiming = globalThis.PerformanceResourceTiming || _PerformanceResourceTiming;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_performance.mjs
var _timeOrigin, _Performance, Performance, performance2;
var init_performance = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_performance.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_proxy();
    init_entry();
    _timeOrigin = Date.now();
    _Performance = class {
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = proxy_default.__createMock__("PerformanceNavigation");
      timing = proxy_default.__createMock__("PerformanceTiming");
      onresourcetimingbufferfull = null;
      now() {
        if (globalThis?.performance?.now && this.timeOrigin === _timeOrigin) {
          return globalThis.performance.now();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e2) => e2.name !== markName) : this._entries.filter((e2) => e2.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e2) => e2.name !== measureName) : this._entries.filter((e2) => e2.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter(
          (e2) => e2.entryType !== "resource" || e2.entryType !== "navigation"
        );
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter(
          (e2) => e2.name === name && (!type2 || e2.entryType === type2)
        );
      }
      getEntriesByType(type2) {
        return this._entries.filter(
          (e2) => e2.entryType === type2
        );
      }
      mark(name, options) {
        const entry = new _PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || performance2.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || performance2.now();
        }
        const entry = new _PerformanceMeasure(measureName, {
          startTime: start,
          detail: { start, end }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      toJSON() {
        return this;
      }
      addEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
    };
    __name(_Performance, "_Performance");
    Performance = globalThis.Performance || _Performance;
    performance2 = globalThis.performance || new Performance();
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_observer.mjs
var _PerformanceObserver, PerformanceObserver, _PerformanceObserverEntryList, PerformanceObserverEntryList;
var init_observer = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/_observer.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_entry();
    _PerformanceObserver = class {
      __unenv__ = true;
      _callback = null;
      constructor(callback2) {
        this._callback = callback2;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
    };
    __name(_PerformanceObserver, "_PerformanceObserver");
    __publicField(_PerformanceObserver, "supportedEntryTypes", _supportedEntryTypes);
    PerformanceObserver = globalThis.PerformanceObserver || _PerformanceObserver;
    _PerformanceObserverEntryList = class {
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    __name(_PerformanceObserverEntryList, "_PerformanceObserverEntryList");
    PerformanceObserverEntryList = globalThis.PerformanceObserverEntryList || _PerformanceObserverEntryList;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/index.mjs
var init_performance2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/web/performance/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_performance();
    init_observer();
    init_entry();
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/polyfill/global-this.mjs
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return {};
}
var global_this_default;
var init_global_this = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/polyfill/global-this.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    __name(getGlobal, "getGlobal");
    global_this_default = getGlobal();
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/polyfill/performance.mjs
var performance_default;
var init_performance3 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/polyfill/performance.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_performance2();
    init_global_this();
    global_this_default.performance = global_this_default.performance || performance2;
    global_this_default.Performance = global_this_default.Performance || Performance;
    global_this_default.PerformanceEntry = global_this_default.PerformanceEntry || PerformanceEntry;
    global_this_default.PerformanceMark = global_this_default.PerformanceMark || PerformanceMark;
    global_this_default.PerformanceMeasure = global_this_default.PerformanceMeasure || PerformanceMeasure;
    global_this_default.PerformanceObserver = global_this_default.PerformanceObserver || PerformanceObserver;
    global_this_default.PerformanceObserverEntryList = global_this_default.PerformanceObserverEntryList || PerformanceObserverEntryList;
    global_this_default.PerformanceResourceTiming = global_this_default.PerformanceResourceTiming || PerformanceResourceTiming;
    performance_default = global_this_default.performance;
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-performance.js
var init_virtual_unenv_global_polyfill_performance = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-performance.js"() {
    init_performance3();
    globalThis.performance = performance_default;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/empty.mjs
var empty_default;
var init_empty = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/mock/empty.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    empty_default = Object.freeze(
      Object.create(null, {
        __unenv__: { get: () => true }
      })
    );
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/env.mjs
var _envShim, _processEnv, _getEnv, env;
var init_env = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/env.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    _envShim = /* @__PURE__ */ Object.create(null);
    _processEnv = globalThis.process?.env;
    _getEnv = /* @__PURE__ */ __name((useShim) => _processEnv || globalThis.__env__ || (useShim ? _envShim : globalThis), "_getEnv");
    env = new Proxy(_envShim, {
      get(_5, prop) {
        const env22 = _getEnv();
        return env22[prop] ?? _envShim[prop];
      },
      has(_5, prop) {
        const env22 = _getEnv();
        return prop in env22 || prop in _envShim;
      },
      set(_5, prop, value) {
        const env22 = _getEnv(true);
        env22[prop] = value;
        return true;
      },
      deleteProperty(_5, prop) {
        const env22 = _getEnv(true);
        delete env22[prop];
        return true;
      },
      ownKeys() {
        const env22 = _getEnv();
        return Object.keys(env22);
      }
    });
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/time.mjs
function _createNextTickWithTimeout() {
  let queue = [];
  let draining = false;
  let currentQueue;
  let queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length > 0) {
      queue = [...currentQueue, ...queue];
    } else {
      queueIndex = -1;
    }
    if (queue.length > 0) {
      drainQueue();
    }
  }
  __name(cleanUpNextTick, "cleanUpNextTick");
  function drainQueue() {
    if (draining) {
      return;
    }
    const timeout = setTimeout(cleanUpNextTick);
    draining = true;
    let len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex]();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = void 0;
    draining = false;
    clearTimeout(timeout);
  }
  __name(drainQueue, "drainQueue");
  const nextTick22 = /* @__PURE__ */ __name((cb, ...args) => {
    queue.push(cb.bind(void 0, ...args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue);
    }
  }, "nextTick2");
  return nextTick22;
}
var hrtime, nextTick;
var init_time = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/time.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    hrtime = Object.assign(
      /* @__PURE__ */ __name(function hrtime2(startTime) {
        const now2 = Date.now();
        const seconds = Math.trunc(now2 / 1e3);
        const nanos = now2 % 1e3 * 1e6;
        if (startTime) {
          let diffSeconds = seconds - startTime[0];
          let diffNanos = nanos - startTime[0];
          if (diffNanos < 0) {
            diffSeconds = diffSeconds - 1;
            diffNanos = 1e9 + diffNanos;
          }
          return [diffSeconds, diffNanos];
        }
        return [seconds, nanos];
      }, "hrtime2"),
      {
        bigint: /* @__PURE__ */ __name(function bigint() {
          return BigInt(Date.now() * 1e6);
        }, "bigint")
      }
    );
    nextTick = globalThis.queueMicrotask ? (cb, ...args) => {
      globalThis.queueMicrotask(cb.bind(void 0, ...args));
    } : _createNextTickWithTimeout();
    __name(_createNextTickWithTimeout, "_createNextTickWithTimeout");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/process.mjs
function noop() {
  return process2;
}
var title, argv, version, versions, on, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, listeners, listenerCount, binding, _cwd, cwd, chdir, umask, getegid, geteuid, getgid, getuid, getgroups, getBuiltinModule, abort, allowedNodeEnvironmentFlags, arch, argv0, config, connected, constrainedMemory, availableMemory, cpuUsage, debugPort, dlopen, disconnect, emitWarning, eventNames, execArgv, execPath, exit, features, getActiveResourcesInfo, getMaxListeners, kill, memoryUsage, pid, platform, ppid, rawListeners, release, report, resourceUsage, setegid, seteuid, setgid, setgroups, setuid, setMaxListeners, setSourceMapsEnabled, stdout, stderr, stdin, traceDeprecation, uptime, exitCode, setUncaughtExceptionCaptureCallback, hasUncaughtExceptionCaptureCallback, sourceMapsEnabled, loadEnvFile, mainModule, permission, channel, throwDeprecation, assert3, openStdin, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _linkedBinding, domain, initgroups, moduleLoadList, reallyExit, _exiting, _events, _eventsCount, _maxListeners, process2;
var init_process = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/internal/process.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_proxy();
    init_empty();
    init_utils();
    init_env();
    init_time();
    init_time();
    title = "unenv";
    argv = [];
    version = "";
    versions = {
      ares: "",
      http_parser: "",
      icu: "",
      modules: "",
      node: "",
      openssl: "",
      uv: "",
      v8: "",
      zlib: ""
    };
    __name(noop, "noop");
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = /* @__PURE__ */ __name(function emit2(event) {
      if (event === "message" || event === "multipleResolves") {
        return process2;
      }
      return false;
    }, "emit2");
    prependListener = noop;
    prependOnceListener = noop;
    listeners = /* @__PURE__ */ __name(function(name) {
      return [];
    }, "listeners");
    listenerCount = /* @__PURE__ */ __name(() => 0, "listenerCount");
    binding = /* @__PURE__ */ __name(function(name) {
      throw new Error("[unenv] process.binding is not supported");
    }, "binding");
    _cwd = "/";
    cwd = /* @__PURE__ */ __name(function cwd2() {
      return _cwd;
    }, "cwd2");
    chdir = /* @__PURE__ */ __name(function chdir2(dir3) {
      _cwd = dir3;
    }, "chdir2");
    umask = /* @__PURE__ */ __name(function umask2() {
      return 0;
    }, "umask2");
    getegid = /* @__PURE__ */ __name(function getegid2() {
      return 1e3;
    }, "getegid2");
    geteuid = /* @__PURE__ */ __name(function geteuid2() {
      return 1e3;
    }, "geteuid2");
    getgid = /* @__PURE__ */ __name(function getgid2() {
      return 1e3;
    }, "getgid2");
    getuid = /* @__PURE__ */ __name(function getuid2() {
      return 1e3;
    }, "getuid2");
    getgroups = /* @__PURE__ */ __name(function getgroups2() {
      return [];
    }, "getgroups2");
    getBuiltinModule = /* @__PURE__ */ __name((_name) => void 0, "getBuiltinModule");
    abort = notImplemented("process.abort");
    allowedNodeEnvironmentFlags = /* @__PURE__ */ new Set();
    arch = "";
    argv0 = "";
    config = empty_default;
    connected = false;
    constrainedMemory = /* @__PURE__ */ __name(() => 0, "constrainedMemory");
    availableMemory = /* @__PURE__ */ __name(() => 0, "availableMemory");
    cpuUsage = notImplemented("process.cpuUsage");
    debugPort = 0;
    dlopen = notImplemented("process.dlopen");
    disconnect = noop;
    emitWarning = noop;
    eventNames = notImplemented("process.eventNames");
    execArgv = [];
    execPath = "";
    exit = notImplemented("process.exit");
    features = /* @__PURE__ */ Object.create({
      inspector: void 0,
      debug: void 0,
      uv: void 0,
      ipv6: void 0,
      tls_alpn: void 0,
      tls_sni: void 0,
      tls_ocsp: void 0,
      tls: void 0,
      cached_builtins: void 0
    });
    getActiveResourcesInfo = /* @__PURE__ */ __name(() => [], "getActiveResourcesInfo");
    getMaxListeners = notImplemented(
      "process.getMaxListeners"
    );
    kill = notImplemented("process.kill");
    memoryUsage = Object.assign(
      () => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }),
      { rss: () => 0 }
    );
    pid = 1e3;
    platform = "";
    ppid = 1e3;
    rawListeners = notImplemented(
      "process.rawListeners"
    );
    release = /* @__PURE__ */ Object.create({
      name: "",
      lts: "",
      sourceUrl: void 0,
      headersUrl: void 0
    });
    report = /* @__PURE__ */ Object.create({
      compact: void 0,
      directory: void 0,
      filename: void 0,
      getReport: notImplemented("process.report.getReport"),
      reportOnFatalError: void 0,
      reportOnSignal: void 0,
      reportOnUncaughtException: void 0,
      signal: void 0,
      writeReport: notImplemented("process.report.writeReport")
    });
    resourceUsage = notImplemented(
      "process.resourceUsage"
    );
    setegid = notImplemented("process.setegid");
    seteuid = notImplemented("process.seteuid");
    setgid = notImplemented("process.setgid");
    setgroups = notImplemented("process.setgroups");
    setuid = notImplemented("process.setuid");
    setMaxListeners = notImplemented(
      "process.setMaxListeners"
    );
    setSourceMapsEnabled = notImplemented("process.setSourceMapsEnabled");
    stdout = proxy_default.__createMock__("process.stdout");
    stderr = proxy_default.__createMock__("process.stderr");
    stdin = proxy_default.__createMock__("process.stdin");
    traceDeprecation = false;
    uptime = /* @__PURE__ */ __name(() => 0, "uptime");
    exitCode = 0;
    setUncaughtExceptionCaptureCallback = notImplemented("process.setUncaughtExceptionCaptureCallback");
    hasUncaughtExceptionCaptureCallback = /* @__PURE__ */ __name(() => false, "hasUncaughtExceptionCaptureCallback");
    sourceMapsEnabled = false;
    loadEnvFile = notImplemented(
      "process.loadEnvFile"
    );
    mainModule = void 0;
    permission = {
      has: () => false
    };
    channel = {
      ref() {
      },
      unref() {
      }
    };
    throwDeprecation = false;
    assert3 = notImplemented("process.assert");
    openStdin = notImplemented("process.openStdin");
    _debugEnd = notImplemented("process._debugEnd");
    _debugProcess = notImplemented("process._debugProcess");
    _fatalException = notImplemented("process._fatalException");
    _getActiveHandles = notImplemented("process._getActiveHandles");
    _getActiveRequests = notImplemented("process._getActiveRequests");
    _kill = notImplemented("process._kill");
    _preload_modules = [];
    _rawDebug = notImplemented("process._rawDebug");
    _startProfilerIdleNotifier = notImplemented(
      "process._startProfilerIdleNotifier"
    );
    _stopProfilerIdleNotifier = notImplemented(
      "process.__stopProfilerIdleNotifier"
    );
    _tickCallback = notImplemented("process._tickCallback");
    _linkedBinding = notImplemented("process._linkedBinding");
    domain = proxy_default.__createMock__("process.domain");
    initgroups = notImplemented("process.initgroups");
    moduleLoadList = [];
    reallyExit = noop;
    _exiting = false;
    _events = [];
    _eventsCount = 0;
    _maxListeners = 0;
    process2 = {
      // @ts-expect-error
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      exitCode,
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      throwDeprecation,
      mainModule,
      permission,
      channel,
      arch,
      argv,
      argv0,
      assert: assert3,
      binding,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      features,
      getBuiltinModule,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      openStdin,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions
    };
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/$cloudflare.mjs
var unpatchedGlobalThisProcess, getBuiltinModule2, workerdProcess, env2, nextTick2, _process, cloudflare_default2;
var init_cloudflare3 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/process/$cloudflare.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_process();
    unpatchedGlobalThisProcess = globalThis["process"];
    getBuiltinModule2 = unpatchedGlobalThisProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule2("node:process");
    ({ env: env2, nextTick: nextTick2 } = workerdProcess);
    _process = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      // @ts-expect-error (not typed)
      _debugEnd,
      _debugProcess,
      // TODO: implemented yet in unenv
      //_events,
      _eventsCount,
      // TODO: implemented yet in unenv
      //_exiting,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      // TODO: implemented yet in unenv
      //_linkedBinding,
      // TODO: implemented yet in unenv
      //_maxListeners,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      assert: assert3,
      availableMemory,
      binding,
      chdir,
      config,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      // TODO: implemented yet in unenv
      //domain,
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exit,
      exitCode,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      hrtime,
      // TODO: implemented yet in unenv
      //initgroups,
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      // TODO: implemented yet in unenv
      //moduleLoadList,
      off,
      on,
      once,
      // TODO: implemented yet in unenv
      //openStdin,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      // TODO: implemented yet in unenv
      //reallyExit,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      setUncaughtExceptionCaptureCallback,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      umask,
      uptime,
      version,
      versions,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      env: env2,
      getBuiltinModule: getBuiltinModule2,
      nextTick: nextTick2
    };
    cloudflare_default2 = _process;
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-process.js
var init_virtual_unenv_global_polyfill_process = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/_virtual_unenv_global_polyfill-process.js"() {
    init_cloudflare3();
    globalThis.process = cloudflare_default2;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
  }
});

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/classes.mjs
var classes_exports = {};
__export(classes_exports, {
  Dir: () => Dir,
  Dirent: () => Dirent,
  FileReadStream: () => FileReadStream,
  FileWriteStream: () => FileWriteStream,
  ReadStream: () => ReadStream,
  Stats: () => Stats,
  StatsFs: () => StatsFs,
  WriteStream: () => WriteStream
});
var Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, StatsFs;
var init_classes = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/classes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_proxy();
    Dir = proxy_default.__createMock__("fs.Dir");
    Dirent = proxy_default.__createMock__("fs.Dirent");
    Stats = proxy_default.__createMock__("fs.Stats");
    ReadStream = proxy_default.__createMock__("fs.ReadStream");
    WriteStream = proxy_default.__createMock__("fs.WriteStream");
    FileReadStream = proxy_default.__createMock__("fs.FileReadStream");
    FileWriteStream = proxy_default.__createMock__("fs.FileWriteStream");
    StatsFs = proxy_default.__createMock__("fs.StatsFs");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  F_OK: () => F_OK,
  R_OK: () => R_OK,
  W_OK: () => W_OK,
  X_OK: () => X_OK,
  constants: () => constants
});
var F_OK, R_OK, W_OK, X_OK, constants;
var init_constants = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/constants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    F_OK = 0;
    R_OK = 4;
    W_OK = 2;
    X_OK = 1;
    constants = /* @__PURE__ */ Object.create({
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      UV_DIRENT_UNKNOWN: 0,
      UV_DIRENT_FILE: 1,
      UV_DIRENT_DIR: 2,
      UV_DIRENT_LINK: 3,
      UV_DIRENT_FIFO: 4,
      UV_DIRENT_SOCKET: 5,
      UV_DIRENT_CHAR: 6,
      UV_DIRENT_BLOCK: 7,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      UV_FS_O_FILEMAP: 0,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DSYNC: 4096,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_COPYFILE_EXCL: 1,
      COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_FICLONE_FORCE: 4
    });
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/promises.mjs
var promises_exports = {};
__export(promises_exports, {
  access: () => access,
  appendFile: () => appendFile,
  chmod: () => chmod,
  chown: () => chown,
  constants: () => constants,
  copyFile: () => copyFile,
  cp: () => cp,
  default: () => promises_default,
  glob: () => glob,
  lchmod: () => lchmod,
  lchown: () => lchown,
  link: () => link,
  lstat: () => lstat,
  lutimes: () => lutimes,
  mkdir: () => mkdir,
  mkdtemp: () => mkdtemp,
  open: () => open,
  opendir: () => opendir,
  readFile: () => readFile,
  readdir: () => readdir,
  readlink: () => readlink,
  realpath: () => realpath,
  rename: () => rename,
  rm: () => rm,
  rmdir: () => rmdir,
  stat: () => stat,
  statfs: () => statfs,
  symlink: () => symlink,
  truncate: () => truncate,
  unlink: () => unlink,
  utimes: () => utimes,
  watch: () => watch,
  writeFile: () => writeFile
});
var access, copyFile, cp, open, opendir, rename, truncate, rm, rmdir, mkdir, readdir, readlink, symlink, lstat, stat, link, unlink, chmod, lchmod, lchown, chown, utimes, lutimes, realpath, mkdtemp, writeFile, appendFile, readFile, watch, statfs, glob, promises_default;
var init_promises = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/promises.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_constants();
    access = notImplemented("fs.access");
    copyFile = notImplemented("fs.copyFile");
    cp = notImplemented("fs.cp");
    open = notImplemented("fs.open");
    opendir = notImplemented("fs.opendir");
    rename = notImplemented("fs.rename");
    truncate = notImplemented("fs.truncate");
    rm = notImplemented("fs.rm");
    rmdir = notImplemented("fs.rmdir");
    mkdir = notImplemented(
      "fs.mkdir"
    );
    readdir = notImplemented(
      "fs.readdir"
    );
    readlink = notImplemented(
      "fs.readlink"
    );
    symlink = notImplemented("fs.symlink");
    lstat = notImplemented(
      "fs.lstat"
    );
    stat = notImplemented(
      "fs.stat"
    );
    link = notImplemented("fs.link");
    unlink = notImplemented("fs.unlink");
    chmod = notImplemented("fs.chmod");
    lchmod = notImplemented("fs.lchmod");
    lchown = notImplemented("fs.lchown");
    chown = notImplemented("fs.chown");
    utimes = notImplemented("fs.utimes");
    lutimes = notImplemented("fs.lutimes");
    realpath = notImplemented(
      "fs.realpath"
    );
    mkdtemp = notImplemented(
      "fs.mkdtemp"
    );
    writeFile = notImplemented("fs.writeFile");
    appendFile = notImplemented("fs.appendFile");
    readFile = notImplemented(
      "fs.readFile"
    );
    watch = notImplemented(
      "fs.watch"
    );
    statfs = notImplemented(
      "fs.statfs"
    );
    glob = notImplemented("fs.glob");
    promises_default = {};
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/fs.mjs
var fs_exports = {};
__export(fs_exports, {
  _toUnixTimestamp: () => _toUnixTimestamp,
  access: () => access2,
  accessSync: () => accessSync,
  appendFile: () => appendFile2,
  appendFileSync: () => appendFileSync,
  chmod: () => chmod2,
  chmodSync: () => chmodSync,
  chown: () => chown2,
  chownSync: () => chownSync,
  close: () => close,
  closeSync: () => closeSync,
  copyFile: () => copyFile2,
  copyFileSync: () => copyFileSync,
  cp: () => cp2,
  cpSync: () => cpSync,
  createReadStream: () => createReadStream,
  createWriteStream: () => createWriteStream,
  exists: () => exists,
  existsSync: () => existsSync,
  fchmod: () => fchmod,
  fchmodSync: () => fchmodSync,
  fchown: () => fchown,
  fchownSync: () => fchownSync,
  fdatasync: () => fdatasync,
  fdatasyncSync: () => fdatasyncSync,
  fstat: () => fstat,
  fstatSync: () => fstatSync,
  fsync: () => fsync,
  fsyncSync: () => fsyncSync,
  ftruncate: () => ftruncate,
  ftruncateSync: () => ftruncateSync,
  futimes: () => futimes,
  futimesSync: () => futimesSync,
  glob: () => glob2,
  globSync: () => globSync,
  lchmod: () => lchmod2,
  lchmodSync: () => lchmodSync,
  lchown: () => lchown2,
  lchownSync: () => lchownSync,
  link: () => link2,
  linkSync: () => linkSync,
  lstat: () => lstat2,
  lstatSync: () => lstatSync,
  lutimes: () => lutimes2,
  lutimesSync: () => lutimesSync,
  mkdir: () => mkdir2,
  mkdirSync: () => mkdirSync,
  mkdtemp: () => mkdtemp2,
  mkdtempSync: () => mkdtempSync,
  open: () => open2,
  openAsBlob: () => openAsBlob,
  openSync: () => openSync,
  opendir: () => opendir2,
  opendirSync: () => opendirSync,
  read: () => read,
  readFile: () => readFile2,
  readFileSync: () => readFileSync,
  readSync: () => readSync,
  readdir: () => readdir2,
  readdirSync: () => readdirSync,
  readlink: () => readlink2,
  readlinkSync: () => readlinkSync,
  readv: () => readv,
  readvSync: () => readvSync,
  realpath: () => realpath2,
  realpathSync: () => realpathSync,
  rename: () => rename2,
  renameSync: () => renameSync,
  rm: () => rm2,
  rmSync: () => rmSync,
  rmdir: () => rmdir2,
  rmdirSync: () => rmdirSync,
  stat: () => stat2,
  statSync: () => statSync,
  statfs: () => statfs2,
  statfsSync: () => statfsSync,
  symlink: () => symlink2,
  symlinkSync: () => symlinkSync,
  truncate: () => truncate2,
  truncateSync: () => truncateSync,
  unlink: () => unlink2,
  unlinkSync: () => unlinkSync,
  unwatchFile: () => unwatchFile,
  utimes: () => utimes2,
  utimesSync: () => utimesSync,
  watch: () => watch2,
  watchFile: () => watchFile,
  write: () => write,
  writeFile: () => writeFile2,
  writeFileSync: () => writeFileSync,
  writeSync: () => writeSync,
  writev: () => writev,
  writevSync: () => writevSync
});
function callbackify(fn3) {
  const fnc = /* @__PURE__ */ __name(function(...args) {
    const cb = args.pop();
    fn3().catch((error4) => cb(error4)).then((val) => cb(void 0, val));
  }, "fnc");
  fnc.__promisify__ = fn3;
  fnc.native = fnc;
  return fnc;
}
var access2, appendFile2, chown2, chmod2, copyFile2, cp2, lchown2, lchmod2, link2, lstat2, lutimes2, mkdir2, mkdtemp2, realpath2, open2, opendir2, readdir2, readFile2, readlink2, rename2, rm2, rmdir2, stat2, symlink2, truncate2, unlink2, utimes2, writeFile2, statfs2, close, createReadStream, createWriteStream, exists, fchown, fchmod, fdatasync, fstat, fsync, ftruncate, futimes, lstatSync, read, readv, realpathSync, statSync, unwatchFile, watch2, watchFile, write, writev, _toUnixTimestamp, openAsBlob, glob2, appendFileSync, accessSync, chownSync, chmodSync, closeSync, copyFileSync, cpSync, existsSync, fchownSync, fchmodSync, fdatasyncSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, lchownSync, lchmodSync, linkSync, lutimesSync, mkdirSync, mkdtempSync, openSync, opendirSync, readdirSync, readSync, readvSync, readFileSync, readlinkSync, renameSync, rmSync, rmdirSync, symlinkSync, truncateSync, unlinkSync, utimesSync, writeFileSync, writeSync, writevSync, statfsSync, globSync;
var init_fs = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/internal/fs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_promises();
    __name(callbackify, "callbackify");
    access2 = callbackify(access);
    appendFile2 = callbackify(appendFile);
    chown2 = callbackify(chown);
    chmod2 = callbackify(chmod);
    copyFile2 = callbackify(copyFile);
    cp2 = callbackify(cp);
    lchown2 = callbackify(lchown);
    lchmod2 = callbackify(lchmod);
    link2 = callbackify(link);
    lstat2 = callbackify(lstat);
    lutimes2 = callbackify(lutimes);
    mkdir2 = callbackify(mkdir);
    mkdtemp2 = callbackify(mkdtemp);
    realpath2 = callbackify(realpath);
    open2 = callbackify(open);
    opendir2 = callbackify(opendir);
    readdir2 = callbackify(readdir);
    readFile2 = callbackify(readFile);
    readlink2 = callbackify(readlink);
    rename2 = callbackify(rename);
    rm2 = callbackify(rm);
    rmdir2 = callbackify(rmdir);
    stat2 = callbackify(stat);
    symlink2 = callbackify(symlink);
    truncate2 = callbackify(truncate);
    unlink2 = callbackify(unlink);
    utimes2 = callbackify(utimes);
    writeFile2 = callbackify(writeFile);
    statfs2 = callbackify(statfs);
    close = notImplementedAsync("fs.close");
    createReadStream = notImplementedAsync(
      "fs.createReadStream"
    );
    createWriteStream = notImplementedAsync("fs.createWriteStream");
    exists = notImplementedAsync("fs.exists");
    fchown = notImplementedAsync("fs.fchown");
    fchmod = notImplementedAsync("fs.fchmod");
    fdatasync = notImplementedAsync("fs.fdatasync");
    fstat = notImplementedAsync("fs.fstat");
    fsync = notImplementedAsync("fs.fsync");
    ftruncate = notImplementedAsync("fs.ftruncate");
    futimes = notImplementedAsync("fs.futimes");
    lstatSync = notImplementedAsync("fs.lstatSync");
    read = notImplementedAsync("fs.read");
    readv = notImplementedAsync("fs.readv");
    realpathSync = notImplementedAsync("fs.realpathSync");
    statSync = notImplementedAsync("fs.statSync");
    unwatchFile = notImplementedAsync("fs.unwatchFile");
    watch2 = notImplementedAsync("fs.watch");
    watchFile = notImplementedAsync("fs.watchFile");
    write = notImplementedAsync("fs.write");
    writev = notImplementedAsync("fs.writev");
    _toUnixTimestamp = notImplementedAsync("fs._toUnixTimestamp");
    openAsBlob = notImplementedAsync("fs.openAsBlob");
    glob2 = notImplementedAsync("fs.glob");
    appendFileSync = notImplemented("fs.appendFileSync");
    accessSync = notImplemented("fs.accessSync");
    chownSync = notImplemented("fs.chownSync");
    chmodSync = notImplemented("fs.chmodSync");
    closeSync = notImplemented("fs.closeSync");
    copyFileSync = notImplemented("fs.copyFileSync");
    cpSync = notImplemented("fs.cpSync");
    existsSync = /* @__PURE__ */ __name(() => false, "existsSync");
    fchownSync = notImplemented("fs.fchownSync");
    fchmodSync = notImplemented("fs.fchmodSync");
    fdatasyncSync = notImplemented("fs.fdatasyncSync");
    fstatSync = notImplemented(
      "fs.fstatSync"
    );
    fsyncSync = notImplemented("fs.fsyncSync");
    ftruncateSync = notImplemented("fs.ftruncateSync");
    futimesSync = notImplemented("fs.futimesSync");
    lchownSync = notImplemented("fs.lchownSync");
    lchmodSync = notImplemented("fs.lchmodSync");
    linkSync = notImplemented("fs.linkSync");
    lutimesSync = notImplemented("fs.lutimesSync");
    mkdirSync = notImplemented("fs.mkdirSync");
    mkdtempSync = notImplemented(
      "fs.mkdtempSync"
    );
    openSync = notImplemented("fs.openSync");
    opendirSync = notImplemented("fs.opendirSync");
    readdirSync = notImplemented(
      "fs.readdirSync"
    );
    readSync = notImplemented("fs.readSync");
    readvSync = notImplemented("fs.readvSync");
    readFileSync = notImplemented(
      "fs.readFileSync"
    );
    readlinkSync = notImplemented(
      "fs.readlinkSync"
    );
    renameSync = notImplemented("fs.renameSync");
    rmSync = notImplemented("fs.rmSync");
    rmdirSync = notImplemented("fs.rmdirSync");
    symlinkSync = notImplemented("fs.symlinkSync");
    truncateSync = notImplemented("fs.truncateSync");
    unlinkSync = notImplemented("fs.unlinkSync");
    utimesSync = notImplemented("fs.utimesSync");
    writeFileSync = notImplemented("fs.writeFileSync");
    writeSync = notImplemented("fs.writeSync");
    writevSync = notImplemented("fs.writevSync");
    statfsSync = notImplemented(
      "fs.statfsSync"
    );
    globSync = notImplemented("fs.globSync");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/index.mjs
var promises, fs_default;
var init_fs2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/fs/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_classes();
    init_constants();
    init_fs();
    init_promises();
    init_classes();
    init_constants();
    init_fs();
    promises = promises_exports;
    fs_default = {
      ...classes_exports,
      ...constants_exports,
      ...fs_exports,
      promises
    };
  }
});

// node-built-in-modules:fs
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_fs2();
    module.exports = fs_default;
  }
});

// node-built-in-modules:path
import libDefault from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = libDefault;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/constants/iternal/os.mjs
var UV_UDP_REUSEADDR, RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, RTLD_LOCAL, RTLD_DEEPBIND, E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, EAFNOSUPPORT, EAGAIN, EALREADY, EBADF, EBADMSG, EBUSY, ECANCELED, ECHILD, ECONNABORTED, ECONNREFUSED, ECONNRESET, EDEADLK, EDESTADDRREQ, EDOM, EDQUOT, EEXIST, EFAULT, EFBIG, EHOSTUNREACH, EIDRM, EILSEQ, EINPROGRESS, EINTR, EINVAL, EIO, EISCONN, EISDIR, ELOOP, EMFILE, EMLINK, EMSGSIZE, EMULTIHOP, ENAMETOOLONG, ENETDOWN, ENETRESET, ENETUNREACH, ENFILE, ENOBUFS, ENODATA, ENODEV, ENOENT, ENOEXEC, ENOLCK, ENOLINK, ENOMEM, ENOMSG, ENOPROTOOPT, ENOSPC, ENOSR, ENOSTR, ENOSYS, ENOTCONN, ENOTDIR, ENOTEMPTY, ENOTSOCK, ENOTSUP, ENOTTY, ENXIO, EOPNOTSUPP, EOVERFLOW, EPERM, EPIPE, EPROTO, EPROTONOSUPPORT, EPROTOTYPE, ERANGE, EROFS, ESPIPE, ESRCH, ESTALE, ETIME, ETIMEDOUT, ETXTBSY, EWOULDBLOCK, EXDEV, WSAEINTR, WSAEBADF, WSAEACCES, WSAEFAULT, WSAEINVAL, WSAEMFILE, WSAEWOULDBLOCK, WSAEINPROGRESS, WSAEALREADY, WSAENOTSOCK, WSAEDESTADDRREQ, WSAEMSGSIZE, WSAEPROTOTYPE, WSAENOPROTOOPT, WSAEPROTONOSUPPORT, WSAESOCKTNOSUPPORT, WSAEOPNOTSUPP, WSAEPFNOSUPPORT, WSAEAFNOSUPPORT, WSAEADDRINUSE, WSAEADDRNOTAVAIL, WSAENETDOWN, WSAENETUNREACH, WSAENETRESET, WSAECONNABORTED, WSAECONNRESET, WSAENOBUFS, WSAEISCONN, WSAENOTCONN, WSAESHUTDOWN, WSAETOOMANYREFS, WSAETIMEDOUT, WSAECONNREFUSED, WSAELOOP, WSAENAMETOOLONG, WSAEHOSTDOWN, WSAEHOSTUNREACH, WSAENOTEMPTY, WSAEPROCLIM, WSAEUSERS, WSAEDQUOT, WSAESTALE, WSAEREMOTE, WSASYSNOTREADY, WSAVERNOTSUPPORTED, WSANOTINITIALISED, WSAEDISCON, WSAENOMORE, WSAECANCELLED, WSAEINVALIDPROCTABLE, WSAEINVALIDPROVIDER, WSAEPROVIDERFAILEDINIT, WSASYSCALLFAILURE, WSASERVICE_NOT_FOUND, WSATYPE_NOT_FOUND, WSA_E_NO_MORE, WSA_E_CANCELLED, WSAEREFUSED, SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGIOT, SIGBUS, SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH, SIGIO, SIGINFO, SIGSYS, SIGPOLL, SIGPWR, SIGBREAK, SIGSTKFLT, SIGUNUSED, SIGLOST, PRIORITY_LOW, PRIORITY_BELOW_NORMAL, PRIORITY_NORMAL, PRIORITY_ABOVE_NORMAL, PRIORITY_HIGH, PRIORITY_HIGHEST, os_default;
var init_os = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/constants/iternal/os.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    UV_UDP_REUSEADDR = 4;
    RTLD_LAZY = 1;
    RTLD_NOW = 2;
    RTLD_GLOBAL = 8;
    RTLD_LOCAL = 4;
    RTLD_DEEPBIND = 16;
    E2BIG = 7;
    EACCES = 13;
    EADDRINUSE = 48;
    EADDRNOTAVAIL = 49;
    EAFNOSUPPORT = 47;
    EAGAIN = 35;
    EALREADY = 37;
    EBADF = 9;
    EBADMSG = 94;
    EBUSY = 16;
    ECANCELED = 89;
    ECHILD = 10;
    ECONNABORTED = 53;
    ECONNREFUSED = 61;
    ECONNRESET = 54;
    EDEADLK = 11;
    EDESTADDRREQ = 39;
    EDOM = 33;
    EDQUOT = 69;
    EEXIST = 17;
    EFAULT = 14;
    EFBIG = 27;
    EHOSTUNREACH = 65;
    EIDRM = 90;
    EILSEQ = 92;
    EINPROGRESS = 36;
    EINTR = 4;
    EINVAL = 22;
    EIO = 5;
    EISCONN = 56;
    EISDIR = 21;
    ELOOP = 62;
    EMFILE = 24;
    EMLINK = 31;
    EMSGSIZE = 40;
    EMULTIHOP = 95;
    ENAMETOOLONG = 63;
    ENETDOWN = 50;
    ENETRESET = 52;
    ENETUNREACH = 51;
    ENFILE = 23;
    ENOBUFS = 55;
    ENODATA = 96;
    ENODEV = 19;
    ENOENT = 2;
    ENOEXEC = 8;
    ENOLCK = 77;
    ENOLINK = 97;
    ENOMEM = 12;
    ENOMSG = 91;
    ENOPROTOOPT = 42;
    ENOSPC = 28;
    ENOSR = 98;
    ENOSTR = 99;
    ENOSYS = 78;
    ENOTCONN = 57;
    ENOTDIR = 20;
    ENOTEMPTY = 66;
    ENOTSOCK = 38;
    ENOTSUP = 45;
    ENOTTY = 25;
    ENXIO = 6;
    EOPNOTSUPP = 102;
    EOVERFLOW = 84;
    EPERM = 1;
    EPIPE = 32;
    EPROTO = 100;
    EPROTONOSUPPORT = 43;
    EPROTOTYPE = 41;
    ERANGE = 34;
    EROFS = 30;
    ESPIPE = 29;
    ESRCH = 3;
    ESTALE = 70;
    ETIME = 101;
    ETIMEDOUT = 60;
    ETXTBSY = 26;
    EWOULDBLOCK = 35;
    EXDEV = 18;
    WSAEINTR = 10004;
    WSAEBADF = 10009;
    WSAEACCES = 10013;
    WSAEFAULT = 10014;
    WSAEINVAL = 10022;
    WSAEMFILE = 10024;
    WSAEWOULDBLOCK = 10035;
    WSAEINPROGRESS = 10036;
    WSAEALREADY = 10037;
    WSAENOTSOCK = 10038;
    WSAEDESTADDRREQ = 10039;
    WSAEMSGSIZE = 10040;
    WSAEPROTOTYPE = 10041;
    WSAENOPROTOOPT = 10042;
    WSAEPROTONOSUPPORT = 10043;
    WSAESOCKTNOSUPPORT = 10044;
    WSAEOPNOTSUPP = 10045;
    WSAEPFNOSUPPORT = 10046;
    WSAEAFNOSUPPORT = 10047;
    WSAEADDRINUSE = 10048;
    WSAEADDRNOTAVAIL = 10049;
    WSAENETDOWN = 10050;
    WSAENETUNREACH = 10051;
    WSAENETRESET = 10052;
    WSAECONNABORTED = 10053;
    WSAECONNRESET = 10054;
    WSAENOBUFS = 10055;
    WSAEISCONN = 10056;
    WSAENOTCONN = 10057;
    WSAESHUTDOWN = 10058;
    WSAETOOMANYREFS = 10059;
    WSAETIMEDOUT = 10060;
    WSAECONNREFUSED = 10061;
    WSAELOOP = 10062;
    WSAENAMETOOLONG = 10063;
    WSAEHOSTDOWN = 10064;
    WSAEHOSTUNREACH = 10065;
    WSAENOTEMPTY = 10066;
    WSAEPROCLIM = 10067;
    WSAEUSERS = 10068;
    WSAEDQUOT = 10069;
    WSAESTALE = 10070;
    WSAEREMOTE = 10071;
    WSASYSNOTREADY = 10091;
    WSAVERNOTSUPPORTED = 10092;
    WSANOTINITIALISED = 10093;
    WSAEDISCON = 10101;
    WSAENOMORE = 10102;
    WSAECANCELLED = 10103;
    WSAEINVALIDPROCTABLE = 10104;
    WSAEINVALIDPROVIDER = 10105;
    WSAEPROVIDERFAILEDINIT = 10106;
    WSASYSCALLFAILURE = 10107;
    WSASERVICE_NOT_FOUND = 10108;
    WSATYPE_NOT_FOUND = 100109;
    WSA_E_NO_MORE = 10110;
    WSA_E_CANCELLED = 10111;
    WSAEREFUSED = 10112;
    SIGHUP = 1;
    SIGINT = 2;
    SIGQUIT = 3;
    SIGILL = 4;
    SIGTRAP = 5;
    SIGABRT = 6;
    SIGIOT = 6;
    SIGBUS = 10;
    SIGFPE = 8;
    SIGKILL = 9;
    SIGUSR1 = 30;
    SIGSEGV = 11;
    SIGUSR2 = 31;
    SIGPIPE = 13;
    SIGALRM = 14;
    SIGTERM = 15;
    SIGCHLD = 20;
    SIGCONT = 19;
    SIGSTOP = 17;
    SIGTSTP = 18;
    SIGTTIN = 21;
    SIGTTOU = 22;
    SIGURG = 16;
    SIGXCPU = 24;
    SIGXFSZ = 25;
    SIGVTALRM = 26;
    SIGPROF = 27;
    SIGWINCH = 28;
    SIGIO = 23;
    SIGINFO = 29;
    SIGSYS = 12;
    SIGPOLL = 34;
    SIGPWR = 29;
    SIGBREAK = 21;
    SIGSTKFLT = 16;
    SIGUNUSED = 31;
    SIGLOST = 29;
    PRIORITY_LOW = 19;
    PRIORITY_BELOW_NORMAL = 10;
    PRIORITY_NORMAL = 0;
    PRIORITY_ABOVE_NORMAL = -7;
    PRIORITY_HIGH = -14;
    PRIORITY_HIGHEST = -20;
    os_default = {
      UV_UDP_REUSEADDR,
      dlopen: {
        RTLD_LAZY,
        RTLD_NOW,
        RTLD_GLOBAL,
        RTLD_LOCAL,
        RTLD_DEEPBIND
      },
      errno: {
        E2BIG,
        EACCES,
        EADDRINUSE,
        EADDRNOTAVAIL,
        EAFNOSUPPORT,
        EAGAIN,
        EALREADY,
        EBADF,
        EBADMSG,
        EBUSY,
        ECANCELED,
        ECHILD,
        ECONNABORTED,
        ECONNREFUSED,
        ECONNRESET,
        EDEADLK,
        EDESTADDRREQ,
        EDOM,
        EDQUOT,
        EEXIST,
        EFAULT,
        EFBIG,
        EHOSTUNREACH,
        EIDRM,
        EILSEQ,
        EINPROGRESS,
        EINTR,
        EINVAL,
        EIO,
        EISCONN,
        EISDIR,
        ELOOP,
        EMFILE,
        EMLINK,
        EMSGSIZE,
        EMULTIHOP,
        ENAMETOOLONG,
        ENETDOWN,
        ENETRESET,
        ENETUNREACH,
        ENFILE,
        ENOBUFS,
        ENODATA,
        ENODEV,
        ENOENT,
        ENOEXEC,
        ENOLCK,
        ENOLINK,
        ENOMEM,
        ENOMSG,
        ENOPROTOOPT,
        ENOSPC,
        ENOSR,
        ENOSTR,
        ENOSYS,
        ENOTCONN,
        ENOTDIR,
        ENOTEMPTY,
        ENOTSOCK,
        ENOTSUP,
        ENOTTY,
        ENXIO,
        EOPNOTSUPP,
        EOVERFLOW,
        EPERM,
        EPIPE,
        EPROTO,
        EPROTONOSUPPORT,
        EPROTOTYPE,
        ERANGE,
        EROFS,
        ESPIPE,
        ESRCH,
        ESTALE,
        ETIME,
        ETIMEDOUT,
        ETXTBSY,
        EWOULDBLOCK,
        EXDEV,
        WSAEINTR,
        WSAEBADF,
        WSAEACCES,
        WSAEFAULT,
        WSAEINVAL,
        WSAEMFILE,
        WSAEWOULDBLOCK,
        WSAEINPROGRESS,
        WSAEALREADY,
        WSAENOTSOCK,
        WSAEDESTADDRREQ,
        WSAEMSGSIZE,
        WSAEPROTOTYPE,
        WSAENOPROTOOPT,
        WSAEPROTONOSUPPORT,
        WSAESOCKTNOSUPPORT,
        WSAEOPNOTSUPP,
        WSAEPFNOSUPPORT,
        WSAEAFNOSUPPORT,
        WSAEADDRINUSE,
        WSAEADDRNOTAVAIL,
        WSAENETDOWN,
        WSAENETUNREACH,
        WSAENETRESET,
        WSAECONNABORTED,
        WSAECONNRESET,
        WSAENOBUFS,
        WSAEISCONN,
        WSAENOTCONN,
        WSAESHUTDOWN,
        WSAETOOMANYREFS,
        WSAETIMEDOUT,
        WSAECONNREFUSED,
        WSAELOOP,
        WSAENAMETOOLONG,
        WSAEHOSTDOWN,
        WSAEHOSTUNREACH,
        WSAENOTEMPTY,
        WSAEPROCLIM,
        WSAEUSERS,
        WSAEDQUOT,
        WSAESTALE,
        WSAEREMOTE,
        WSASYSNOTREADY,
        WSAVERNOTSUPPORTED,
        WSANOTINITIALISED,
        WSAEDISCON,
        WSAENOMORE,
        WSAECANCELLED,
        WSAEINVALIDPROCTABLE,
        WSAEINVALIDPROVIDER,
        WSAEPROVIDERFAILEDINIT,
        WSASYSCALLFAILURE,
        WSASERVICE_NOT_FOUND,
        WSATYPE_NOT_FOUND,
        WSA_E_NO_MORE,
        WSA_E_CANCELLED,
        WSAEREFUSED
      },
      signals: {
        SIGHUP,
        SIGINT,
        SIGQUIT,
        SIGILL,
        SIGTRAP,
        SIGABRT,
        SIGIOT,
        SIGBUS,
        SIGFPE,
        SIGKILL,
        SIGUSR1,
        SIGSEGV,
        SIGUSR2,
        SIGPIPE,
        SIGALRM,
        SIGTERM,
        SIGCHLD,
        SIGCONT,
        SIGSTOP,
        SIGTSTP,
        SIGTTIN,
        SIGTTOU,
        SIGURG,
        SIGXCPU,
        SIGXFSZ,
        SIGVTALRM,
        SIGPROF,
        SIGWINCH,
        SIGIO,
        SIGINFO,
        SIGSYS,
        SIGBREAK,
        SIGLOST,
        SIGPWR,
        SIGPOLL,
        SIGSTKFLT,
        SIGUNUSED
      },
      priority: {
        PRIORITY_LOW,
        PRIORITY_BELOW_NORMAL,
        PRIORITY_NORMAL,
        PRIORITY_ABOVE_NORMAL,
        PRIORITY_HIGH,
        PRIORITY_HIGHEST
      }
    };
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/os/internal/constants.mjs
var constants2;
var init_constants2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/os/internal/constants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_os();
    constants2 = {
      ...os_default
    };
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/os/index.mjs
var NUM_CPUS, availableParallelism, arch2, machine, endianness, cpus, getPriority, setPriority, homedir, tmpdir, devNull, freemem, totalmem, loadavg, uptime2, hostname, networkInterfaces, platform2, type, release2, version2, userInfo, EOL, os_default2;
var init_os2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/os/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_constants2();
    NUM_CPUS = 8;
    availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
    arch2 = /* @__PURE__ */ __name(() => "", "arch");
    machine = /* @__PURE__ */ __name(() => "", "machine");
    endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
    cpus = /* @__PURE__ */ __name(() => {
      const info3 = {
        model: "",
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      };
      return Array.from({ length: NUM_CPUS }, () => info3);
    }, "cpus");
    getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
    setPriority = notImplemented("os.setPriority");
    homedir = /* @__PURE__ */ __name(() => "/", "homedir");
    tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
    devNull = "/dev/null";
    freemem = /* @__PURE__ */ __name(() => 0, "freemem");
    totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
    loadavg = /* @__PURE__ */ __name(() => [0, 0, 0], "loadavg");
    uptime2 = /* @__PURE__ */ __name(() => 0, "uptime");
    hostname = /* @__PURE__ */ __name(() => "", "hostname");
    networkInterfaces = /* @__PURE__ */ __name(() => {
      return {
        lo0: [
          {
            address: "127.0.0.1",
            netmask: "255.0.0.0",
            family: "IPv4",
            mac: "00:00:00:00:00:00",
            internal: true,
            cidr: "127.0.0.1/8"
          },
          {
            address: "::1",
            netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
            family: "IPv6",
            mac: "00:00:00:00:00:00",
            internal: true,
            cidr: "::1/128",
            scopeid: 0
          },
          {
            address: "fe80::1",
            netmask: "ffff:ffff:ffff:ffff::",
            family: "IPv6",
            mac: "00:00:00:00:00:00",
            internal: true,
            cidr: "fe80::1/64",
            scopeid: 1
          }
        ]
      };
    }, "networkInterfaces");
    platform2 = /* @__PURE__ */ __name(() => "linux", "platform");
    type = /* @__PURE__ */ __name(() => "Linux", "type");
    release2 = /* @__PURE__ */ __name(() => "", "release");
    version2 = /* @__PURE__ */ __name(() => "", "version");
    userInfo = /* @__PURE__ */ __name((opts) => {
      const encode5 = /* @__PURE__ */ __name((str) => {
        if (opts?.encoding) {
          const buff = Buffer.from(str);
          return opts.encoding === "buffer" ? buff : buff.toString(opts.encoding);
        }
        return str;
      }, "encode");
      return {
        gid: 1e3,
        uid: 1e3,
        homedir: encode5("/"),
        shell: encode5("/bin/sh"),
        username: encode5("root")
      };
    }, "userInfo");
    EOL = "\n";
    os_default2 = {
      arch: arch2,
      availableParallelism,
      constants: constants2,
      cpus,
      EOL,
      endianness,
      devNull,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      machine,
      networkInterfaces,
      platform: platform2,
      release: release2,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime: uptime2,
      userInfo,
      version: version2
    };
  }
});

// node-built-in-modules:os
var require_os = __commonJS({
  "node-built-in-modules:os"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_os2();
    module.exports = os_default2;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/web.mjs
var web_exports = {};
__export(web_exports, {
  getRandomValues: () => getRandomValues,
  randomUUID: () => randomUUID,
  subtle: () => subtle
});
var subtle, randomUUID, getRandomValues;
var init_web = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/web.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    subtle = globalThis.crypto?.subtle;
    randomUUID = /* @__PURE__ */ __name(() => {
      return globalThis.crypto?.randomUUID();
    }, "randomUUID");
    getRandomValues = /* @__PURE__ */ __name((array) => {
      return globalThis.crypto?.getRandomValues(array);
    }, "getRandomValues");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/node.mjs
var node_exports = {};
__export(node_exports, {
  Certificate: () => Certificate,
  Cipher: () => Cipher,
  Cipheriv: () => Cipheriv,
  Decipher: () => Decipher,
  Decipheriv: () => Decipheriv,
  DiffieHellman: () => DiffieHellman,
  DiffieHellmanGroup: () => DiffieHellmanGroup,
  ECDH: () => ECDH,
  Hash: () => Hash,
  Hmac: () => Hmac,
  KeyObject: () => KeyObject,
  Sign: () => Sign,
  Verify: () => Verify,
  X509Certificate: () => X509Certificate,
  checkPrime: () => checkPrime,
  checkPrimeSync: () => checkPrimeSync,
  constants: () => constants3,
  createCipher: () => createCipher,
  createCipheriv: () => createCipheriv,
  createDecipher: () => createDecipher,
  createDecipheriv: () => createDecipheriv,
  createDiffieHellman: () => createDiffieHellman,
  createDiffieHellmanGroup: () => createDiffieHellmanGroup,
  createECDH: () => createECDH,
  createHash: () => createHash,
  createHmac: () => createHmac,
  createPrivateKey: () => createPrivateKey,
  createPublicKey: () => createPublicKey,
  createSecretKey: () => createSecretKey,
  createSign: () => createSign,
  createVerify: () => createVerify,
  diffieHellman: () => diffieHellman,
  fips: () => fips,
  generateKey: () => generateKey,
  generateKeyPair: () => generateKeyPair,
  generateKeyPairSync: () => generateKeyPairSync,
  generateKeySync: () => generateKeySync,
  generatePrime: () => generatePrime,
  generatePrimeSync: () => generatePrimeSync,
  getCipherInfo: () => getCipherInfo,
  getCiphers: () => getCiphers,
  getCurves: () => getCurves,
  getDiffieHellman: () => getDiffieHellman,
  getFips: () => getFips,
  getHashes: () => getHashes,
  hash: () => hash,
  hkdf: () => hkdf,
  hkdfSync: () => hkdfSync,
  pbkdf2: () => pbkdf2,
  pbkdf2Sync: () => pbkdf2Sync,
  privateDecrypt: () => privateDecrypt,
  privateEncrypt: () => privateEncrypt,
  pseudoRandomBytes: () => pseudoRandomBytes,
  publicDecrypt: () => publicDecrypt,
  publicEncrypt: () => publicEncrypt,
  randomBytes: () => randomBytes,
  randomFill: () => randomFill,
  randomFillSync: () => randomFillSync,
  randomInt: () => randomInt,
  scrypt: () => scrypt,
  scryptSync: () => scryptSync,
  secureHeapUsed: () => secureHeapUsed,
  setEngine: () => setEngine,
  setFips: () => setFips,
  sign: () => sign,
  timingSafeEqual: () => timingSafeEqual,
  verify: () => verify,
  webcrypto: () => webcrypto
});
var MAX_RANDOM_VALUE_BYTES, webcrypto, randomBytes, fips, constants3, checkPrime, checkPrimeSync, createCipher, createDecipher, pseudoRandomBytes, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, diffieHellman, generatePrime, generatePrimeSync, getCiphers, getCipherInfo, getCurves, getDiffieHellman, getHashes, hkdf, hkdfSync, pbkdf2, pbkdf2Sync, generateKeyPair, generateKeyPairSync, generateKey, generateKeySync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomFill, randomFillSync, randomInt, scrypt, scryptSync, sign, setEngine, timingSafeEqual, getFips, setFips, verify, secureHeapUsed, hash, Certificate, Cipher, Cipheriv, Decipher, Decipheriv, DiffieHellman, DiffieHellmanGroup, ECDH, Hash, Hmac, KeyObject, Sign, Verify, X509Certificate;
var init_node = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/node.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_web();
    MAX_RANDOM_VALUE_BYTES = 65536;
    webcrypto = new Proxy(
      globalThis.crypto,
      {
        get(_5, key) {
          if (key === "CryptoKey") {
            return globalThis.CryptoKey;
          }
          if (typeof globalThis.crypto[key] === "function") {
            return globalThis.crypto[key].bind(globalThis.crypto);
          }
          return globalThis.crypto[key];
        }
      }
    );
    randomBytes = /* @__PURE__ */ __name((size, cb) => {
      const bytes = Buffer.alloc(size, 0, void 0);
      for (let generated = 0; generated < size; generated += MAX_RANDOM_VALUE_BYTES) {
        getRandomValues(
          Uint8Array.prototype.slice.call(
            bytes,
            generated,
            generated + MAX_RANDOM_VALUE_BYTES
          )
        );
      }
      if (typeof cb === "function") {
        cb(null, bytes);
        return void 0;
      }
      return bytes;
    }, "randomBytes");
    fips = false;
    constants3 = {};
    checkPrime = notImplemented("crypto.checkPrime");
    checkPrimeSync = notImplemented(
      "crypto.checkPrimeSync"
    );
    createCipher = notImplemented("crypto.createCipher");
    createDecipher = notImplemented("crypto.createDecipher");
    pseudoRandomBytes = notImplemented("crypto.pseudoRandomBytes");
    createCipheriv = notImplemented(
      "crypto.createCipheriv"
    );
    createDecipheriv = notImplemented("crypto.createDecipheriv");
    createDiffieHellman = notImplemented("crypto.createDiffieHellman");
    createDiffieHellmanGroup = notImplemented("crypto.createDiffieHellmanGroup");
    createECDH = notImplemented("crypto.createECDH");
    createHash = notImplemented("crypto.createHash");
    createHmac = notImplemented("crypto.createHmac");
    createPrivateKey = notImplemented("crypto.createPrivateKey");
    createPublicKey = notImplemented("crypto.createPublicKey");
    createSecretKey = notImplemented("crypto.createSecretKey");
    createSign = notImplemented("crypto.createSign");
    createVerify = notImplemented(
      "crypto.createVerify"
    );
    diffieHellman = notImplemented(
      "crypto.diffieHellman"
    );
    generatePrime = notImplemented(
      "crypto.generatePrime"
    );
    generatePrimeSync = notImplemented("crypto.generatePrimeSync");
    getCiphers = notImplemented("crypto.getCiphers");
    getCipherInfo = notImplemented(
      "crypto.getCipherInfo"
    );
    getCurves = notImplemented("crypto.getCurves");
    getDiffieHellman = notImplemented("crypto.getDiffieHellman");
    getHashes = notImplemented("crypto.getHashes");
    hkdf = notImplemented("crypto.hkdf");
    hkdfSync = notImplemented("crypto.hkdfSync");
    pbkdf2 = notImplemented("crypto.pbkdf2");
    pbkdf2Sync = notImplemented("crypto.pbkdf2Sync");
    generateKeyPair = notImplemented("crypto.generateKeyPair");
    generateKeyPairSync = notImplemented("crypto.generateKeyPairSync");
    generateKey = notImplemented("crypto.generateKey");
    generateKeySync = notImplemented("crypto.generateKeySync");
    privateDecrypt = notImplemented(
      "crypto.privateDecrypt"
    );
    privateEncrypt = notImplemented(
      "crypto.privateEncrypt"
    );
    publicDecrypt = notImplemented(
      "crypto.publicDecrypt"
    );
    publicEncrypt = notImplemented(
      "crypto.publicEncrypt"
    );
    randomFill = notImplemented("crypto.randomFill");
    randomFillSync = notImplemented(
      "crypto.randomFillSync"
    );
    randomInt = notImplemented("crypto.randomInt");
    scrypt = notImplemented("crypto.scrypt");
    scryptSync = notImplemented("crypto.scryptSync");
    sign = notImplemented("crypto.sign");
    setEngine = notImplemented("crypto.setEngine");
    timingSafeEqual = notImplemented("crypto.timingSafeEqual");
    getFips = notImplemented("crypto.getFips");
    setFips = notImplemented("crypto.setFips");
    verify = notImplemented("crypto.verify");
    secureHeapUsed = notImplemented(
      "crypto.secureHeapUsed"
    );
    hash = notImplemented("crypto.hash");
    Certificate = notImplementedClass(
      "crypto.Certificate"
    );
    Cipher = notImplementedClass(
      "crypto.Cipher"
    );
    Cipheriv = notImplementedClass(
      "crypto.Cipheriv"
      // @ts-expect-error not typed yet
    );
    Decipher = notImplementedClass(
      "crypto.Decipher"
    );
    Decipheriv = notImplementedClass(
      "crypto.Decipheriv"
      // @ts-expect-error not typed yet
    );
    DiffieHellman = notImplementedClass(
      "crypto.DiffieHellman"
    );
    DiffieHellmanGroup = notImplementedClass(
      "crypto.DiffieHellmanGroup"
    );
    ECDH = notImplementedClass(
      "crypto.ECDH"
    );
    Hash = notImplementedClass(
      "crypto.Hash"
    );
    Hmac = notImplementedClass(
      "crypto.Hmac"
    );
    KeyObject = notImplementedClass(
      "crypto.KeyObject"
    );
    Sign = notImplementedClass(
      "crypto.Sign"
    );
    Verify = notImplementedClass(
      "crypto.Verify"
    );
    X509Certificate = notImplementedClass(
      "crypto.X509Certificate"
    );
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/constants.mjs
var constants4, constants_default;
var init_constants3 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/internal/constants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    constants4 = {
      ALPN_ENABLED: 1,
      // Node.js v18 only
      DH_CHECK_P_NOT_PRIME: 1,
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_NOT_SUITABLE_GENERATOR: 8,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      ENGINE_METHOD_ALL: 65535,
      ENGINE_METHOD_CIPHERS: 64,
      ENGINE_METHOD_DH: 4,
      ENGINE_METHOD_DIGESTS: 128,
      ENGINE_METHOD_DSA: 2,
      ENGINE_METHOD_EC: 2048,
      ENGINE_METHOD_NONE: 0,
      ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
      ENGINE_METHOD_PKEY_METHS: 512,
      ENGINE_METHOD_RAND: 8,
      ENGINE_METHOD_RSA: 1,
      OPENSSL_VERSION_NUMBER: 0,
      // explicitly set to 0 to avoid version misdetection
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_HYBRID: 6,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_PKCS1_PADDING: 1,
      RSA_PKCS1_PSS_PADDING: 6,
      RSA_PSS_SALTLEN_AUTO: -2,
      RSA_PSS_SALTLEN_DIGEST: -1,
      RSA_PSS_SALTLEN_MAX_SIGN: -2,
      RSA_X931_PADDING: 5,
      SSL_OP_ALL: 2147485776,
      SSL_OP_ALLOW_NO_DHE_KEX: 1024,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
      SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
      SSL_OP_CISCO_ANYCONNECT: 32768,
      SSL_OP_COOKIE_EXCHANGE: 8192,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
      SSL_OP_EPHEMERAL_RSA: 0,
      // Node.js v18 only
      SSL_OP_LEGACY_SERVER_CONNECT: 4,
      SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
      // Node.js v18 only
      SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
      // Node.js v18 only
      SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
      // Node.js v18 only
      SSL_OP_NETSCAPE_CA_DN_BUG: 0,
      // Node.js v18 only
      SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
      // Node.js v18 only
      SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
      // Node.js v18 only
      SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
      // Node.js v18 only
      SSL_OP_NO_COMPRESSION: 131072,
      SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
      SSL_OP_NO_QUERY_MTU: 4096,
      SSL_OP_NO_RENEGOTIATION: 1073741824,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
      SSL_OP_NO_SSLv2: 0,
      SSL_OP_NO_SSLv3: 33554432,
      SSL_OP_NO_TICKET: 16384,
      SSL_OP_NO_TLSv1_1: 268435456,
      SSL_OP_NO_TLSv1_2: 134217728,
      SSL_OP_NO_TLSv1_3: 536870912,
      SSL_OP_NO_TLSv1: 67108864,
      SSL_OP_PKCS1_CHECK_1: 0,
      // Node.js v18 only
      SSL_OP_PKCS1_CHECK_2: 0,
      // Node.js v18 only
      SSL_OP_PRIORITIZE_CHACHA: 2097152,
      SSL_OP_SINGLE_DH_USE: 0,
      // Node.js v18 only
      SSL_OP_SINGLE_ECDH_USE: 0,
      // Node.js v18 only
      SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
      // Node.js v18 only
      SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
      // Node.js v18 only
      SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
      // Node.js v18 only
      SSL_OP_TLS_D5_BUG: 0,
      // Node.js v18 only
      SSL_OP_TLS_ROLLBACK_BUG: 8388608,
      TLS1_1_VERSION: 0,
      // explicitly set to 0 to avoid version misdetection
      TLS1_2_VERSION: 0,
      // explicitly set to 0 to avoid version misdetection
      TLS1_3_VERSION: 0,
      // explicitly set to 0 to avoid version misdetection
      TLS1_VERSION: 0,
      // explicitly set to 0 to avoid version misdetection
      defaultCoreCipherList: "",
      // explicitly set to "" to avoid version misdetection
      get defaultCipherList() {
        return constants4.defaultCoreCipherList;
      },
      set defaultCipherList(_ignored) {
      }
    };
    constants_default = constants4;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/index.mjs
var crypto_default;
var init_crypto = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_web();
    init_node();
    init_constants3();
    init_web();
    init_node();
    init_constants3();
    crypto_default = {
      ...web_exports,
      ...node_exports,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants: constants_default
    };
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/$cloudflare.mjs
var workerdCrypto, Certificate2, DiffieHellman2, DiffieHellmanGroup2, Hash2, Hmac2, KeyObject2, X509Certificate2, checkPrime2, checkPrimeSync2, createDiffieHellman2, createDiffieHellmanGroup2, createHash2, createHmac2, createPrivateKey2, createPublicKey2, createSecretKey2, generateKey2, generateKeyPair2, generateKeyPairSync2, generateKeySync2, generatePrime2, generatePrimeSync2, getCiphers2, getCurves2, getDiffieHellman2, getFips2, getHashes2, hkdf2, hkdfSync2, pbkdf22, pbkdf2Sync2, randomBytes2, randomFill2, randomFillSync2, randomInt2, randomUUID2, scrypt2, scryptSync2, secureHeapUsed2, setEngine2, setFips2, subtle2, timingSafeEqual2, getRandomValues2, webcrypto2, fips2, cloudflare_default3;
var init_cloudflare4 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/crypto/$cloudflare.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_crypto();
    init_crypto();
    workerdCrypto = process.getBuiltinModule("node:crypto");
    ({
      Certificate: Certificate2,
      DiffieHellman: DiffieHellman2,
      DiffieHellmanGroup: DiffieHellmanGroup2,
      Hash: Hash2,
      Hmac: Hmac2,
      KeyObject: KeyObject2,
      X509Certificate: X509Certificate2,
      checkPrime: checkPrime2,
      checkPrimeSync: checkPrimeSync2,
      createDiffieHellman: createDiffieHellman2,
      createDiffieHellmanGroup: createDiffieHellmanGroup2,
      createHash: createHash2,
      createHmac: createHmac2,
      createPrivateKey: createPrivateKey2,
      createPublicKey: createPublicKey2,
      createSecretKey: createSecretKey2,
      generateKey: generateKey2,
      generateKeyPair: generateKeyPair2,
      generateKeyPairSync: generateKeyPairSync2,
      generateKeySync: generateKeySync2,
      generatePrime: generatePrime2,
      generatePrimeSync: generatePrimeSync2,
      getCiphers: getCiphers2,
      getCurves: getCurves2,
      getDiffieHellman: getDiffieHellman2,
      getFips: getFips2,
      getHashes: getHashes2,
      hkdf: hkdf2,
      hkdfSync: hkdfSync2,
      pbkdf2: pbkdf22,
      pbkdf2Sync: pbkdf2Sync2,
      randomBytes: randomBytes2,
      randomFill: randomFill2,
      randomFillSync: randomFillSync2,
      randomInt: randomInt2,
      randomUUID: randomUUID2,
      scrypt: scrypt2,
      scryptSync: scryptSync2,
      secureHeapUsed: secureHeapUsed2,
      setEngine: setEngine2,
      setFips: setFips2,
      subtle: subtle2,
      timingSafeEqual: timingSafeEqual2
    } = workerdCrypto);
    getRandomValues2 = workerdCrypto.getRandomValues.bind(
      workerdCrypto.webcrypto
    );
    webcrypto2 = {
      CryptoKey: webcrypto.CryptoKey,
      getRandomValues: getRandomValues2,
      randomUUID: randomUUID2,
      subtle: subtle2
    };
    fips2 = workerdCrypto.fips;
    cloudflare_default3 = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      Certificate: Certificate2,
      Cipher,
      Cipheriv,
      Decipher,
      Decipheriv,
      ECDH,
      Sign,
      Verify,
      X509Certificate: X509Certificate2,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants: constants_default,
      createCipheriv,
      createDecipheriv,
      createECDH,
      createSign,
      createVerify,
      diffieHellman,
      getCipherInfo,
      hash,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      scrypt: scrypt2,
      scryptSync: scryptSync2,
      sign,
      verify,
      // default-only export from unenv
      createCipher,
      createDecipher,
      pseudoRandomBytes,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      DiffieHellman: DiffieHellman2,
      DiffieHellmanGroup: DiffieHellmanGroup2,
      Hash: Hash2,
      Hmac: Hmac2,
      KeyObject: KeyObject2,
      checkPrime: checkPrime2,
      checkPrimeSync: checkPrimeSync2,
      createDiffieHellman: createDiffieHellman2,
      createDiffieHellmanGroup: createDiffieHellmanGroup2,
      createHash: createHash2,
      createHmac: createHmac2,
      createPrivateKey: createPrivateKey2,
      createPublicKey: createPublicKey2,
      createSecretKey: createSecretKey2,
      generateKey: generateKey2,
      generateKeyPair: generateKeyPair2,
      generateKeyPairSync: generateKeyPairSync2,
      generateKeySync: generateKeySync2,
      generatePrime: generatePrime2,
      generatePrimeSync: generatePrimeSync2,
      getCiphers: getCiphers2,
      getCurves: getCurves2,
      getDiffieHellman: getDiffieHellman2,
      getFips: getFips2,
      getHashes: getHashes2,
      getRandomValues: getRandomValues2,
      hkdf: hkdf2,
      hkdfSync: hkdfSync2,
      pbkdf2: pbkdf22,
      pbkdf2Sync: pbkdf2Sync2,
      randomBytes: randomBytes2,
      randomFill: randomFill2,
      randomFillSync: randomFillSync2,
      randomInt: randomInt2,
      randomUUID: randomUUID2,
      secureHeapUsed: secureHeapUsed2,
      setEngine: setEngine2,
      setFips: setFips2,
      subtle: subtle2,
      timingSafeEqual: timingSafeEqual2,
      // default-only export from workerd
      fips: fips2,
      // special-cased deep merged symbols
      webcrypto: webcrypto2
    };
  }
});

// node-built-in-modules:crypto
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_cloudflare4();
    module.exports = cloudflare_default3;
  }
});

// node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "16.4.5",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        "test:coverage": "tap --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/main.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var fs = require_fs();
    var path2 = require_path();
    var os = require_os();
    var crypto2 = require_crypto();
    var packageJson = require_package();
    var version4 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse5(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    __name(parse5, "parse");
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i3 = 0; i3 < length; i3++) {
        try {
          const key = keys[i3].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error4) {
          if (i3 + 1 >= length) {
            throw error4;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    __name(_parseVault, "_parseVault");
    function _log(message2) {
      console.log(`[dotenv@${version4}][INFO] ${message2}`);
    }
    __name(_log, "_log");
    function _warn(message2) {
      console.log(`[dotenv@${version4}][WARN] ${message2}`);
    }
    __name(_warn, "_warn");
    function _debug(message2) {
      console.log(`[dotenv@${version4}][DEBUG] ${message2}`);
    }
    __name(_debug, "_debug");
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    __name(_dotenvKey, "_dotenvKey");
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error4) {
        if (error4.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error4;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    __name(_instructions, "_instructions");
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    __name(_vaultPath, "_vaultPath");
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    __name(_resolveHome, "_resolveHome");
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    __name(_configVault, "_configVault");
    function configDotenv(options) {
      const dotenvPath = path2.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug3 = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug3) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path3 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(path3, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e2) {
          if (debug3) {
            _debug(`Failed to load ${path3} ${e2.message}`);
          }
          lastError = e2;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    __name(configDotenv, "configDotenv");
    function config2(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    __name(config2, "config");
    function decrypt4(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce2 = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce2);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error4) {
        const isRange = error4 instanceof RangeError;
        const invalidKeyLength = error4.message === "Invalid key length";
        const decryptionFailed = error4.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error4;
        }
      }
    }
    __name(decrypt4, "decrypt");
    function populate(processEnv, parsed, options = {}) {
      const debug3 = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug3) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    __name(populate, "populate");
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config2,
      decrypt: decrypt4,
      parse: parse5,
      populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  }
});

// node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS({
  "node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/env-options.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var options = {};
    if (process.env.DOTENV_CONFIG_ENCODING != null) {
      options.encoding = process.env.DOTENV_CONFIG_ENCODING;
    }
    if (process.env.DOTENV_CONFIG_PATH != null) {
      options.path = process.env.DOTENV_CONFIG_PATH;
    }
    if (process.env.DOTENV_CONFIG_DEBUG != null) {
      options.debug = process.env.DOTENV_CONFIG_DEBUG;
    }
    if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
      options.override = process.env.DOTENV_CONFIG_OVERRIDE;
    }
    if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
      options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
    }
    module.exports = options;
  }
});

// node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS({
  "node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/cli-options.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var re = /^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;
    module.exports = /* @__PURE__ */ __name(function optionMatcher(args) {
      return args.reduce(function(acc, cur) {
        const matches = cur.match(re);
        if (matches) {
          acc[matches[1]] = matches[2];
        }
        return acc;
      }, {});
    }, "optionMatcher");
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      __name(apply, "apply");
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      __name(arrayAggregator, "arrayAggregator");
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEach, "arrayEach");
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEachRight, "arrayEachRight");
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      __name(arrayEvery, "arrayEvery");
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      __name(arrayFilter, "arrayFilter");
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      __name(arrayIncludes, "arrayIncludes");
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      __name(arrayIncludesWith, "arrayIncludesWith");
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      __name(arrayMap, "arrayMap");
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      __name(arrayPush, "arrayPush");
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      __name(arrayReduce, "arrayReduce");
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      __name(arrayReduceRight, "arrayReduceRight");
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      __name(arraySome, "arraySome");
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      __name(asciiToArray, "asciiToArray");
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      __name(asciiWords, "asciiWords");
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      __name(baseFindKey, "baseFindKey");
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseFindIndex, "baseFindIndex");
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      __name(baseIndexOf, "baseIndexOf");
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseIndexOfWith, "baseIndexOfWith");
      function baseIsNaN(value) {
        return value !== value;
      }
      __name(baseIsNaN, "baseIsNaN");
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      __name(baseMean, "baseMean");
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      __name(baseProperty, "baseProperty");
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      __name(basePropertyOf, "basePropertyOf");
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      __name(baseReduce, "baseReduce");
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      __name(baseSortBy, "baseSortBy");
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      __name(baseSum, "baseSum");
      function baseTimes(n3, iteratee) {
        var index = -1, result = Array(n3);
        while (++index < n3) {
          result[index] = iteratee(index);
        }
        return result;
      }
      __name(baseTimes, "baseTimes");
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      __name(baseToPairs, "baseToPairs");
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      __name(baseTrim, "baseTrim");
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      __name(baseUnary, "baseUnary");
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      __name(baseValues, "baseValues");
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      __name(cacheHas, "cacheHas");
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsStartIndex, "charsStartIndex");
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsEndIndex, "charsEndIndex");
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      __name(countHolders, "countHolders");
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      __name(escapeStringChar, "escapeStringChar");
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      __name(getValue, "getValue");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      __name(hasUnicode, "hasUnicode");
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      __name(hasUnicodeWord, "hasUnicodeWord");
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      __name(iteratorToArray, "iteratorToArray");
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      __name(mapToArray, "mapToArray");
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg, "overArg");
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      __name(replaceHolders, "replaceHolders");
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      __name(setToArray, "setToArray");
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      __name(setToPairs, "setToPairs");
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      __name(strictIndexOf, "strictIndexOf");
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      __name(strictLastIndexOf, "strictLastIndexOf");
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      __name(stringSize, "stringSize");
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      __name(stringToArray, "stringToArray");
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      __name(trimmedEndIndex, "trimmedEndIndex");
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      __name(unicodeSize, "unicodeSize");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      __name(unicodeToArray, "unicodeToArray");
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      __name(unicodeWords, "unicodeWords");
      var runInContext = /* @__PURE__ */ __name(function runInContext2(context2) {
        context2 = context2 == null ? root : _5.defaults(root.Object(), context2, _5.pick(root, contextProps));
        var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context2["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike2(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        __name(lodash, "lodash");
        var baseCreate = function() {
          function object() {
          }
          __name(object, "object");
          return function(proto) {
            if (!isObject3(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        __name(baseLodash, "baseLodash");
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        __name(LodashWrapper, "LodashWrapper");
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        __name(LazyWrapper, "LazyWrapper");
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        __name(lazyClone, "lazyClone");
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        __name(lazyReverse, "lazyReverse");
        function lazyValue() {
          var array = this.__wrapped__.value(), dir3 = this.__dir__, isArr = isArray(array), isRight = dir3 < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir3;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        __name(lazyValue, "lazyValue");
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash3(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(Hash3, "Hash");
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        __name(hashClear, "hashClear");
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(hashDelete, "hashDelete");
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        __name(hashGet, "hashGet");
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        __name(hashHas, "hashHas");
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        __name(hashSet, "hashSet");
        Hash3.prototype.clear = hashClear;
        Hash3.prototype["delete"] = hashDelete;
        Hash3.prototype.get = hashGet;
        Hash3.prototype.has = hashHas;
        Hash3.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(ListCache, "ListCache");
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        __name(listCacheClear, "listCacheClear");
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        __name(listCacheDelete, "listCacheDelete");
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        __name(listCacheGet, "listCacheGet");
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        __name(listCacheHas, "listCacheHas");
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        __name(listCacheSet, "listCacheSet");
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(MapCache, "MapCache");
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash3(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash3()
          };
        }
        __name(mapCacheClear, "mapCacheClear");
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(mapCacheDelete, "mapCacheDelete");
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        __name(mapCacheGet, "mapCacheGet");
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        __name(mapCacheHas, "mapCacheHas");
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        __name(mapCacheSet, "mapCacheSet");
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        __name(SetCache, "SetCache");
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        __name(setCacheAdd, "setCacheAdd");
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        __name(setCacheHas, "setCacheHas");
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        __name(Stack, "Stack");
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        __name(stackClear, "stackClear");
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        __name(stackDelete, "stackDelete");
        function stackGet(key) {
          return this.__data__.get(key);
        }
        __name(stackGet, "stackGet");
        function stackHas(key) {
          return this.__data__.has(key);
        }
        __name(stackHas, "stackHas");
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        __name(stackSet, "stackSet");
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(arrayLikeKeys, "arrayLikeKeys");
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        __name(arraySample, "arraySample");
        function arraySampleSize(array, n3) {
          return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
        }
        __name(arraySampleSize, "arraySampleSize");
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        __name(arrayShuffle, "arrayShuffle");
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        __name(assignMergeValue, "assignMergeValue");
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        __name(assignValue, "assignValue");
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        __name(assocIndexOf, "assocIndexOf");
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        __name(baseAggregator, "baseAggregator");
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        __name(baseAssign, "baseAssign");
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        __name(baseAssignIn, "baseAssignIn");
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        __name(baseAssignValue, "baseAssignValue");
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get3(object, paths[index]);
          }
          return result2;
        }
        __name(baseAt, "baseAt");
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        __name(baseClamp, "baseClamp");
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject3(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag2]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag2, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        __name(baseClone, "baseClone");
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        __name(baseConforms, "baseConforms");
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        __name(baseConformsTo, "baseConformsTo");
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        __name(baseDelay, "baseDelay");
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseDifference, "baseDifference");
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        __name(baseEvery, "baseEvery");
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        __name(baseExtremum, "baseExtremum");
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        __name(baseFill, "baseFill");
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        __name(baseFilter, "baseFilter");
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        __name(baseFlatten, "baseFlatten");
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        __name(baseForOwn, "baseForOwn");
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        __name(baseForOwnRight, "baseForOwnRight");
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        __name(baseFunctions, "baseFunctions");
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index = 0, length = path2.length;
          while (object != null && index < length) {
            object = object[toKey(path2[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        __name(baseGet, "baseGet");
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        __name(baseGetAllKeys, "baseGetAllKeys");
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        __name(baseGetTag, "baseGetTag");
        function baseGt(value, other) {
          return value > other;
        }
        __name(baseGt, "baseGt");
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        __name(baseHas, "baseHas");
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        __name(baseHasIn, "baseHasIn");
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        __name(baseInRange, "baseInRange");
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseIntersection, "baseIntersection");
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        __name(baseInverter, "baseInverter");
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        __name(baseInvoke, "baseInvoke");
        function baseIsArguments(value) {
          return isObjectLike2(value) && baseGetTag(value) == argsTag;
        }
        __name(baseIsArguments, "baseIsArguments");
        function baseIsArrayBuffer(value) {
          return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
        }
        __name(baseIsArrayBuffer, "baseIsArrayBuffer");
        function baseIsDate(value) {
          return isObjectLike2(value) && baseGetTag(value) == dateTag;
        }
        __name(baseIsDate, "baseIsDate");
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        __name(baseIsEqual, "baseIsEqual");
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        __name(baseIsEqualDeep, "baseIsEqualDeep");
        function baseIsMap(value) {
          return isObjectLike2(value) && getTag(value) == mapTag;
        }
        __name(baseIsMap, "baseIsMap");
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        __name(baseIsMatch, "baseIsMatch");
        function baseIsNative(value) {
          if (!isObject3(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        __name(baseIsNative, "baseIsNative");
        function baseIsRegExp(value) {
          return isObjectLike2(value) && baseGetTag(value) == regexpTag;
        }
        __name(baseIsRegExp, "baseIsRegExp");
        function baseIsSet(value) {
          return isObjectLike2(value) && getTag(value) == setTag;
        }
        __name(baseIsSet, "baseIsSet");
        function baseIsTypedArray(value) {
          return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        __name(baseIsTypedArray, "baseIsTypedArray");
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        __name(baseIteratee, "baseIteratee");
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(baseKeys, "baseKeys");
        function baseKeysIn(object) {
          if (!isObject3(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(baseKeysIn, "baseKeysIn");
        function baseLt(value, other) {
          return value < other;
        }
        __name(baseLt, "baseLt");
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        __name(baseMap, "baseMap");
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        __name(baseMatches, "baseMatches");
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get3(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        __name(baseMatchesProperty, "baseMatchesProperty");
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject3(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        __name(baseMerge, "baseMerge");
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject3(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        __name(baseMergeDeep, "baseMergeDeep");
        function baseNth(array, n3) {
          var length = array.length;
          if (!length) {
            return;
          }
          n3 += n3 < 0 ? length : 0;
          return isIndex(n3, length) ? array[n3] : undefined2;
        }
        __name(baseNth, "baseNth");
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        __name(baseOrderBy, "baseOrderBy");
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        __name(basePick, "basePick");
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path2 = paths[index], value = baseGet(object, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object), value);
            }
          }
          return result2;
        }
        __name(basePickBy, "basePickBy");
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        __name(basePropertyDeep, "basePropertyDeep");
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        __name(basePullAll, "basePullAll");
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        __name(basePullAt, "basePullAt");
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        __name(baseRandom, "baseRandom");
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        __name(baseRange, "baseRange");
        function baseRepeat(string, n3) {
          var result2 = "";
          if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n3 % 2) {
              result2 += string;
            }
            n3 = nativeFloor(n3 / 2);
            if (n3) {
              string += string;
            }
          } while (n3);
          return result2;
        }
        __name(baseRepeat, "baseRepeat");
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        __name(baseRest, "baseRest");
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        __name(baseSample, "baseSample");
        function baseSampleSize(collection, n3) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n3, 0, array.length));
        }
        __name(baseSampleSize, "baseSampleSize");
        function baseSet(object, path2, value, customizer) {
          if (!isObject3(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path2[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject3(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        __name(baseSet, "baseSet");
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        __name(baseShuffle, "baseShuffle");
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        __name(baseSlice, "baseSlice");
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        __name(baseSome, "baseSome");
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        __name(baseSortedIndex, "baseSortedIndex");
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        __name(baseSortedIndexBy, "baseSortedIndexBy");
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        __name(baseSortedUniq, "baseSortedUniq");
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        __name(baseToNumber, "baseToNumber");
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(baseToString, "baseToString");
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseUniq, "baseUniq");
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last(path2))];
        }
        __name(baseUnset, "baseUnset");
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        __name(baseUpdate, "baseUpdate");
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        __name(baseWhile, "baseWhile");
        function baseWrapperValue(value, actions2) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions2, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        __name(baseWrapperValue, "baseWrapperValue");
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        __name(baseXor, "baseXor");
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        __name(baseZipObject, "baseZipObject");
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        __name(castArrayLikeObject, "castArrayLikeObject");
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        __name(castFunction, "castFunction");
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        __name(castPath, "castPath");
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        __name(castSlice, "castSlice");
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        __name(cloneBuffer, "cloneBuffer");
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        __name(cloneArrayBuffer, "cloneArrayBuffer");
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        __name(cloneDataView, "cloneDataView");
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        __name(cloneRegExp, "cloneRegExp");
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        __name(cloneSymbol, "cloneSymbol");
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        __name(cloneTypedArray, "cloneTypedArray");
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        __name(compareAscending, "compareAscending");
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        __name(compareMultiple, "compareMultiple");
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        __name(composeArgs, "composeArgs");
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        __name(composeArgsRight, "composeArgsRight");
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        __name(copyArray, "copyArray");
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        __name(copyObject, "copyObject");
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        __name(copySymbols, "copySymbols");
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        __name(copySymbolsIn, "copySymbolsIn");
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        __name(createAggregator, "createAggregator");
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        __name(createAssigner, "createAssigner");
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        __name(createBaseEach, "createBaseEach");
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        __name(createBaseFor, "createBaseFor");
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn3.apply(isBind ? thisArg : this, arguments);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createBind, "createBind");
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        __name(createCaseFirst, "createCaseFirst");
        function createCompounder(callback2) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback2, "");
          };
        }
        __name(createCompounder, "createCompounder");
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject3(result2) ? result2 : thisBinding;
          };
        }
        __name(createCtor, "createCtor");
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn3, this, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createCurry, "createCurry");
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = /* @__PURE__ */ __name(function(key) {
                return iteratee2(iterable[key], key, iterable);
              }, "predicate");
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        __name(createFind, "createFind");
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        __name(createFlow, "createFlow");
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn3 = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn3 = Ctor || createCtor(fn3);
            }
            return fn3.apply(thisBinding, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createHybrid, "createHybrid");
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        __name(createInverter, "createInverter");
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        __name(createMathOperation, "createMathOperation");
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        __name(createOver, "createOver");
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        __name(createPadding, "createPadding");
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn3, isBind ? thisArg : this, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createPartial, "createPartial");
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        __name(createRange, "createRange");
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        __name(createRelationalOperation, "createRelationalOperation");
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        __name(createRecurry, "createRecurry");
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        __name(createRound, "createRound");
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag2 = getTag(object);
            if (tag2 == mapTag) {
              return mapToArray(object);
            }
            if (tag2 == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        __name(createToPairs, "createToPairs");
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        __name(createWrap, "createWrap");
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        __name(customDefaultsAssignIn, "customDefaultsAssignIn");
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject3(objValue) && isObject3(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        __name(customDefaultsMerge, "customDefaultsMerge");
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        __name(customOmitClone, "customOmitClone");
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        __name(equalArrays, "equalArrays");
        function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
          switch (tag2) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq2(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        __name(equalByTag, "equalByTag");
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        __name(equalObjects, "equalObjects");
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        __name(flatRest, "flatRest");
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        __name(getAllKeys, "getAllKeys");
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        __name(getAllKeysIn, "getAllKeysIn");
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        __name(getFuncName, "getFuncName");
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        __name(getHolder, "getHolder");
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        __name(getIteratee, "getIteratee");
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        __name(getMapData, "getMapData");
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        __name(getMatchData, "getMatchData");
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        __name(getNative, "getNative");
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag2;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        __name(getRawTag, "getRawTag");
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = /* @__PURE__ */ __name(function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          }, "getTag");
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        __name(getView, "getView");
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        __name(getWrapDetails, "getWrapDetails");
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length, result2 = false;
          while (++index < length) {
            var key = toKey(path2[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        __name(hasPath, "hasPath");
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        __name(initCloneArray, "initCloneArray");
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        __name(initCloneObject, "initCloneObject");
        function initCloneByTag(object, tag2, isDeep) {
          var Ctor = object.constructor;
          switch (tag2) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        __name(initCloneByTag, "initCloneByTag");
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        __name(insertWrapDetails, "insertWrapDetails");
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        __name(isFlattenable, "isFlattenable");
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        __name(isIndex, "isIndex");
        function isIterateeCall(value, index, object) {
          if (!isObject3(object)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
            return eq2(object[index], value);
          }
          return false;
        }
        __name(isIterateeCall, "isIterateeCall");
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        __name(isKey, "isKey");
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        __name(isKeyable, "isKeyable");
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        __name(isLaziable, "isLaziable");
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        __name(isMasked, "isMasked");
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        __name(isPrototype, "isPrototype");
        function isStrictComparable(value) {
          return value === value && !isObject3(value);
        }
        __name(isStrictComparable, "isStrictComparable");
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        __name(matchesStrictComparable, "matchesStrictComparable");
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        __name(memoizeCapped, "memoizeCapped");
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        __name(mergeData, "mergeData");
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(nativeKeysIn, "nativeKeysIn");
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        __name(objectToString, "objectToString");
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        __name(overRest, "overRest");
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        __name(parent, "parent");
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        __name(reorder, "reorder");
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        __name(safeGet, "safeGet");
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        __name(setWrapToString, "setWrapToString");
        function shortOut(func) {
          var count4 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count4 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count4 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        __name(shortOut, "shortOut");
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        __name(shuffleSelf, "shuffleSelf");
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(toKey, "toKey");
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        __name(toSource, "toSource");
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        __name(updateWrapDetails, "updateWrapDetails");
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        __name(wrapperClone, "wrapperClone");
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        __name(chunk, "chunk");
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        __name(compact, "compact");
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        __name(concat2, "concat");
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        __name(drop, "drop");
        function dropRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        __name(dropRight, "dropRight");
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        __name(dropRightWhile, "dropRightWhile");
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        __name(dropWhile, "dropWhile");
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        __name(fill, "fill");
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        __name(findIndex, "findIndex");
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        __name(findLastIndex, "findLastIndex");
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        __name(flatten, "flatten");
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        __name(flattenDeep, "flattenDeep");
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        __name(flattenDepth, "flattenDepth");
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        __name(fromPairs, "fromPairs");
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        __name(head, "head");
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        __name(indexOf, "indexOf");
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        __name(initial, "initial");
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        __name(join, "join");
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        __name(last, "last");
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        __name(lastIndexOf, "lastIndexOf");
        function nth(array, n3) {
          return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
        }
        __name(nth, "nth");
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        __name(pullAll, "pullAll");
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        __name(pullAllBy, "pullAllBy");
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        __name(pullAllWith, "pullAllWith");
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        __name(remove, "remove");
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        __name(reverse, "reverse");
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        __name(slice, "slice");
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        __name(sortedIndex, "sortedIndex");
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        __name(sortedIndexBy, "sortedIndexBy");
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedIndexOf, "sortedIndexOf");
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        __name(sortedLastIndex, "sortedLastIndex");
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        __name(sortedLastIndexBy, "sortedLastIndexBy");
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedLastIndexOf, "sortedLastIndexOf");
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        __name(sortedUniq, "sortedUniq");
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(sortedUniqBy, "sortedUniqBy");
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        __name(tail, "tail");
        function take(array, n3, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        __name(take, "take");
        function takeRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        __name(takeRight, "takeRight");
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        __name(takeRightWhile, "takeRightWhile");
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        __name(takeWhile, "takeWhile");
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        __name(uniq, "uniq");
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(uniqBy, "uniqBy");
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        __name(uniqWith, "uniqWith");
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group3) {
            if (isArrayLikeObject(group3)) {
              length = nativeMax(group3.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        __name(unzip, "unzip");
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group3) {
            return apply(iteratee2, undefined2, group3);
          });
        }
        __name(unzipWith, "unzipWith");
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        __name(zipObject, "zipObject");
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        __name(zipObjectDeep, "zipObjectDeep");
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        __name(chain, "chain");
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        __name(tap, "tap");
        function thru(value, interceptor) {
          return interceptor(value);
        }
        __name(thru, "thru");
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = /* @__PURE__ */ __name(function(object) {
            return baseAt(object, paths);
          }, "interceptor");
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        __name(wrapperChain, "wrapperChain");
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        __name(wrapperCommit, "wrapperCommit");
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        __name(wrapperNext, "wrapperNext");
        function wrapperToIterator() {
          return this;
        }
        __name(wrapperToIterator, "wrapperToIterator");
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        __name(wrapperPlant, "wrapperPlant");
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        __name(wrapperReverse, "wrapperReverse");
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        __name(wrapperValue, "wrapperValue");
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(every, "every");
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        __name(filter, "filter");
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        __name(flatMap, "flatMap");
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        __name(flatMapDeep, "flatMapDeep");
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        __name(flatMapDepth, "flatMapDepth");
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEach, "forEach");
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEachRight, "forEachRight");
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        __name(includes, "includes");
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(map2, "map");
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        __name(orderBy, "orderBy");
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        __name(reduce, "reduce");
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        __name(reduceRight, "reduceRight");
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        __name(reject, "reject");
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        __name(sample, "sample");
        function sampleSize(collection, n3, guard) {
          if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n3);
        }
        __name(sampleSize, "sampleSize");
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        __name(shuffle, "shuffle");
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag2 = getTag(collection);
          if (tag2 == mapTag || tag2 == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        __name(size, "size");
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(some, "some");
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n3, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        __name(after, "after");
        function ary(func, n3, guard) {
          n3 = guard ? undefined2 : n3;
          n3 = func && n3 == null ? func.length : n3;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
        }
        __name(ary, "ary");
        function before(n3, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n3 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        __name(before, "before");
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        __name(curry, "curry");
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        __name(curryRight, "curryRight");
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject3(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time4) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time4;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          __name(invokeFunc, "invokeFunc");
          function leadingEdge(time4) {
            lastInvokeTime = time4;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time4) : result2;
          }
          __name(leadingEdge, "leadingEdge");
          function remainingWait(time4) {
            var timeSinceLastCall = time4 - lastCallTime, timeSinceLastInvoke = time4 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          __name(remainingWait, "remainingWait");
          function shouldInvoke(time4) {
            var timeSinceLastCall = time4 - lastCallTime, timeSinceLastInvoke = time4 - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          __name(shouldInvoke, "shouldInvoke");
          function timerExpired() {
            var time4 = now2();
            if (shouldInvoke(time4)) {
              return trailingEdge(time4);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time4));
          }
          __name(timerExpired, "timerExpired");
          function trailingEdge(time4) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time4);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          __name(trailingEdge, "trailingEdge");
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          __name(cancel, "cancel");
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          __name(flush, "flush");
          function debounced() {
            var time4 = now2(), isInvoking = shouldInvoke(time4);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time4;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          __name(debounced, "debounced");
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        __name(debounce, "debounce");
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        __name(flip, "flip");
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = /* @__PURE__ */ __name(function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          }, "memoized");
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        __name(memoize, "memoize");
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        __name(negate, "negate");
        function once3(func) {
          return before(2, func);
        }
        __name(once3, "once");
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        __name(rest, "rest");
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        __name(spread, "spread");
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject3(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        __name(throttle, "throttle");
        function unary(func) {
          return ary(func, 1);
        }
        __name(unary, "unary");
        function wrap3(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        __name(wrap3, "wrap");
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        __name(castArray, "castArray");
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        __name(clone, "clone");
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneWith, "cloneWith");
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        __name(cloneDeep, "cloneDeep");
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneDeepWith, "cloneDeepWith");
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        __name(conformsTo, "conformsTo");
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        __name(eq2, "eq");
        var gt3 = createRelationalOperation(baseGt);
        var gte2 = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        __name(isArrayLike, "isArrayLike");
        function isArrayLikeObject(value) {
          return isObjectLike2(value) && isArrayLike(value);
        }
        __name(isArrayLikeObject, "isArrayLikeObject");
        function isBoolean(value) {
          return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag;
        }
        __name(isBoolean, "isBoolean");
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        __name(isElement, "isElement");
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag2 = getTag(value);
          if (tag2 == mapTag || tag2 == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        __name(isEmpty, "isEmpty");
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        __name(isEqual, "isEqual");
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        __name(isEqualWith, "isEqualWith");
        function isError(value) {
          if (!isObjectLike2(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        __name(isError, "isError");
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        __name(isFinite2, "isFinite");
        function isFunction(value) {
          if (!isObject3(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
        }
        __name(isFunction, "isFunction");
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        __name(isInteger, "isInteger");
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        __name(isLength, "isLength");
        function isObject3(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        __name(isObject3, "isObject");
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        __name(isObjectLike2, "isObjectLike");
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        __name(isMatch, "isMatch");
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        __name(isMatchWith, "isMatchWith");
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        __name(isNaN2, "isNaN");
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        __name(isNative, "isNative");
        function isNull2(value) {
          return value === null;
        }
        __name(isNull2, "isNull");
        function isNil(value) {
          return value == null;
        }
        __name(isNil, "isNil");
        function isNumber(value) {
          return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
        }
        __name(isNumber, "isNumber");
        function isPlainObject(value) {
          if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        __name(isPlainObject, "isPlainObject");
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        __name(isSafeInteger, "isSafeInteger");
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
        }
        __name(isString, "isString");
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
        }
        __name(isSymbol, "isSymbol");
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        __name(isUndefined, "isUndefined");
        function isWeakMap(value) {
          return isObjectLike2(value) && getTag(value) == weakMapTag;
        }
        __name(isWeakMap, "isWeakMap");
        function isWeakSet(value) {
          return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
        }
        __name(isWeakSet, "isWeakSet");
        var lt2 = createRelationalOperation(baseLt);
        var lte2 = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag ? setToArray : values;
          return func(value);
        }
        __name(toArray, "toArray");
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        __name(toFinite, "toFinite");
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        __name(toInteger, "toInteger");
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        __name(toLength, "toLength");
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject3(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject3(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        __name(toNumber, "toNumber");
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        __name(toPlainObject, "toPlainObject");
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        __name(toSafeInteger, "toSafeInteger");
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        __name(toString, "toString");
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        __name(create, "create");
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        __name(findKey, "findKey");
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        __name(findLastKey, "findLastKey");
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forIn, "forIn");
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forInRight, "forInRight");
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        __name(forOwn, "forOwn");
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        __name(forOwnRight, "forOwnRight");
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        __name(functions, "functions");
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        __name(functionsIn, "functionsIn");
        function get3(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        __name(get3, "get");
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        __name(has, "has");
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        __name(hasIn, "hasIn");
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        __name(keys, "keys");
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        __name(keysIn, "keysIn");
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        __name(mapKeys, "mapKeys");
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        __name(mapValues, "mapValues");
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        __name(omitBy, "omitBy");
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        __name(pickBy, "pickBy");
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path2[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        __name(result, "result");
        function set(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        __name(set, "set");
        function setWith(object, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value, customizer);
        }
        __name(setWith, "setWith");
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject3(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        __name(transform, "transform");
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        __name(unset, "unset");
        function update(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        __name(update, "update");
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        __name(updateWith, "updateWith");
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        __name(values, "values");
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        __name(valuesIn, "valuesIn");
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        __name(clamp, "clamp");
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        __name(inRange, "inRange");
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        __name(random, "random");
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        __name(capitalize, "capitalize");
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        __name(deburr, "deburr");
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        __name(endsWith, "endsWith");
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        __name(escape, "escape");
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        __name(escapeRegExp, "escapeRegExp");
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        __name(pad, "pad");
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        __name(padEnd, "padEnd");
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        __name(padStart, "padStart");
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        __name(parseInt2, "parseInt");
        function repeat(string, n3, guard) {
          if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          return baseRepeat(toString(string), n3);
        }
        __name(repeat, "repeat");
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        __name(replace, "replace");
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        __name(split, "split");
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        __name(startsWith, "startsWith");
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        __name(template, "template");
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        __name(toLower, "toLower");
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        __name(toUpper, "toUpper");
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        __name(trim, "trim");
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        __name(trimEnd, "trimEnd");
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        __name(trimStart, "trimStart");
        function truncate3(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject3(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        __name(truncate3, "truncate");
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        __name(unescape, "unescape");
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        __name(words, "words");
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        __name(cond, "cond");
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(conforms, "conforms");
        function constant(value) {
          return function() {
            return value;
          };
        }
        __name(constant, "constant");
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        __name(defaultTo, "defaultTo");
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        __name(identity, "identity");
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        __name(iteratee, "iteratee");
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(matches, "matches");
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        __name(matchesProperty, "matchesProperty");
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                  actions2.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        __name(mixin, "mixin");
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        __name(noConflict, "noConflict");
        function noop2() {
        }
        __name(noop2, "noop");
        function nthArg(n3) {
          n3 = toInteger(n3);
          return baseRest(function(args) {
            return baseNth(args, n3);
          });
        }
        __name(nthArg, "nthArg");
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        __name(property, "property");
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        __name(propertyOf, "propertyOf");
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        __name(stubArray, "stubArray");
        function stubFalse() {
          return false;
        }
        __name(stubFalse, "stubFalse");
        function stubObject() {
          return {};
        }
        __name(stubObject, "stubObject");
        function stubString() {
          return "";
        }
        __name(stubString, "stubString");
        function stubTrue() {
          return true;
        }
        __name(stubTrue, "stubTrue");
        function times(n3, iteratee2) {
          n3 = toInteger(n3);
          if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n3 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n3) {
            iteratee2(index);
          }
          return result2;
        }
        __name(times, "times");
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        __name(toPath, "toPath");
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        __name(uniqueId, "uniqueId");
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor2 = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        __name(max, "max");
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        __name(maxBy, "maxBy");
        function mean(array) {
          return baseMean(array, identity);
        }
        __name(mean, "mean");
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        __name(meanBy, "meanBy");
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        __name(min, "min");
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        __name(minBy, "minBy");
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        __name(sum, "sum");
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        __name(sumBy, "sumBy");
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat2;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once3;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap3;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor2;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get3;
        lodash.gt = gt3;
        lodash.gte = gte2;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject3;
        lodash.isObjectLike = isObjectLike2;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt2;
        lodash.lte = lte2;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate3;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n3) {
            n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n3) {
            return this.reverse()[methodName](n3).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = /* @__PURE__ */ __name(function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            }, "interceptor");
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      }, "runInContext");
      var _5 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _5;
        define(function() {
          return _5;
        });
      } else if (freeModule) {
        (freeModule.exports = _5)._ = _5;
        freeExports._ = _5;
      } else {
        root._ = _5;
      }
    }).call(exports);
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/querystring/internal/querystring.mjs
function encodeStr(str, noEscapeTable, hexTable2) {
  const len = str.length;
  if (len === 0)
    return "";
  let out = "";
  let lastPos = 0;
  let i3 = 0;
  outer:
    for (; i3 < len; i3++) {
      let c4 = String.prototype.charCodeAt.call(str, i3);
      while (c4 < 128) {
        if (noEscapeTable[c4] !== 1) {
          if (lastPos < i3)
            out += String.prototype.slice.call(str, lastPos, i3);
          lastPos = i3 + 1;
          out += hexTable2[c4];
        }
        if (++i3 === len)
          break outer;
        c4 = String.prototype.charCodeAt.call(str, i3);
      }
      if (lastPos < i3)
        out += String.prototype.slice.call(str, lastPos, i3);
      if (c4 < 2048) {
        lastPos = i3 + 1;
        out += hexTable2[192 | c4 >> 6] + hexTable2[128 | c4 & 63];
        continue;
      }
      if (c4 < 55296 || c4 >= 57344) {
        lastPos = i3 + 1;
        out += hexTable2[224 | c4 >> 12] + hexTable2[128 | c4 >> 6 & 63] + hexTable2[128 | c4 & 63];
        continue;
      }
      ++i3;
      if (i3 >= len)
        throw new ERR_INVALID_URI();
      const c22 = String.prototype.charCodeAt.call(str, i3) & 1023;
      lastPos = i3 + 1;
      c4 = 65536 + ((c4 & 1023) << 10 | c22);
      out += hexTable2[240 | c4 >> 18] + hexTable2[128 | c4 >> 12 & 63] + hexTable2[128 | c4 >> 6 & 63] + hexTable2[128 | c4 & 63];
    }
  if (lastPos === 0)
    return str;
  if (lastPos < len)
    return out + String.prototype.slice.call(str, lastPos);
  return out;
}
var ERR_INVALID_URI, hexTable, isHexTable;
var init_querystring = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/querystring/internal/querystring.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    ERR_INVALID_URI = class extends URIError {
      code = "ERR_INVALID_URI";
      constructor() {
        super("URI malformed");
      }
    };
    __name(ERR_INVALID_URI, "ERR_INVALID_URI");
    hexTable = Array.from({ length: 256 });
    for (let i3 = 0; i3 < 256; ++i3)
      hexTable[i3] = "%" + String.prototype.toUpperCase.call(
        (i3 < 16 ? "0" : "") + Number.prototype.toString.call(i3, 16)
      );
    isHexTable = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 64 - 79
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 96 - 111
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 112 - 127
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 128 ...
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
      // ... 256
    ]);
    __name(encodeStr, "encodeStr");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/querystring/index.mjs
function unescapeBuffer(s3, decodeSpaces) {
  const out = globalThis.Buffer.allocUnsafe(s3.length);
  let index = 0;
  let outIndex = 0;
  let currentChar;
  let nextChar;
  let hexHigh;
  let hexLow;
  const maxLength = s3.length - 2;
  let hasHex = false;
  while (index < s3.length) {
    currentChar = String.prototype.charCodeAt.call(s3, index);
    if (currentChar === 43 && decodeSpaces) {
      out[outIndex++] = 32;
      index++;
      continue;
    }
    if (currentChar === 37 && index < maxLength) {
      currentChar = String.prototype.charCodeAt.call(s3, ++index);
      hexHigh = unhexTable[currentChar];
      if (hexHigh >= 0) {
        nextChar = String.prototype.charCodeAt.call(s3, ++index);
        hexLow = unhexTable[nextChar];
        if (hexLow >= 0) {
          hasHex = true;
          currentChar = hexHigh * 16 + hexLow;
        } else {
          out[outIndex++] = 37;
          index--;
        }
      } else {
        out[outIndex++] = 37;
        continue;
      }
    }
    out[outIndex++] = currentChar;
    index++;
  }
  return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s3, decodeSpaces) {
  try {
    return decodeURIComponent(s3);
  } catch {
    return unescapeBuffer(s3, decodeSpaces).toString();
  }
}
function qsEscape(str) {
  if (typeof str !== "string") {
    if (typeof str === "object")
      str = String(str);
    else {
      str += "";
    }
  }
  return encodeStr(str, noEscape, hexTable);
}
function stringifyPrimitive(v4) {
  if (typeof v4 === "string")
    return v4;
  if (typeof v4 === "number" && Number.isFinite(v4))
    return "" + v4;
  if (typeof v4 === "bigint")
    return "" + v4;
  if (typeof v4 === "boolean")
    return v4 ? "true" : "false";
  return "";
}
function encodeStringified(v4, encode5) {
  if (typeof v4 === "string")
    return v4.length > 0 ? encode5(v4) : "";
  if (typeof v4 === "number" && Number.isFinite(v4)) {
    return Math.abs(v4) < 1e21 ? "" + v4 : encode5("" + v4);
  }
  if (typeof v4 === "bigint")
    return "" + v4;
  if (typeof v4 === "boolean")
    return v4 ? "true" : "false";
  return "";
}
function encodeStringifiedCustom(v4, encode5) {
  return encode5(stringifyPrimitive(v4));
}
function stringify(obj, sep, eq2, options) {
  sep = sep || "&";
  eq2 = eq2 || "=";
  let encode5 = qsEscape;
  if (options && typeof options.encodeURIComponent === "function") {
    encode5 = options.encodeURIComponent;
  }
  const convert = encode5 === qsEscape ? encodeStringified : encodeStringifiedCustom;
  if (obj !== null && typeof obj === "object") {
    const keys = Object.keys(obj);
    const len = keys.length;
    let fields = "";
    for (let i3 = 0; i3 < len; ++i3) {
      const k3 = keys[i3];
      const v4 = obj[k3];
      let ks2 = convert(k3, encode5);
      ks2 += eq2;
      if (Array.isArray(v4)) {
        const vlen = v4.length;
        if (vlen === 0)
          continue;
        if (fields)
          fields += sep;
        for (let j3 = 0; j3 < vlen; ++j3) {
          if (j3)
            fields += sep;
          fields += ks2;
          fields += convert(v4[j3], encode5);
        }
      } else {
        if (fields)
          fields += sep;
        fields += ks2;
        fields += convert(v4, encode5);
      }
    }
    return fields;
  }
  return "";
}
function charCodes(str) {
  if (str.length === 0)
    return [];
  if (str.length === 1)
    return [String.prototype.charCodeAt.call(str, 0)];
  const ret = Array.from({ length: str.length });
  for (let i3 = 0; i3 < str.length; ++i3)
    ret[i3] = String.prototype.charCodeAt.call(str, i3);
  return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode5) {
  if (key.length > 0 && keyEncoded)
    key = decodeStr(key, decode5);
  if (value.length > 0 && valEncoded)
    value = decodeStr(value, decode5);
  if (obj[key] === void 0) {
    obj[key] = value;
  } else {
    const curValue = obj[key];
    if (curValue.pop)
      curValue[curValue.length] = value;
    else
      obj[key] = [curValue, value];
  }
}
function parse(qs, sep, eq2, options) {
  const obj = { __proto__: null };
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  const sepCodes = sep ? charCodes(String(sep)) : defSepCodes;
  const eqCodes = eq2 ? charCodes(String(eq2)) : defEqCodes;
  const sepLen = sepCodes.length;
  const eqLen = eqCodes.length;
  let pairs = 1e3;
  if (options && typeof options.maxKeys === "number") {
    pairs = options.maxKeys > 0 ? options.maxKeys : -1;
  }
  let decode5 = qsUnescape;
  if (options && typeof options.decodeURIComponent === "function") {
    decode5 = options.decodeURIComponent;
  }
  const customDecode = decode5 !== qsUnescape;
  let lastPos = 0;
  let sepIdx = 0;
  let eqIdx = 0;
  let key = "";
  let value = "";
  let keyEncoded = customDecode;
  let valEncoded = customDecode;
  const plusChar = customDecode ? "%20" : " ";
  let encodeCheck = 0;
  for (let i3 = 0; i3 < qs.length; ++i3) {
    const code = String.prototype.charCodeAt.call(qs, i3);
    if (code === sepCodes[sepIdx]) {
      if (++sepIdx === sepLen) {
        const end = i3 - sepIdx + 1;
        if (eqIdx < eqLen) {
          if (lastPos < end) {
            key += String.prototype.slice.call(qs, lastPos, end);
          } else if (key.length === 0) {
            if (--pairs === 0)
              return obj;
            lastPos = i3 + 1;
            sepIdx = eqIdx = 0;
            continue;
          }
        } else if (lastPos < end) {
          value += String.prototype.slice.call(qs, lastPos, end);
        }
        addKeyVal(obj, key, value, keyEncoded, valEncoded, decode5);
        if (--pairs === 0)
          return obj;
        keyEncoded = valEncoded = customDecode;
        key = value = "";
        encodeCheck = 0;
        lastPos = i3 + 1;
        sepIdx = eqIdx = 0;
      }
    } else {
      sepIdx = 0;
      if (eqIdx < eqLen) {
        if (code === eqCodes[eqIdx]) {
          if (++eqIdx === eqLen) {
            const end = i3 - eqIdx + 1;
            if (lastPos < end)
              key += String.prototype.slice.call(qs, lastPos, end);
            encodeCheck = 0;
            lastPos = i3 + 1;
          }
          continue;
        } else {
          eqIdx = 0;
          if (!keyEncoded) {
            if (code === 37) {
              encodeCheck = 1;
              continue;
            } else if (encodeCheck > 0) {
              if (isHexTable[code] === 1) {
                if (++encodeCheck === 3)
                  keyEncoded = true;
                continue;
              } else {
                encodeCheck = 0;
              }
            }
          }
        }
        if (code === 43) {
          if (lastPos < i3)
            key += String.prototype.slice.call(qs, lastPos, i3);
          key += plusChar;
          lastPos = i3 + 1;
          continue;
        }
      }
      if (code === 43) {
        if (lastPos < i3)
          value += String.prototype.slice.call(qs, lastPos, i3);
        value += plusChar;
        lastPos = i3 + 1;
      } else if (!valEncoded) {
        if (code === 37) {
          encodeCheck = 1;
        } else if (encodeCheck > 0) {
          if (isHexTable[code] === 1) {
            if (++encodeCheck === 3)
              valEncoded = true;
          } else {
            encodeCheck = 0;
          }
        }
      }
    }
  }
  if (lastPos < qs.length) {
    if (eqIdx < eqLen)
      key += String.prototype.slice.call(qs, lastPos);
    else if (sepIdx < sepLen)
      value += String.prototype.slice.call(qs, lastPos);
  } else if (eqIdx === 0 && key.length === 0) {
    return obj;
  }
  addKeyVal(obj, key, value, keyEncoded, valEncoded, decode5);
  return obj;
}
function decodeStr(s3, decoder3) {
  try {
    return decoder3(s3);
  } catch {
    return qsUnescape(s3, true);
  }
}
var unhexTable, noEscape, defSepCodes, defEqCodes, querystring_default;
var init_querystring2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/querystring/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_querystring();
    unhexTable = new Int8Array([
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 0 - 15
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 16 - 31
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 32 - 47
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 48 - 63
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 64 - 79
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 80 - 95
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 96 - 111
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 112 - 127
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      // 128 ...
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
      // ... 255
    ]);
    __name(unescapeBuffer, "unescapeBuffer");
    __name(qsUnescape, "qsUnescape");
    noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 112 - 127
    ]);
    __name(qsEscape, "qsEscape");
    __name(stringifyPrimitive, "stringifyPrimitive");
    __name(encodeStringified, "encodeStringified");
    __name(encodeStringifiedCustom, "encodeStringifiedCustom");
    __name(stringify, "stringify");
    __name(charCodes, "charCodes");
    defSepCodes = [38];
    defEqCodes = [61];
    __name(addKeyVal, "addKeyVal");
    __name(parse, "parse");
    __name(decodeStr, "decodeStr");
    querystring_default = {
      unescapeBuffer,
      unescape: qsUnescape,
      escape: qsEscape,
      stringify,
      encode: stringify,
      parse,
      decode: parse
    };
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/punycode/internal/punycode.mjs
function error3(type2) {
  throw new RangeError(errors[type2]);
}
function map(array, callback2) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback2(array[length]);
  }
  return result;
}
function mapDomain(domain2, callback2) {
  const parts = domain2.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain2 = parts[1];
  }
  domain2 = domain2.replace(regexSeparators, ".");
  const labels = domain2.split(".");
  const encoded = map(labels, callback2).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII;
var init_punycode = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/punycode/internal/punycode.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\u007F]/;
    regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    __name(error3, "error");
    __name(map, "map");
    __name(mapDomain, "mapDomain");
    __name(ucs2decode, "ucs2decode");
    basicToDigit = /* @__PURE__ */ __name(function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    }, "basicToDigit");
    digitToBasic = /* @__PURE__ */ __name(function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }, "digitToBasic");
    adapt = /* @__PURE__ */ __name(function(delta, numPoints, firstTime) {
      let k3 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k3 += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
    }, "adapt");
    decode = /* @__PURE__ */ __name(function(input) {
      const output = [];
      const inputLength = input.length;
      let i3 = 0;
      let n3 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j3 = 0; j3 < basic; ++j3) {
        if (input.charCodeAt(j3) >= 128) {
          error3("not-basic");
        }
        output.push(input.charCodeAt(j3));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i3;
        for (let w3 = 1, k3 = base; ; k3 += base) {
          if (index >= inputLength) {
            error3("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error3("invalid-input");
          }
          if (digit > floor((maxInt - i3) / w3)) {
            error3("overflow");
          }
          i3 += digit * w3;
          const t2 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base - t2;
          if (w3 > floor(maxInt / baseMinusT)) {
            error3("overflow");
          }
          w3 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i3 - oldi, out, oldi === 0);
        if (floor(i3 / out) > maxInt - n3) {
          error3("overflow");
        }
        n3 += floor(i3 / out);
        i3 %= out;
        output.splice(i3++, 0, n3);
      }
      return String.fromCodePoint(...output);
    }, "decode");
    encode = /* @__PURE__ */ __name(function(_input) {
      const output = [];
      const input = ucs2decode(_input);
      const inputLength = input.length;
      let n3 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m5 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n3 && currentValue < m5) {
            m5 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m5 - n3 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error3("overflow");
        }
        delta += (m5 - n3) * handledCPCountPlusOne;
        n3 = m5;
        for (const currentValue of input) {
          if (currentValue < n3 && ++delta > maxInt) {
            error3("overflow");
          }
          if (currentValue === n3) {
            let q = delta;
            for (let k3 = base; ; k3 += base) {
              const t2 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
              if (q < t2) {
                break;
              }
              const qMinusT = q - t2;
              const baseMinusT = base - t2;
              output.push(
                stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(
              delta,
              handledCPCountPlusOne,
              handledCPCount === basicLength
            );
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n3;
      }
      return output.join("");
    }, "encode");
    toUnicode = /* @__PURE__ */ __name(function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    }, "toUnicode");
    toASCII = /* @__PURE__ */ __name(function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    }, "toASCII");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/punycode/index.mjs
var init_punycode2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/punycode/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_punycode();
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/util.mjs
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
var init_util = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/util.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    __name(spliceOne, "spliceOne");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/errors.mjs
function fmt(val) {
  if (Array.isArray(val)) {
    return val.map((v4) => fmt(v4)).join(" or ");
  }
  if (!val) {
    return "" + val;
  }
  return val.toString();
}
var ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_INVALID_URL, ERR_INVALID_URL_SCHEME, ERR_INVALID_FILE_URL_PATH, ERR_INVALID_FILE_URL_HOST;
var init_errors = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/errors.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    __name(fmt, "fmt");
    ERR_INVALID_ARG_VALUE = class extends TypeError {
      code = "ERR_INVALID_ARG_VALUE";
      constructor(name, value, reason) {
        super(
          `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${value}`
        );
      }
    };
    __name(ERR_INVALID_ARG_VALUE, "ERR_INVALID_ARG_VALUE");
    ERR_INVALID_ARG_TYPE = class extends TypeError {
      code = "ERR_INVALID_ARG_TYPE";
      constructor(name, expected, actual) {
        super(
          `The "${name}" argument must be of type ${fmt(expected)}. Received ${fmt(actual)}`
        );
      }
    };
    __name(ERR_INVALID_ARG_TYPE, "ERR_INVALID_ARG_TYPE");
    ERR_INVALID_URL = class extends TypeError {
      code = "ERR_INVALID_URL";
      input;
      base;
      constructor(input, base2) {
        super("Invalid URL");
        this.input = input;
        if (base2 != null) {
          this.base = base2;
        }
      }
    };
    __name(ERR_INVALID_URL, "ERR_INVALID_URL");
    ERR_INVALID_URL_SCHEME = class extends TypeError {
      code = "ERR_INVALID_URL_SCHEME";
      constructor(expected) {
        super(`The URL must be of scheme ${expected}`);
      }
    };
    __name(ERR_INVALID_URL_SCHEME, "ERR_INVALID_URL_SCHEME");
    ERR_INVALID_FILE_URL_PATH = class extends TypeError {
      code = "ERR_INVALID_FILE_URL_PATH";
      constructor(path2) {
        super(`Invalid ile URL path: ${path2}`);
      }
    };
    __name(ERR_INVALID_FILE_URL_PATH, "ERR_INVALID_FILE_URL_PATH");
    ERR_INVALID_FILE_URL_HOST = class extends TypeError {
      code = "ERR_INVALID_FILE_URL_HOST";
      constructor(host) {
        super(`File URL host must be "localhost" or empty on ${host}`);
      }
    };
    __name(ERR_INVALID_FILE_URL_HOST, "ERR_INVALID_FILE_URL_HOST");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/constants.mjs
var CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT;
var init_constants4 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/constants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    CHAR_LOWERCASE_A = 97;
    CHAR_LOWERCASE_Z = 122;
    CHAR_FORWARD_SLASH = 47;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_VERTICAL_LINE = 124;
    CHAR_COLON = 58;
    CHAR_QUESTION_MARK = 63;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_TAB = 9;
    CHAR_HASH = 35;
    CHAR_SPACE = 32;
    CHAR_NO_BREAK_SPACE = 160;
    CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_LEFT_ANGLE_BRACKET = 60;
    CHAR_RIGHT_ANGLE_BRACKET = 62;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_PERCENT = 37;
    CHAR_SEMICOLON = 59;
    CHAR_CIRCUMFLEX_ACCENT = 94;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_AT = 64;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/url.mjs
import path from "node:path";
function pathToFileURL(filepath, options) {
  const windows = options?.windows;
  if (windows && String.prototype.startsWith.call(filepath, "\\\\")) {
    const outURL = new URL("file://");
    const isExtendedUNC = String.prototype.startsWith.call(
      filepath,
      "\\\\?\\UNC\\"
    );
    const prefixLength = isExtendedUNC ? 8 : 2;
    const hostnameEndIndex = String.prototype.indexOf.call(
      filepath,
      "\\",
      prefixLength
    );
    if (hostnameEndIndex === -1) {
      throw new ERR_INVALID_ARG_VALUE(
        "path",
        filepath,
        "Missing UNC resource path"
      );
    }
    const hostname2 = String.prototype.slice.call(
      filepath,
      prefixLength,
      hostnameEndIndex
    );
    outURL.hostname = toASCII(hostname2);
    outURL.pathname = encodePathChars(
      filepath.slice(hostnameEndIndex).replace(backslashRegEx, "/"),
      { windows }
    );
    return outURL;
  }
  let resolved = windows ? path.win32.resolve(filepath) : path.posix.resolve(filepath);
  const filePathLast = String.prototype.charCodeAt.call(
    filepath,
    filepath.length - 1
  );
  if ((filePathLast === CHAR_FORWARD_SLASH || windows && filePathLast === CHAR_BACKWARD_SLASH) && resolved.at(-1) !== path.sep)
    resolved += "/";
  resolved = encodePathChars(resolved, { windows });
  if (String.prototype.indexOf.call(resolved, "?") !== -1)
    resolved = resolved.replace(questionRegex, "%3F");
  if (String.prototype.indexOf.call(resolved, "#") !== -1)
    resolved = resolved.replace(hashRegex, "%23");
  return new URL(`file://${resolved}`);
}
function fileURLToPath(path2, options) {
  const windows = options?.windows;
  if (typeof path2 === "string")
    path2 = new URL(path2);
  else if (!isURL(path2))
    throw new ERR_INVALID_ARG_TYPE("path", ["string", "URL"], path2);
  if (path2.protocol !== "file:")
    throw new ERR_INVALID_URL_SCHEME("file");
  return windows ? getPathFromURLWin32(path2) : getPathFromURLPosix(path2);
}
function urlToHttpOptions(url) {
  const { hostname: hostname2, pathname, port: port2, username, password, search } = url;
  return {
    __proto__: null,
    ...url,
    // In case the url object was extended by the user.
    protocol: url.protocol,
    hostname: hostname2 && String.prototype.startsWith.call(hostname2, "[") ? String.prototype.slice.call(hostname2, 1, -1) : hostname2,
    hash: url.hash,
    search,
    pathname,
    path: `${pathname || ""}${search || ""}`,
    href: url.href,
    port: port2 === "" ? void 0 : Number(port2),
    auth: username || password ? `${decodeURIComponent(username)}:${decodeURIComponent(password)}` : void 0
  };
}
function encodePathChars(filepath, options) {
  const windows = options?.windows;
  if (String.prototype.indexOf.call(filepath, "%") !== -1)
    filepath = filepath.replace(percentRegEx, "%25");
  if (!windows && String.prototype.indexOf.call(filepath, "\\") !== -1)
    filepath = filepath.replace(backslashRegEx, "%5C");
  if (String.prototype.indexOf.call(filepath, "\n") !== -1)
    filepath = filepath.replace(newlineRegEx, "%0A");
  if (String.prototype.indexOf.call(filepath, "\r") !== -1)
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  if (String.prototype.indexOf.call(filepath, "	") !== -1)
    filepath = filepath.replace(tabRegEx, "%09");
  return filepath;
}
function getPathFromURLWin32(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n3 = 0; n3 < pathname.length; n3++) {
    if (pathname[n3] === "%") {
      const third = pathname.codePointAt(n3 + 2) | 32;
      if (pathname[n3 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n3 + 1] === "5" && third === 99) {
        throw new ERR_INVALID_FILE_URL_PATH(
          String.raw`must not include encoded \ or / characters`
        );
      }
    }
  }
  pathname = pathname.replace(FORWARD_SLASH, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${toUnicode(hostname2)}${pathname}`;
  }
  const letter = String.prototype.codePointAt.call(pathname, 1) | 32;
  const sep = String.prototype.charAt.call(pathname, 2);
  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
  sep !== ":") {
    throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
  }
  return String.prototype.slice.call(pathname, 1);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new ERR_INVALID_FILE_URL_HOST("??");
  }
  const pathname = url.pathname;
  for (let n3 = 0; n3 < pathname.length; n3++) {
    if (pathname[n3] === "%") {
      const third = String.prototype.codePointAt.call(pathname, n3 + 2) | 32;
      if (pathname[n3 + 1] === "2" && third === 102) {
        throw new ERR_INVALID_FILE_URL_PATH(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function isURL(self2) {
  return Boolean(
    self2?.href && self2.protocol && self2.auth === void 0 && self2.path === void 0
  );
}
var unsafeProtocol, hostlessProtocol, slashedProtocol, FORWARD_SLASH, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, questionRegex, hashRegex;
var init_url = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/internal/url.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_punycode2();
    init_constants4();
    init_errors();
    unsafeProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
    hostlessProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
    slashedProtocol = /* @__PURE__ */ new Set([
      "http",
      "http:",
      "https",
      "https:",
      "ftp",
      "ftp:",
      "gopher",
      "gopher:",
      "file",
      "file:",
      "ws",
      "ws:",
      "wss",
      "wss:"
    ]);
    FORWARD_SLASH = /\//g;
    __name(pathToFileURL, "pathToFileURL");
    __name(fileURLToPath, "fileURLToPath");
    __name(urlToHttpOptions, "urlToHttpOptions");
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    questionRegex = /\?/g;
    hashRegex = /#/g;
    __name(encodePathChars, "encodePathChars");
    __name(getPathFromURLWin32, "getPathFromURLWin32");
    __name(getPathFromURLPosix, "getPathFromURLPosix");
    __name(isURL, "isURL");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/index.mjs
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (!urlParseWarned) {
    urlParseWarned = true;
    console.warn(
      "[DeprecationWarning] [unenv] [node:url] DEP0169: `url.parse()` behavior is not standardized and prone to errors that have security implications. Use the WHATWG URL API instead. CVEs are not issued for `url.parse()` vulnerabilities."
    );
  }
  if (url instanceof Url)
    return url;
  const urlObject = new Url();
  urlObject.parse(url, parseQueryString, slashesDenoteHost);
  return urlObject;
}
function isIpv6Hostname(hostname2) {
  return String.prototype.charCodeAt.call(hostname2, 0) === CHAR_LEFT_SQUARE_BRACKET && String.prototype.charCodeAt.call(hostname2, hostname2.length - 1) === CHAR_RIGHT_SQUARE_BRACKET;
}
function getHostname(self2, rest, hostname2, url) {
  for (let i3 = 0; i3 < hostname2.length; ++i3) {
    const code = hostname2.charCodeAt(i3);
    const isValid2 = code !== CHAR_FORWARD_SLASH && code !== CHAR_BACKWARD_SLASH && code !== CHAR_HASH && code !== CHAR_QUESTION_MARK && code !== CHAR_COLON;
    if (!isValid2) {
      if (warnInvalidPort && code === CHAR_COLON) {
        console.warn(
          `[DeprecationWarning] [unenv] [node:url] DEP0170: The URL ${url} is invalid. Future versions of Node.js will throw an error.`
        );
        warnInvalidPort = false;
      }
      self2.hostname = hostname2.slice(0, i3);
      return `/${hostname2.slice(i3)}${rest}`;
    }
  }
  return rest;
}
function autoEscapeStr(rest) {
  let escaped = "";
  let lastEscapedPos = 0;
  for (let i3 = 0; i3 < rest.length; ++i3) {
    const escapedChar = escapedCodes[rest.charCodeAt(i3)];
    if (escapedChar) {
      if (i3 > lastEscapedPos)
        escaped += rest.slice(lastEscapedPos, i3);
      escaped += escapedChar;
      lastEscapedPos = i3 + 1;
    }
  }
  if (lastEscapedPos === 0)
    return rest;
  if (lastEscapedPos < rest.length)
    escaped += rest.slice(lastEscapedPos);
  return escaped;
}
function urlFormat(urlObject, options) {
  if (typeof urlObject === "string") {
    urlObject = urlParse(urlObject);
  } else if (typeof urlObject !== "object" || urlObject === null) {
    throw new ERR_INVALID_ARG_TYPE(
      "urlObject",
      ["Object", "string"],
      urlObject
    );
  } else if (urlObject instanceof URL2) {
    let fragment = true;
    let unicode = false;
    let search = true;
    let auth = true;
    if (options) {
      if (options.fragment != null) {
        fragment = Boolean(options.fragment);
      }
      if (options.unicode != null) {
        unicode = Boolean(options.unicode);
      }
      if (options.search != null) {
        search = Boolean(options.search);
      }
      if (options.auth != null) {
        auth = Boolean(options.auth);
      }
    }
    const _url = new URL2(urlObject.href);
    if (!fragment)
      _url.hash = "";
    if (!search)
      _url.search = "";
    if (!auth)
      _url.username = _url.password = "";
    if (unicode) {
      return Url.prototype.format.call(_url);
    }
    return _url.href;
  }
  return Url.prototype.format.call(urlObject);
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function pathToFileURL2(path2, options) {
  return pathToFileURL(path2, options);
}
var Url, protocolPattern, portPattern, hostPattern, simplePathPattern, forbiddenHostChars, forbiddenHostCharsIpv6, noEscapeAuth, escapedCodes, hostnameMaxLen, urlParseWarned, warnInvalidPort, URL2, URLSearchParams2, domainToASCII, domainToUnicode, url_default;
var init_url2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/url/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_querystring2();
    init_punycode2();
    init_querystring();
    init_util();
    init_errors();
    init_url();
    init_constants4();
    Url = class {
      auth = null;
      hash = null;
      host = null;
      hostname = null;
      href = null;
      path = null;
      pathname = null;
      protocol = null;
      search = null;
      slashes = null;
      port = null;
      query = null;
      parse(url, parseQueryString, slashesDenoteHost) {
        if (typeof url !== "string") {
          throw new ERR_INVALID_ARG_TYPE("url", "string", url);
        }
        let hasHash = false;
        let hasAt = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for (let i3 = 0, inWs = false, split = false; i3 < url.length; ++i3) {
          const code = url.charCodeAt(i3);
          const isWs = code < 33 || code === CHAR_NO_BREAK_SPACE || code === CHAR_ZERO_WIDTH_NOBREAK_SPACE;
          if (start === -1) {
            if (isWs)
              continue;
            lastPos = start = i3;
          } else if (inWs) {
            if (!isWs) {
              end = -1;
              inWs = false;
            }
          } else if (isWs) {
            end = i3;
            inWs = true;
          }
          if (!split) {
            switch (code) {
              case CHAR_AT:
                hasAt = true;
                break;
              case CHAR_HASH:
                hasHash = true;
              case CHAR_QUESTION_MARK:
                split = true;
                break;
              case CHAR_BACKWARD_SLASH:
                if (i3 - lastPos > 0)
                  rest += url.slice(lastPos, i3);
                rest += "/";
                lastPos = i3 + 1;
                break;
            }
          } else if (!hasHash && code === CHAR_HASH) {
            hasHash = true;
          }
        }
        if (start !== -1) {
          if (lastPos === start) {
            if (end === -1) {
              if (start === 0)
                rest = url;
              else
                rest = url.slice(start);
            } else {
              rest = url.slice(start, end);
            }
          } else if (end === -1 && lastPos < url.length) {
            rest += url.slice(lastPos);
          } else if (end !== -1 && lastPos < end) {
            rest += url.slice(lastPos, end);
          }
        }
        if (!slashesDenoteHost && !hasHash && !hasAt) {
          const simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = parse(this.search.slice(1));
              } else {
                this.query = this.search.slice(1);
              }
            } else if (parseQueryString) {
              this.search = null;
              this.query = { __proto__: null };
            }
            return this;
          }
        }
        const protoMatch = protocolPattern.exec(rest);
        let proto, lowerProto;
        if (protoMatch) {
          proto = protoMatch[0];
          lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
          slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
          if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
            rest = rest.slice(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
          let hostEnd = -1;
          let atSign = -1;
          let nonHost = -1;
          for (let i3 = 0; i3 < rest.length; ++i3) {
            switch (rest.charCodeAt(i3)) {
              case CHAR_TAB:
              case CHAR_LINE_FEED:
              case CHAR_CARRIAGE_RETURN:
                rest = rest.slice(0, i3) + rest.slice(i3 + 1);
                i3 -= 1;
                break;
              case CHAR_SPACE:
              case CHAR_DOUBLE_QUOTE:
              case CHAR_PERCENT:
              case CHAR_SINGLE_QUOTE:
              case CHAR_SEMICOLON:
              case CHAR_LEFT_ANGLE_BRACKET:
              case CHAR_RIGHT_ANGLE_BRACKET:
              case CHAR_BACKWARD_SLASH:
              case CHAR_CIRCUMFLEX_ACCENT:
              case CHAR_GRAVE_ACCENT:
              case CHAR_LEFT_CURLY_BRACKET:
              case CHAR_VERTICAL_LINE:
              case CHAR_RIGHT_CURLY_BRACKET:
                if (nonHost === -1)
                  nonHost = i3;
                break;
              case CHAR_HASH:
              case CHAR_FORWARD_SLASH:
              case CHAR_QUESTION_MARK:
                if (nonHost === -1)
                  nonHost = i3;
                hostEnd = i3;
                break;
              case CHAR_AT:
                atSign = i3;
                nonHost = -1;
                break;
            }
            if (hostEnd !== -1)
              break;
          }
          start = 0;
          if (atSign !== -1) {
            this.auth = decodeURIComponent(rest.slice(0, atSign));
            start = atSign + 1;
          }
          if (nonHost === -1) {
            this.host = rest.slice(start);
            rest = "";
          } else {
            this.host = rest.slice(start, nonHost);
            rest = rest.slice(nonHost);
          }
          this.parseHost();
          if (typeof this.hostname !== "string")
            this.hostname = "";
          const hostname2 = this.hostname;
          const ipv6Hostname = isIpv6Hostname(hostname2);
          if (!ipv6Hostname) {
            rest = getHostname(this, rest, hostname2, url);
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (this.hostname !== "") {
            if (ipv6Hostname) {
              if (forbiddenHostCharsIpv6.test(this.hostname)) {
                throw new ERR_INVALID_URL(url);
              }
            } else {
              this.hostname = toASCII(this.hostname);
              if (this.hostname === "" || forbiddenHostChars.test(this.hostname)) {
                throw new ERR_INVALID_URL(url);
              }
            }
          }
          const p5 = this.port ? ":" + this.port : "";
          const h2 = this.hostname || "";
          this.host = h2 + p5;
          if (ipv6Hostname) {
            this.hostname = this.hostname.slice(1, -1);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol.has(lowerProto)) {
          rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for (let i3 = 0; i3 < rest.length; ++i3) {
          const code = rest.charCodeAt(i3);
          if (code === CHAR_HASH) {
            this.hash = rest.slice(i3);
            hashIdx = i3;
            break;
          } else if (code === CHAR_QUESTION_MARK && questionIdx === -1) {
            questionIdx = i3;
          }
        }
        if (questionIdx !== -1) {
          if (hashIdx === -1) {
            this.search = rest.slice(questionIdx);
            this.query = rest.slice(questionIdx + 1);
          } else {
            this.search = rest.slice(questionIdx, hashIdx);
            this.query = rest.slice(questionIdx + 1, hashIdx);
          }
          if (parseQueryString) {
            this.query = parse(this.query);
          }
        } else if (parseQueryString) {
          this.search = null;
          this.query = { __proto__: null };
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
          if (rest.length > 0)
            this.pathname = rest;
        } else if (firstIdx > 0) {
          this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          const p5 = this.pathname || "";
          const s3 = this.search || "";
          this.path = p5 + s3;
        }
        this.href = this.format();
        return this;
      }
      format() {
        let auth = this.auth || "";
        if (auth) {
          auth = encodeStr(auth, noEscapeAuth, hexTable);
          auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash2 = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query !== null && typeof this.query === "object") {
          query = stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
          protocol += ":";
        let newPathname = "";
        let lastPos = 0;
        for (let i3 = 0; i3 < pathname.length; ++i3) {
          switch (pathname.charCodeAt(i3)) {
            case CHAR_HASH:
              if (i3 - lastPos > 0)
                newPathname += pathname.slice(lastPos, i3);
              newPathname += "%23";
              lastPos = i3 + 1;
              break;
            case CHAR_QUESTION_MARK:
              if (i3 - lastPos > 0)
                newPathname += pathname.slice(lastPos, i3);
              newPathname += "%3F";
              lastPos = i3 + 1;
              break;
          }
        }
        if (lastPos > 0) {
          if (lastPos === pathname.length) {
            pathname = newPathname;
          } else {
            pathname = newPathname + pathname.slice(lastPos);
          }
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
          if (this.slashes || host) {
            if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH)
              pathname = "/" + pathname;
            host = "//" + host;
          } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
            host = "//";
          }
        }
        search = search.replace(/#/g, "%23");
        if (hash2 && hash2.charCodeAt(0) !== CHAR_HASH)
          hash2 = "#" + hash2;
        if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK)
          search = "?" + search;
        return protocol + host + pathname + search + hash2;
      }
      resolve(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      }
      resolveObject(relative) {
        if (typeof relative === "string") {
          const rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        const result = new Url();
        Object.assign(result, this);
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          const relativeWithoutProtocol = Object.keys(relative).reduce(
            (acc, key) => {
              if (key !== "protocol") {
                acc[key] = relative[key];
              }
              return acc;
            },
            {}
          );
          Object.assign(result, relativeWithoutProtocol);
          if (slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol.has(relative.protocol)) {
            Object.assign(result, relative);
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol.has(relative.protocol)) {
            const relPath2 = (relative.pathname || "").split("/");
            while (relPath2.length > 0 && !(relative.host = relPath2.shift()))
              ;
            if (!relative.host)
              relative.host = "";
            if (!relative.hostname)
              relative.hostname = "";
            if (relPath2[0] !== "")
              relPath2.unshift("");
            if (relPath2.length < 2)
              relPath2.unshift("");
            result.pathname = relPath2.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            const p5 = result.pathname || "";
            const s3 = result.search || "";
            result.path = p5 + s3;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative.pathname && relative.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "")
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            result.auth = null;
            if (relative.host) {
              if (relPath[0] === "")
                relPath[0] = relative.host;
              else
                relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          if (relative.host || relative.host === "") {
            if (result.host !== relative.host)
              result.auth = null;
            result.host = relative.host;
            result.port = relative.port;
          }
          if (relative.hostname || relative.hostname === "") {
            if (result.hostname !== relative.hostname)
              result.auth = null;
            result.hostname = relative.hostname;
          }
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length > 0) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (relative.search !== null && relative.search !== void 0) {
          if (noLeadingSlashes) {
            result.hostname = result.host = srcPath.shift();
            const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (result.pathname !== null || result.search !== null) {
            result.path = // eslint-disable-next-line unicorn/prefer-logical-operator-over-ternary
            (result.pathname ? result.pathname : "") + // eslint-disable-next-line unicorn/prefer-logical-operator-over-ternary
            (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (srcPath.length === 0) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        let last = srcPath.at(-1);
        const hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for (let i3 = srcPath.length - 1; i3 >= 0; i3--) {
          last = srcPath[i3];
          if (last === ".") {
            spliceOne(srcPath, i3);
          } else if (last === "..") {
            spliceOne(srcPath, i3);
            up++;
          } else if (up) {
            spliceOne(srcPath, i3);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          while (up--) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").slice(-1) !== "/") {
          srcPath.push("");
        }
        const isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length > 0 ? srcPath.shift() : "";
          const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (srcPath.length === 0) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
          result.path = // eslint-disable-next-line unicorn/prefer-logical-operator-over-ternary
          (result.pathname ? result.pathname : "") + // eslint-disable-next-line unicorn/prefer-logical-operator-over-ternary
          (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      parseHost() {
        let host = this.host;
        const portMatch = portPattern.exec(host);
        if (portMatch) {
          const port2 = portMatch[0];
          if (port2 !== ":") {
            this.port = port2.slice(1);
          }
          host = host.slice(0, host.length - port2.length);
        }
        if (host)
          this.hostname = host;
      }
    };
    __name(Url, "Url");
    protocolPattern = /^[\d+.a-z-]+:/i;
    portPattern = /:\d*$/;
    hostPattern = /^\/\/[^/@]+@[^/@]+/;
    simplePathPattern = /^(\/\/?(?!\/)[^\s?]*)(\?\S*)?$/;
    forbiddenHostChars = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    forbiddenHostCharsIpv6 = /[\0\t\n\r #%/<>?@\\^|]/;
    noEscapeAuth = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0x00 - 0x0F
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0x10 - 0x1F
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 0x20 - 0x2F
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      // 0x30 - 0x3F
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 0x40 - 0x4F
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 0x50 - 0x5F
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 0x60 - 0x6F
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 0x70 - 0x7F
    ]);
    escapedCodes = [
      /* 0 - 9 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%09",
      /* 10 - 19 */
      "%0A",
      "",
      "",
      "%0D",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 20 - 29 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 30 - 39 */
      "",
      "",
      "%20",
      "",
      "%22",
      "",
      "",
      "",
      "",
      "%27",
      /* 40 - 49 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 50 - 59 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 60 - 69 */
      "%3C",
      "",
      "%3E",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 70 - 79 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 80 - 89 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 90 - 99 */
      "",
      "",
      "%5C",
      "",
      "%5E",
      "",
      "%60",
      "",
      "",
      "",
      /* 100 - 109 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 110 - 119 */
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      /* 120 - 125 */
      "",
      "",
      "",
      "%7B",
      "%7C",
      "%7D"
    ];
    hostnameMaxLen = 255;
    urlParseWarned = false;
    __name(urlParse, "urlParse");
    __name(isIpv6Hostname, "isIpv6Hostname");
    warnInvalidPort = true;
    __name(getHostname, "getHostname");
    __name(autoEscapeStr, "autoEscapeStr");
    __name(urlFormat, "urlFormat");
    __name(urlResolve, "urlResolve");
    __name(urlResolveObject, "urlResolveObject");
    __name(pathToFileURL2, "pathToFileURL");
    URL2 = globalThis.URL;
    URLSearchParams2 = globalThis.URLSearchParams;
    domainToASCII = toASCII;
    domainToUnicode = toUnicode;
    url_default = {
      // Original API
      Url,
      parse: urlParse,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      // WHATWG API
      URL: URL2,
      URLSearchParams: URLSearchParams2,
      domainToASCII,
      domainToUnicode,
      // Utilities
      pathToFileURL: pathToFileURL2,
      fileURLToPath,
      urlToHttpOptions
    };
  }
});

// node-built-in-modules:url
var require_url = __commonJS({
  "node-built-in-modules:url"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_url2();
    module.exports = url_default;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    module.exports = getRawTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
    module.exports = objectToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    module.exports = baseGetTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function isObject3(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    module.exports = isObject3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag2 = baseGetTag(value);
      return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
    }
    __name(isFunction, "isFunction");
    module.exports = isFunction;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    module.exports = isMasked;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    module.exports = toSource;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject3 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    module.exports = baseIsNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    module.exports = getValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    module.exports = getNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    __name(baseAssignValue, "baseAssignValue");
    module.exports = baseAssignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq2, "eq");
    module.exports = eq2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseAssignValue = require_baseAssignValue();
    var eq2 = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    __name(assignValue, "assignValue");
    module.exports = assignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    __name(copyObject, "copyObject");
    module.exports = copyObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    module.exports = identity;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    module.exports = apply;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    __name(overRest, "overRest");
    module.exports = overRest;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function constant(value) {
      return function() {
        return value;
      };
    }
    __name(constant, "constant");
    module.exports = constant;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count4 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count4 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count4 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    __name(shortOut, "shortOut");
    module.exports = shortOut;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    __name(baseRest, "baseRest");
    module.exports = baseRest;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    module.exports = isLength;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    __name(isArrayLike, "isArrayLike");
    module.exports = isArrayLike;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    module.exports = isIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var eq2 = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject3 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject3(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq2(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    module.exports = isIterateeCall;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    __name(createAssigner, "createAssigner");
    module.exports = createAssigner;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    module.exports = baseTimes;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    module.exports = isObjectLike2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike2(value) && baseGetTag(value) == argsTag;
    }
    __name(baseIsArguments, "baseIsArguments");
    module.exports = baseIsArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike2 = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    module.exports = stubFalse;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike2 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    module.exports = baseIsTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    module.exports = baseUnary;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    module.exports = arrayLikeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    module.exports = isPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    __name(nativeKeysIn, "nativeKeysIn");
    module.exports = nativeKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isObject3 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject3(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeysIn, "baseKeysIn");
    module.exports = baseKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    __name(keysIn, "keysIn");
    module.exports = keysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assignIn.js
var require_assignIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assignIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    module.exports = assignIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/extend.js
var require_extend = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/extend.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = require_assignIn();
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike2 = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
    }
    __name(isString, "isString");
    module.exports = isString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function isUndefined(value) {
      return value === void 0;
    }
    __name(isUndefined, "isUndefined");
    module.exports = isUndefined;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    module.exports = overArg;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    module.exports = baseKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    module.exports = getTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag2 = getTag(value);
      if (tag2 == mapTag || tag2 == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    __name(isEmpty, "isEmpty");
    module.exports = isEmpty;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/entries.js
var require_entries = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/entries.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = Object.entries ? Object.entries : function(obj) {
      let ownProps = Object.keys(obj), i3 = ownProps.length, resArray = new Array(i3);
      while (i3--) {
        resArray[i3] = [ownProps[i3], obj[ownProps[i3]]];
      }
      return resArray;
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/config.js
var require_config = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/config.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var url = require_url();
    var extend = require_extend();
    var isObject3 = require_isObject();
    var isString = require_isString();
    var isUndefined = require_isUndefined();
    var isEmpty = require_isEmpty();
    var entries = require_entries();
    var cloudinary_config = void 0;
    function putNestedValue(params, key, value) {
      let chain = key.split(/[\[\]]+/).filter((i3) => i3.length);
      let outer = params;
      let lastKey = chain.pop();
      for (let j3 = 0; j3 < chain.length; j3++) {
        let innerKey = chain[j3];
        let inner = outer[innerKey];
        if (inner == null) {
          inner = {};
          outer[innerKey] = inner;
        }
        outer = inner;
      }
      outer[lastKey] = value;
      return params;
    }
    __name(putNestedValue, "putNestedValue");
    function parseCloudinaryConfigFromEnvURL(ENV_STR) {
      let conf = {};
      let uri = url.parse(ENV_STR, true);
      if (uri.protocol === "cloudinary:") {
        conf = Object.assign({}, conf, {
          cloud_name: uri.host,
          api_key: uri.auth && uri.auth.split(":")[0],
          api_secret: uri.auth && uri.auth.split(":")[1],
          private_cdn: uri.pathname != null,
          secure_distribution: uri.pathname && uri.pathname.substring(1)
        });
      } else if (uri.protocol === "account:") {
        conf = Object.assign({}, conf, {
          account_id: uri.host,
          provisioning_api_key: uri.auth && uri.auth.split(":")[0],
          provisioning_api_secret: uri.auth && uri.auth.split(":")[1]
        });
      }
      return conf;
    }
    __name(parseCloudinaryConfigFromEnvURL, "parseCloudinaryConfigFromEnvURL");
    function extendCloudinaryConfigFromQuery(ENV_URL, confToExtend = {}) {
      let uri = url.parse(ENV_URL, true);
      if (uri.query != null) {
        entries(uri.query).forEach(([key, value]) => putNestedValue(confToExtend, key, value));
      }
    }
    __name(extendCloudinaryConfigFromQuery, "extendCloudinaryConfigFromQuery");
    function extendCloudinaryConfig(parsedConfig, confToExtend = {}) {
      entries(parsedConfig).forEach(([key, value]) => {
        if (value !== void 0) {
          confToExtend[key] = value;
        }
      });
      return confToExtend;
    }
    __name(extendCloudinaryConfig, "extendCloudinaryConfig");
    module.exports = function(new_config, new_value) {
      if (cloudinary_config == null || new_config === true) {
        if (cloudinary_config == null) {
          cloudinary_config = {};
        } else {
          Object.keys(cloudinary_config).forEach((key) => delete cloudinary_config[key]);
        }
        let CLOUDINARY_ENV_URL = process.env.CLOUDINARY_URL;
        let CLOUDINARY_ENV_ACCOUNT_URL = process.env.CLOUDINARY_ACCOUNT_URL;
        let CLOUDINARY_API_PROXY = process.env.CLOUDINARY_API_PROXY;
        if (CLOUDINARY_ENV_URL && !CLOUDINARY_ENV_URL.toLowerCase().startsWith("cloudinary://")) {
          throw new Error("Invalid CLOUDINARY_URL protocol. URL should begin with 'cloudinary://'");
        }
        if (CLOUDINARY_ENV_ACCOUNT_URL && !CLOUDINARY_ENV_ACCOUNT_URL.toLowerCase().startsWith("account://")) {
          throw new Error("Invalid CLOUDINARY_ACCOUNT_URL protocol. URL should begin with 'account://'");
        }
        if (!isEmpty(CLOUDINARY_API_PROXY)) {
          extendCloudinaryConfig({ api_proxy: CLOUDINARY_API_PROXY }, cloudinary_config);
        }
        [CLOUDINARY_ENV_URL, CLOUDINARY_ENV_ACCOUNT_URL].forEach((ENV_URL) => {
          if (ENV_URL) {
            let parsedConfig = parseCloudinaryConfigFromEnvURL(ENV_URL);
            extendCloudinaryConfig(parsedConfig, cloudinary_config);
            extendCloudinaryConfigFromQuery(ENV_URL, cloudinary_config);
          }
        });
      }
      if (!isUndefined(new_value)) {
        cloudinary_config[new_config] = new_value;
      } else if (isString(new_config)) {
        return cloudinary_config[new_config];
      } else if (isObject3(new_config)) {
        extend(cloudinary_config, new_config);
      }
      return cloudinary_config;
    };
  }
});

// node-built-in-modules:querystring
var require_querystring = __commonJS({
  "node-built-in-modules:querystring"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_querystring2();
    module.exports = querystring_default;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    __name(compact, "compact");
    module.exports = compact;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    __name(head, "head");
    module.exports = head;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js
var require_first = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = require_head();
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike2 = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module.exports = isPlainObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    __name(last, "last");
    module.exports = last;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    module.exports = arrayMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    __name(listCacheClear, "listCacheClear");
    module.exports = listCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var eq2 = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    module.exports = assocIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    module.exports = listCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    module.exports = listCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    module.exports = listCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    module.exports = listCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    __name(stackClear, "stackClear");
    module.exports = stackClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    __name(stackDelete, "stackDelete");
    module.exports = stackDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    module.exports = stackGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    module.exports = stackHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    __name(hashClear, "hashClear");
    module.exports = hashClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(hashDelete, "hashDelete");
    module.exports = hashDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    module.exports = hashGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    __name(hashHas, "hashHas");
    module.exports = hashHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    module.exports = hashSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash3(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash3, "Hash");
    Hash3.prototype.clear = hashClear;
    Hash3.prototype["delete"] = hashDelete;
    Hash3.prototype.get = hashGet;
    Hash3.prototype.has = hashHas;
    Hash3.prototype.set = hashSet;
    module.exports = Hash3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Hash3 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash3(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash3()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    module.exports = mapCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    module.exports = isKeyable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    module.exports = getMapData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(mapCacheDelete, "mapCacheDelete");
    module.exports = mapCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    module.exports = mapCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    module.exports = mapCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    module.exports = mapCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    __name(stackSet, "stackSet");
    module.exports = stackSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    __name(Stack, "Stack");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    module.exports = setCacheAdd;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    module.exports = setCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    module.exports = arraySome;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    __name(cacheHas, "cacheHas");
    module.exports = cacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    module.exports = equalArrays;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    module.exports = mapToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    module.exports = setToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq2 = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
      switch (tag2) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq2(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    module.exports = equalByTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    module.exports = arrayPush;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    module.exports = baseGetAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    module.exports = arrayFilter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    module.exports = stubArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    module.exports = keys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    module.exports = getAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    module.exports = equalObjects;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike2 = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    module.exports = baseIsEqual;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    module.exports = baseIsMatch;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isObject3 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject3(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    module.exports = isStrictComparable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    module.exports = getMatchData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    module.exports = matchesStrictComparable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    module.exports = baseMatches;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    module.exports = isSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    module.exports = isKey;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    __name(memoizeCapped, "memoizeCapped");
    module.exports = memoizeCapped;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    module.exports = baseToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString, "toString");
    module.exports = toString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    __name(castPath, "castPath");
    module.exports = castPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    module.exports = toKey;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    module.exports = baseGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGet = require_baseGet();
    function get3(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    __name(get3, "get");
    module.exports = get3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    module.exports = baseHasIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    module.exports = hasPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    __name(hasIn, "hasIn");
    module.exports = hasIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsEqual = require_baseIsEqual();
    var get3 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get3(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    module.exports = baseMatchesProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    module.exports = baseProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    module.exports = basePropertyDeep;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    __name(property, "property");
    module.exports = property;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    module.exports = baseIteratee;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    module.exports = createBaseFor;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    module.exports = baseForOwn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    module.exports = createBaseEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    __name(baseMap, "baseMap");
    module.exports = baseMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map2(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    __name(map2, "map");
    module.exports = map2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    __name(baseSlice, "baseSlice");
    module.exports = baseSlice;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    module.exports = trimmedEndIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    __name(baseTrim, "baseTrim");
    module.exports = baseTrim;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseTrim = require_baseTrim();
    var isObject3 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = toNumber;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    module.exports = toFinite;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    module.exports = toInteger;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/take.js
var require_take = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/take.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function take(array, n3, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n3 = guard || n3 === void 0 ? 1 : toInteger(n3);
      return baseSlice(array, 0, n3 < 0 ? 0 : n3);
    }
    __name(take, "take");
    module.exports = take;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAt.js
var require_baseAt = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAt.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var get3 = require_get();
    function baseAt(object, paths) {
      var index = -1, length = paths.length, result = Array(length), skip = object == null;
      while (++index < length) {
        result[index] = skip ? void 0 : get3(object, paths[index]);
      }
      return result;
    }
    __name(baseAt, "baseAt");
    module.exports = baseAt;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    module.exports = isFlattenable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    module.exports = baseFlatten;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    __name(flatten, "flatten");
    module.exports = flatten;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_flatRest.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    __name(flatRest, "flatRest");
    module.exports = flatRest;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/at.js
var require_at = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/at.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseAt = require_baseAt();
    var flatRest = require_flatRest();
    var at = flatRest(baseAt);
    module.exports = at;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    module.exports = arrayEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    module.exports = baseAssign;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    __name(baseAssignIn, "baseAssignIn");
    module.exports = baseAssignIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    module.exports = cloneBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    module.exports = copyArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    module.exports = copySymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    __name(copySymbolsIn, "copySymbolsIn");
    module.exports = copySymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    __name(getAllKeysIn, "getAllKeysIn");
    module.exports = getAllKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    module.exports = initCloneArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    module.exports = cloneDataView;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    module.exports = cloneRegExp;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    module.exports = cloneSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    module.exports = cloneTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag2, isDeep) {
      var Ctor = object.constructor;
      switch (tag2) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    module.exports = initCloneByTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isObject3 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      __name(object, "object");
      return function(proto) {
        if (!isObject3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    module.exports = initCloneObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getTag = require_getTag();
    var isObjectLike2 = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike2(value) && getTag(value) == mapTag;
    }
    __name(baseIsMap, "baseIsMap");
    module.exports = baseIsMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var getTag = require_getTag();
    var isObjectLike2 = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike2(value) && getTag(value) == setTag;
    }
    __name(baseIsSet, "baseIsSet");
    module.exports = baseIsSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject3 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject3(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag2]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag2, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    module.exports = baseClone;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    __name(clone, "clone");
    module.exports = clone;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    __name(baseFilter, "baseFilter");
    module.exports = baseFilter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    __name(filter, "filter");
    module.exports = filter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    module.exports = baseFindIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    module.exports = baseIsNaN;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    module.exports = strictIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    module.exports = baseIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    module.exports = baseValues;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    __name(values, "values");
    module.exports = values;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    __name(includes, "includes");
    module.exports = includes;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isNumber.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber(value) {
      return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
    }
    __name(isNumber, "isNumber");
    module.exports = isNumber;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/smart_escape.js
var require_smart_escape = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/smart_escape.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function smart_escape(string, unsafe = /([^a-zA-Z0-9_.\-\/:]+)/g) {
      return string.replace(unsafe, function(match) {
        return match.split("").map(function(c4) {
          return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
        }).join("");
      });
    }
    __name(smart_escape, "smart_escape");
    module.exports = smart_escape;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/parsing/consumeOption.js
var require_consumeOption = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/parsing/consumeOption.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function consumeOption(options, option_name, default_value) {
      let result = options[option_name];
      delete options[option_name];
      return result != null ? result : default_value;
    }
    __name(consumeOption, "consumeOption");
    module.exports = consumeOption;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/parsing/toArray.js
var require_toArray = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/parsing/toArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArray = require_isArray();
    function toArray(arg) {
      switch (true) {
        case arg == null:
          return [];
        case isArray(arg):
          return arg;
        default:
          return [arg];
      }
    }
    __name(toArray, "toArray");
    module.exports = toArray;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64Encode.js
var require_base64Encode = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64Encode.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function base64Encode(input) {
      if (!(input instanceof Buffer)) {
        input = Buffer.from(String(input), "binary");
      }
      return input.toString("base64");
    }
    __name(base64Encode, "base64Encode");
    module.exports.base64Encode = base64Encode;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64EncodeURL.js
var require_base64EncodeURL = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64EncodeURL.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var { base64Encode } = require_base64Encode();
    function base64EncodeURL(sourceUrl) {
      try {
        sourceUrl = decodeURI(sourceUrl);
      } catch (error4) {
      }
      sourceUrl = encodeURI(sourceUrl);
      return base64Encode(sourceUrl).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }
    __name(base64EncodeURL, "base64EncodeURL");
    module.exports.base64EncodeURL = base64EncodeURL;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/encodeDoubleArray.js
var require_encodeDoubleArray = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/encodeDoubleArray.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isArray = require_isArray();
    var toArray = require_toArray();
    function encodeDoubleArray(array) {
      array = toArray(array);
      if (!isArray(array[0])) {
        array = [array];
      }
      return array.map((e2) => toArray(e2).join(",")).join("|");
    }
    __name(encodeDoubleArray, "encodeDoubleArray");
    module.exports = encodeDoubleArray;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/auth_token.js
var require_auth_token = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/auth_token.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var crypto2 = require_crypto();
    var smart_escape = require_smart_escape();
    var unsafe = /([ "#%&'/:;<=>?@[\]^`{|}~]+)/g;
    function digest2(message2, key) {
      return crypto2.createHmac("sha256", Buffer.from(key, "hex")).update(message2).digest("hex");
    }
    __name(digest2, "digest");
    function escapeToLower(url) {
      const safeUrl = smart_escape(url, unsafe);
      return safeUrl.replace(/%../g, function(match) {
        return match.toLowerCase();
      });
    }
    __name(escapeToLower, "escapeToLower");
    module.exports = function(options) {
      const tokenName = options.token_name ? options.token_name : "__cld_token__";
      const tokenSeparator = "~";
      if (options.expiration == null) {
        if (options.duration != null) {
          let start = options.start_time != null ? options.start_time : Math.round(Date.now() / 1e3);
          options.expiration = start + options.duration;
        } else {
          throw new Error("Must provide either expiration or duration");
        }
      }
      let tokenParts = [];
      if (options.ip != null) {
        tokenParts.push(`ip=${options.ip}`);
      }
      if (options.start_time != null) {
        tokenParts.push(`st=${options.start_time}`);
      }
      tokenParts.push(`exp=${options.expiration}`);
      if (options.acl != null) {
        if (Array.isArray(options.acl) === true) {
          options.acl = options.acl.join("!");
        }
        tokenParts.push(`acl=${escapeToLower(options.acl)}`);
      }
      let toSign = [...tokenParts];
      if (options.url != null && options.acl == null) {
        let url = escapeToLower(options.url);
        toSign.push(`url=${url}`);
      }
      let auth = digest2(toSign.join(tokenSeparator), options.key);
      tokenParts.push(`hmac=${auth}`);
      if (!options.url && !options.acl) {
        throw "authToken must contain either an acl or a url property";
      }
      return `${tokenName}=${tokenParts.join(tokenSeparator)}`;
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/utf8_encode.js
var require_utf8_encode = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/utf8_encode.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = /* @__PURE__ */ __name(function utf8_encode(argString) {
      let c1, enc2, n3;
      if (argString == null) {
        return "";
      }
      let string = argString + "";
      let utftext = "";
      let start = 0;
      let end = 0;
      let stringl = string.length;
      n3 = 0;
      while (n3 < stringl) {
        c1 = string.charCodeAt(n3);
        enc2 = null;
        if (c1 < 128) {
          end++;
        } else if (c1 > 127 && c1 < 2048) {
          enc2 = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);
        } else {
          enc2 = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);
        }
        if (enc2 !== null) {
          if (end > start) {
            utftext += string.slice(start, end);
          }
          utftext += enc2;
          start = n3 + 1;
          end = start;
        }
        n3++;
      }
      if (end > start) {
        utftext += string.slice(start, stringl);
      }
      return utftext;
    }, "utf8_encode");
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/crc32.js
var require_crc32 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/crc32.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utf8_encode = require_utf8_encode();
    function crc32(str) {
      let crc, i3, iTop, table3, x3, y3;
      str = utf8_encode(str);
      table3 = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
      crc = 0;
      x3 = 0;
      y3 = 0;
      crc = crc ^ -1;
      i3 = 0;
      iTop = str.length;
      while (i3 < iTop) {
        y3 = (crc ^ str.charCodeAt(i3)) & 255;
        x3 = "0x" + table3.substr(y3 * 9, 8);
        crc = crc >>> 8 ^ x3;
        i3++;
      }
      crc = crc ^ -1;
      if (crc < 0) {
        crc += 4294967296;
      }
      return crc;
    }
    __name(crc32, "crc32");
    module.exports = crc32;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/ensurePresenceOf.js
var require_ensurePresenceOf = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/ensurePresenceOf.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function ensurePresenceOf(parameters) {
      let missing = Object.keys(parameters).filter((key) => parameters[key] === void 0);
      if (missing.length) {
        console.error(missing.join(",") + " cannot be undefined");
      }
    }
    __name(ensurePresenceOf, "ensurePresenceOf");
    module.exports = ensurePresenceOf;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/ensureOption.js
var require_ensureOption = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/ensureOption.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function defaults(defaultOptions) {
      return /* @__PURE__ */ __name(function ensureOption(options, name, defaultValue) {
        let value;
        if (typeof options[name] !== "undefined") {
          value = options[name];
        } else if (typeof defaultOptions[name] !== "undefined") {
          value = defaultOptions[name];
        } else if (typeof defaultValue !== "undefined") {
          value = defaultValue;
        } else {
          throw new Error(`Must supply ${name}`);
        }
        return value;
      }, "ensureOption");
    }
    __name(defaults, "defaults");
    module.exports = defaults({});
    module.exports.defaults = defaults;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/isRemoteUrl.js
var require_isRemoteUrl = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/isRemoteUrl.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var isString = require_isString();
    function isRemoteUrl(url) {
      const SUBSTRING_LENGTH = 120;
      const urlSubstring = isString(url) && url.substring(0, SUBSTRING_LENGTH);
      return isString(url) && /^ftp:|^https?:|^gs:|^s3:|^data:([\w-.]+\/[\w-.]+(\+[\w-.]+)?)?(;[\w-.]+=[\w-.]+)*;base64,([a-zA-Z0-9\/+\n=]+)$/.test(urlSubstring);
    }
    __name(isRemoteUrl, "isRemoteUrl");
    module.exports = isRemoteUrl;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/getSDKVersions.js
var require_getSDKVersions = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/getSDKVersions.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var fs = require_fs();
    var path2 = require_path();
    var sdkCode = "M";
    function readSdkSemver() {
      const pkgJsonPath = path2.join(__dirname, "../../../package.json");
      try {
        const pkgJSONFile = fs.readFileSync(pkgJsonPath, "utf-8");
        return JSON.parse(pkgJSONFile).version;
      } catch (e2) {
        if (e2.code === "ENOENT") {
          return "0.0.0";
        }
        return "n/a";
      }
    }
    __name(readSdkSemver, "readSdkSemver");
    function getSDKVersions(useSDKVersion = "default", useNodeVersion = "default") {
      const sdkSemver = useSDKVersion === "default" ? readSdkSemver() : useSDKVersion;
      const techVersion = useNodeVersion === "default" ? process.versions.node : useNodeVersion;
      const product2 = "A";
      return {
        sdkSemver,
        techVersion,
        sdkCode,
        product: product2
      };
    }
    __name(getSDKVersions, "getSDKVersions");
    module.exports = getSDKVersions;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/removePatchFromSemver.js
var require_removePatchFromSemver = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/removePatchFromSemver.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = (semVerStr) => {
      let parts = semVerStr.split(".");
      return `${parts[0]}.${parts[1]}`;
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/stringPad.js
var require_stringPad = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/stringPad.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function repeatStringNumTimes(string, times) {
      let repeatedString = "";
      while (times > 0) {
        repeatedString += string;
        times--;
      }
      return repeatedString;
    }
    __name(repeatStringNumTimes, "repeatStringNumTimes");
    module.exports = (value, targetLength, padString) => {
      targetLength = targetLength >> 0;
      padString = String(typeof padString !== "undefined" ? padString : " ");
      if (value.length > targetLength) {
        return String(value);
      } else {
        targetLength = targetLength - value.length;
        if (targetLength > padString.length) {
          padString += repeatStringNumTimes(padString, targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + String(value);
      }
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/reverseVersion.js
var require_reverseVersion = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/reverseVersion.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var stringPad = require_stringPad();
    module.exports = (semVer) => {
      if (semVer.split(".").length < 2) {
        throw new Error("invalid semVer, must have at least two segments");
      }
      return semVer.split(".").reverse().map((segment) => {
        return stringPad(segment, 2, "0");
      }).join(".");
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64Map.js
var require_base64Map = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/encoding/base64Map.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var stringPad = require_stringPad();
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var num = 0;
    var base64Map = {};
    [...chars].forEach((char) => {
      let key = num.toString(2);
      key = stringPad(key, 6, "0");
      base64Map[key] = char;
      num++;
    });
    module.exports = base64Map;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/encodeVersion.js
var require_encodeVersion = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/encodeVersion.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var reverseVersion = require_reverseVersion();
    var stringPad = require_stringPad();
    var base64Map = require_base64Map();
    module.exports = (semVer) => {
      let strResult = "";
      let parts = semVer.split(".").length;
      let paddedStringLength = parts * 6;
      let paddedReversedSemver = reverseVersion(semVer);
      let num = parseInt(paddedReversedSemver.split(".").join(""));
      let paddedBinary = num.toString(2);
      paddedBinary = stringPad(paddedBinary, paddedStringLength, "0");
      if (paddedBinary.length % 6 !== 0) {
        throw "Version must be smaller than 43.21.26)";
      }
      paddedBinary.match(/.{1,6}/g).forEach((bitString) => {
        strResult += base64Map[bitString];
      });
      return strResult;
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/index.js
var require_analytics = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/analytics/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var removePatchFromSemver = require_removePatchFromSemver();
    var encodeVersion = require_encodeVersion();
    function getSDKAnalyticsSignature(analyticsOptions = {}) {
      try {
        const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);
        const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);
        const encodedTechVersion = encodeVersion(twoPartVersion);
        const featureCode = analyticsOptions.feature;
        const SDKCode = analyticsOptions.sdkCode;
        const product2 = analyticsOptions.product;
        const algoVersion = "B";
        return `${algoVersion}${product2}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;
      } catch (e2) {
        return "E";
      }
    }
    __name(getSDKAnalyticsSignature, "getSDKAnalyticsSignature");
    function getAnalyticsOptions(options) {
      let analyticsOptions = {
        sdkSemver: options.sdkSemver,
        techVersion: options.techVersion,
        sdkCode: options.sdkCode,
        product: options.product,
        feature: "0"
      };
      if (options.urlAnalytics) {
        if (options.accessibility) {
          analyticsOptions.feature = "D";
        }
        if (options.loading === "lazy") {
          analyticsOptions.feature = "C";
        }
        if (options.responsive) {
          analyticsOptions.feature = "A";
        }
        if (options.placeholder) {
          analyticsOptions.feature = "B";
        }
        return analyticsOptions;
      } else {
        return {};
      }
    }
    __name(getAnalyticsOptions, "getAnalyticsOptions");
    module.exports = {
      getSDKAnalyticsSignature,
      getAnalyticsOptions
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/package.json
var require_package2 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/package.json"(exports, module) {
    module.exports = {
      author: "Cloudinary <info@cloudinary.com>",
      name: "cloudinary",
      description: "Cloudinary NPM for node.js integration",
      version: "2.5.1",
      homepage: "https://cloudinary.com",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/cloudinary/cloudinary_npm.git"
      },
      main: "cloudinary.js",
      dependencies: {
        lodash: "^4.17.21",
        q: "^1.5.1"
      },
      devDependencies: {
        "@types/mocha": "^7.0.2",
        "@types/node": "^13.5.0",
        "@types/expect.js": "^0.3.29",
        "date-fns": "^2.16.1",
        dotenv: "4.x",
        dtslint: "^0.9.1",
        eslint: "^6.8.0",
        "eslint-config-airbnb-base": "^14.2.1",
        "eslint-plugin-import": "^2.20.2",
        "expect.js": "0.3.x",
        glob: "^7.1.6",
        jsdoc: "3.5.5",
        jsdom: "^9.12.0",
        "jsdom-global": "2.1.1",
        mocha: "^6.2.3",
        "mock-fs": "^4.12.0",
        nyc: "^13.3.0",
        rimraf: "^3.0.0",
        sinon: "^6.1.4",
        typescript: "^3.7.5",
        "webpack-cli": "^3.2.1"
      },
      files: [
        "lib/**/*",
        "cloudinary.js",
        "babel.config.js",
        "package.json",
        "types/index.d.ts"
      ],
      types: "types",
      scripts: {
        test: "tools/scripts/test.sh",
        "test:unit": "tools/scripts/test.es6.unit.sh",
        "test-with-temp-cloud": "tools/scripts/tests-with-temp-cloud.sh",
        dtslint: "tools/scripts/ditslint.sh",
        lint: "tools/scripts/lint.sh",
        coverage: "tools/scripts/test.es6.sh --coverage",
        "test-es6": "tools/scripts/test.es6.sh",
        docs: "tools/scripts/docs.sh"
      },
      engines: {
        node: ">=9"
      }
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/consts.js
var require_consts = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/consts.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = {
      width: "auto",
      crop: "limit"
    };
    var DEFAULT_POSTER_OPTIONS = {
      format: "jpg",
      resource_type: "video"
    };
    var DEFAULT_VIDEO_SOURCE_TYPES = ["webm", "mp4", "ogv"];
    var CONDITIONAL_OPERATORS = {
      "=": "eq",
      "!=": "ne",
      "<": "lt",
      ">": "gt",
      "<=": "lte",
      ">=": "gte",
      "&&": "and",
      "||": "or",
      "*": "mul",
      "/": "div",
      "+": "add",
      "-": "sub",
      "^": "pow"
    };
    var SIMPLE_PARAMS = [
      ["audio_codec", "ac"],
      ["audio_frequency", "af"],
      ["bit_rate", "br"],
      ["color_space", "cs"],
      ["default_image", "d"],
      ["delay", "dl"],
      ["density", "dn"],
      ["duration", "du"],
      ["end_offset", "eo"],
      ["fetch_format", "f"],
      ["gravity", "g"],
      ["page", "pg"],
      ["prefix", "p"],
      ["start_offset", "so"],
      ["streaming_profile", "sp"],
      ["video_codec", "vc"],
      ["video_sampling", "vs"]
    ];
    var PREDEFINED_VARS = {
      "aspect_ratio": "ar",
      "aspectRatio": "ar",
      "current_page": "cp",
      "currentPage": "cp",
      "duration": "du",
      "face_count": "fc",
      "faceCount": "fc",
      "height": "h",
      "initial_aspect_ratio": "iar",
      "initial_height": "ih",
      "initial_width": "iw",
      "initialAspectRatio": "iar",
      "initialHeight": "ih",
      "initialWidth": "iw",
      "initial_duration": "idu",
      "initialDuration": "idu",
      "page_count": "pc",
      "page_x": "px",
      "page_y": "py",
      "pageCount": "pc",
      "pageX": "px",
      "pageY": "py",
      "tags": "tags",
      "width": "w"
    };
    var TRANSFORMATION_PARAMS = [
      "angle",
      "aspect_ratio",
      "audio_codec",
      "audio_frequency",
      "background",
      "bit_rate",
      "border",
      "color",
      "color_space",
      "crop",
      "default_image",
      "delay",
      "density",
      "dpr",
      "duration",
      "effect",
      "end_offset",
      "fetch_format",
      "flags",
      "fps",
      "gravity",
      "height",
      "if",
      "keyframe_interval",
      "offset",
      "opacity",
      "overlay",
      "page",
      "prefix",
      "quality",
      "radius",
      "raw_transformation",
      "responsive_width",
      "size",
      "start_offset",
      "streaming_profile",
      "transformation",
      "underlay",
      "variables",
      "video_codec",
      "video_sampling",
      "width",
      "x",
      "y",
      "zoom"
      // + any key that starts with '$'
    ];
    var LAYER_KEYWORD_PARAMS = {
      font_weight: "normal",
      font_style: "normal",
      text_decoration: "none",
      text_align: null,
      stroke: "none"
    };
    var UPLOAD_PREFIX = "https://api.cloudinary.com";
    var SUPPORTED_SIGNATURE_ALGORITHMS = ["sha1", "sha256"];
    var DEFAULT_SIGNATURE_ALGORITHM = "sha1";
    module.exports = {
      DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
      DEFAULT_POSTER_OPTIONS,
      DEFAULT_VIDEO_SOURCE_TYPES,
      CONDITIONAL_OPERATORS,
      PREDEFINED_VARS,
      LAYER_KEYWORD_PARAMS,
      TRANSFORMATION_PARAMS,
      SIMPLE_PARAMS,
      UPLOAD_PREFIX,
      SUPPORTED_SIGNATURE_ALGORITHMS,
      DEFAULT_SIGNATURE_ALGORITHM
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var crypto2 = require_crypto();
    var querystring = require_querystring();
    var urlParse2 = require_url().parse;
    var compact = require_compact();
    var first = require_first();
    var isFunction = require_isFunction();
    var isPlainObject = require_isPlainObject();
    var last = require_last();
    var map2 = require_map();
    var take = require_take();
    var at = require_at();
    var clone = require_clone();
    var extend = require_extend();
    var filter = require_filter();
    var includes = require_includes();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isNumber = require_isNumber();
    var isObject3 = require_isObject();
    var isString = require_isString();
    var isUndefined = require_isUndefined();
    var smart_escape = require_smart_escape();
    var consumeOption = require_consumeOption();
    var toArray = require_toArray();
    var { base64EncodeURL } = require_base64EncodeURL();
    var encodeDoubleArray = require_encodeDoubleArray();
    var config2 = require_config();
    var generate_token = require_auth_token();
    var crc32 = require_crc32();
    var ensurePresenceOf = require_ensurePresenceOf();
    var ensureOption = require_ensureOption().defaults(config2());
    var entries = require_entries();
    var isRemoteUrl = require_isRemoteUrl();
    var getSDKVersions = require_getSDKVersions();
    var {
      getAnalyticsOptions,
      getSDKAnalyticsSignature
    } = require_analytics();
    exports = module.exports;
    var utils = module.exports;
    try {
      utils.VERSION = require_package2().version;
    } catch (error4) {
      utils.VERSION = "";
    }
    function generate_auth_token(options) {
      let token_options = Object.assign({}, config2().auth_token, options);
      return generate_token(token_options);
    }
    __name(generate_auth_token, "generate_auth_token");
    exports.CF_SHARED_CDN = "d3jpl91pxevbkh.cloudfront.net";
    exports.OLD_AKAMAI_SHARED_CDN = "cloudinary-a.akamaihd.net";
    exports.AKAMAI_SHARED_CDN = "res.cloudinary.com";
    exports.SHARED_CDN = exports.AKAMAI_SHARED_CDN;
    exports.USER_AGENT = `CloudinaryNodeJS/${exports.VERSION} (Node ${process.versions.node})`;
    exports.userPlatform = "";
    function getUserAgent() {
      return isEmpty(utils.userPlatform) ? `${utils.USER_AGENT}` : `${utils.userPlatform} ${utils.USER_AGENT}`;
    }
    __name(getUserAgent, "getUserAgent");
    var {
      DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
      DEFAULT_POSTER_OPTIONS,
      DEFAULT_VIDEO_SOURCE_TYPES,
      CONDITIONAL_OPERATORS,
      PREDEFINED_VARS,
      LAYER_KEYWORD_PARAMS,
      TRANSFORMATION_PARAMS,
      SIMPLE_PARAMS,
      UPLOAD_PREFIX,
      SUPPORTED_SIGNATURE_ALGORITHMS,
      DEFAULT_SIGNATURE_ALGORITHM
    } = require_consts();
    function textStyle(layer) {
      let keywords = [];
      let style = "";
      if (!isEmpty(layer.text_style)) {
        return layer.text_style;
      }
      Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {
        let default_value = LAYER_KEYWORD_PARAMS[attr];
        let attr_value = layer[attr] || default_value;
        if (attr_value !== default_value) {
          keywords.push(attr_value);
        }
      });
      Object.keys(layer).forEach((attr) => {
        if (attr === "letter_spacing" || attr === "line_spacing") {
          keywords.push(`${attr}_${layer[attr]}`);
        }
        if (attr === "font_hinting") {
          keywords.push(`${attr.split("_").pop()}_${layer[attr]}`);
        }
        if (attr === "font_antialiasing") {
          keywords.push(`antialias_${layer[attr]}`);
        }
      });
      if (layer.hasOwnProperty("font_size") || !isEmpty(keywords)) {
        if (!layer.font_size)
          throw new Error("Must supply font_size for text in overlay/underlay");
        if (!layer.font_family)
          throw new Error("Must supply font_family for text in overlay/underlay");
        keywords.unshift(layer.font_size);
        keywords.unshift(layer.font_family);
        style = compact(keywords).join("_");
      }
      return style;
    }
    __name(textStyle, "textStyle");
    function normalize_expression(expression) {
      if (!isString(expression) || expression.length === 0 || expression.match(/^!.+!$/)) {
        return expression;
      }
      const operators = "\\|\\||>=|<=|&&|!=|>|=|<|/|-|\\^|\\+|\\*";
      const operatorsPattern = "((" + operators + ")(?=[ _]))";
      const operatorsReplaceRE = new RegExp(operatorsPattern, "g");
      expression = expression.replace(operatorsReplaceRE, (match) => CONDITIONAL_OPERATORS[match]);
      const predefinedVarsPattern = "(" + Object.keys(PREDEFINED_VARS).map((v4) => `:${v4}|${v4}`).join("|") + ")";
      const userVariablePattern = "(\\$_*[^_ ]+)";
      const variablesReplaceRE = new RegExp(`${userVariablePattern}|${predefinedVarsPattern}`, "g");
      expression = expression.replace(variablesReplaceRE, (match) => PREDEFINED_VARS[match] || match);
      return expression.replace(/[ _]+/g, "_");
    }
    __name(normalize_expression, "normalize_expression");
    function process_custom_function(customFunction) {
      if (!isObject3(customFunction)) {
        return customFunction;
      }
      if (customFunction.function_type === "remote") {
        const encodedSource = base64EncodeURL(customFunction.source);
        return [customFunction.function_type, encodedSource].join(":");
      }
      return [customFunction.function_type, customFunction.source].join(":");
    }
    __name(process_custom_function, "process_custom_function");
    function process_custom_pre_function(customPreFunction) {
      let result = process_custom_function(customPreFunction);
      return utils.isString(result) ? `pre:${result}` : null;
    }
    __name(process_custom_pre_function, "process_custom_pre_function");
    function process_if(ifValue) {
      return ifValue ? "if_" + normalize_expression(ifValue) : ifValue;
    }
    __name(process_if, "process_if");
    function process_layer(layer) {
      if (isString(layer)) {
        let resourceType = null;
        let layerUrl = "";
        let fetchLayerBegin = "fetch:";
        if (layer.startsWith(fetchLayerBegin)) {
          layerUrl = layer.substring(fetchLayerBegin.length);
        } else if (layer.indexOf(":fetch:", 0) !== -1) {
          const parts = layer.split(":", 3);
          resourceType = parts[0];
          layerUrl = parts[2];
        } else {
          return layer;
        }
        layer = {
          url: layerUrl,
          type: "fetch"
        };
        if (resourceType) {
          layer.resource_type = resourceType;
        }
      }
      if (typeof layer !== "object") {
        return layer;
      }
      let {
        resource_type,
        text: text2,
        type: type2,
        public_id,
        format,
        url: fetchUrl
      } = layer;
      const components = [];
      if (!isEmpty(text2) && isEmpty(resource_type)) {
        resource_type = "text";
      }
      if (!isEmpty(fetchUrl) && isEmpty(type2)) {
        type2 = "fetch";
      }
      if (!isEmpty(public_id) && !isEmpty(format)) {
        public_id = `${public_id}.${format}`;
      }
      if (isEmpty(public_id) && resource_type !== "text" && type2 !== "fetch") {
        throw new Error("Must supply public_id for non-text overlay");
      }
      if (!isEmpty(resource_type) && resource_type !== "image") {
        components.push(resource_type);
      }
      if (!isEmpty(type2) && type2 !== "upload") {
        components.push(type2);
      }
      if (resource_type === "text" || resource_type === "subtitles") {
        if (isEmpty(public_id) && isEmpty(text2)) {
          throw new Error("Must supply either text or public_in in overlay");
        }
        const textOptions = textStyle(layer);
        if (!isEmpty(textOptions)) {
          components.push(textOptions);
        }
        if (!isEmpty(public_id)) {
          public_id = public_id.replace("/", ":");
          components.push(public_id);
        }
        if (!isEmpty(text2)) {
          const variablesRegex = new RegExp(/(\$\([a-zA-Z]\w+\))/g);
          const textDividedByVariables = text2.split(variablesRegex).filter((x3) => x3);
          const encodedParts = textDividedByVariables.map((subText) => {
            const matches = variablesRegex[Symbol.match](subText);
            const isVariable = matches ? matches.length > 0 : false;
            if (isVariable) {
              return subText;
            }
            return encodeCurlyBraces(encodeURIComponent(smart_escape(subText, new RegExp(/([,\/])/g))));
          });
          components.push(encodedParts.join(""));
        }
      } else if (type2 === "fetch") {
        const encodedUrl = base64EncodeURL(fetchUrl);
        components.push(encodedUrl);
      } else {
        public_id = public_id.replace("/", ":");
        components.push(public_id);
      }
      return components.join(":");
    }
    __name(process_layer, "process_layer");
    function replaceAllSubstrings(string, search, replacement = "") {
      return string.split(search).join(replacement);
    }
    __name(replaceAllSubstrings, "replaceAllSubstrings");
    function encodeCurlyBraces(input) {
      return replaceAllSubstrings(replaceAllSubstrings(input, "(", "%28"), ")", "%29");
    }
    __name(encodeCurlyBraces, "encodeCurlyBraces");
    function process_radius(radius) {
      if (!radius) {
        return radius;
      }
      if (!isArray(radius)) {
        radius = [radius];
      }
      if (radius.length === 0 || radius.length > 4) {
        throw new Error("Radius array should contain between 1 and 4 values");
      }
      if (radius.findIndex((x3) => x3 === null) >= 0) {
        throw new Error("Corner: Cannot be null");
      }
      return radius.map(normalize_expression).join(":");
    }
    __name(process_radius, "process_radius");
    function build_multi_and_sprite_params(tagOrOptions, options) {
      let tag2 = null;
      if (typeof tagOrOptions === "string") {
        tag2 = tagOrOptions;
      } else {
        if (isEmpty(options)) {
          options = tagOrOptions;
        } else {
          throw new Error("First argument must be a tag when additional options are passed");
        }
        tag2 = null;
      }
      if (!options && !tag2) {
        throw new Error("Either tag or urls are required");
      }
      if (!options) {
        options = {};
      }
      const urls2 = options.urls;
      const transformation = generate_transformation_string(extend({}, options, {
        fetch_format: options.format
      }));
      return {
        tag: tag2,
        transformation,
        urls: urls2,
        timestamp: utils.timestamp(),
        async: options.async,
        notification_url: options.notification_url
      };
    }
    __name(build_multi_and_sprite_params, "build_multi_and_sprite_params");
    function build_upload_params(options) {
      let params = {
        access_mode: options.access_mode,
        allowed_formats: options.allowed_formats && toArray(options.allowed_formats).join(","),
        asset_folder: options.asset_folder,
        async: utils.as_safe_bool(options.async),
        backup: utils.as_safe_bool(options.backup),
        callback: options.callback,
        cinemagraph_analysis: utils.as_safe_bool(options.cinemagraph_analysis),
        colors: utils.as_safe_bool(options.colors),
        display_name: options.display_name,
        discard_original_filename: utils.as_safe_bool(options.discard_original_filename),
        eager: utils.build_eager(options.eager),
        eager_async: utils.as_safe_bool(options.eager_async),
        eager_notification_url: options.eager_notification_url,
        eval: options.eval,
        exif: utils.as_safe_bool(options.exif),
        faces: utils.as_safe_bool(options.faces),
        folder: options.folder,
        format: options.format,
        filename_override: options.filename_override,
        image_metadata: utils.as_safe_bool(options.image_metadata),
        media_metadata: utils.as_safe_bool(options.media_metadata),
        invalidate: utils.as_safe_bool(options.invalidate),
        moderation: options.moderation,
        notification_url: options.notification_url,
        overwrite: utils.as_safe_bool(options.overwrite),
        phash: utils.as_safe_bool(options.phash),
        proxy: options.proxy,
        public_id: options.public_id,
        public_id_prefix: options.public_id_prefix,
        quality_analysis: utils.as_safe_bool(options.quality_analysis),
        responsive_breakpoints: utils.generate_responsive_breakpoints_string(options.responsive_breakpoints),
        return_delete_token: utils.as_safe_bool(options.return_delete_token),
        timestamp: options.timestamp || exports.timestamp(),
        transformation: decodeURIComponent(utils.generate_transformation_string(clone(options))),
        type: options.type,
        unique_filename: utils.as_safe_bool(options.unique_filename),
        upload_preset: options.upload_preset,
        use_filename: utils.as_safe_bool(options.use_filename),
        use_filename_as_display_name: utils.as_safe_bool(options.use_filename_as_display_name),
        quality_override: options.quality_override,
        accessibility_analysis: utils.as_safe_bool(options.accessibility_analysis),
        use_asset_folder_as_public_id_prefix: utils.as_safe_bool(options.use_asset_folder_as_public_id_prefix),
        visual_search: utils.as_safe_bool(options.visual_search),
        on_success: options.on_success,
        auto_transcription: options.auto_transcription,
        auto_chaptering: utils.as_safe_bool(options.auto_chaptering)
      };
      return utils.updateable_resource_params(options, params);
    }
    __name(build_upload_params, "build_upload_params");
    function encode_key_value(arg) {
      if (!isObject3(arg)) {
        return arg;
      }
      return entries(arg).map(([k3, v4]) => `${k3}=${v4}`).join("|");
    }
    __name(encode_key_value, "encode_key_value");
    function escapeMetadataValue(value) {
      return value.toString().replace(/([=|])/g, "\\$&");
    }
    __name(escapeMetadataValue, "escapeMetadataValue");
    function encode_context(metadataObj) {
      if (!isObject3(metadataObj)) {
        return metadataObj;
      }
      return entries(metadataObj).map(([key, value]) => {
        if (isString(value)) {
          return `${key}=${escapeMetadataValue(value)}`;
        } else if (isArray(value)) {
          let values = value.map((innerVal) => {
            return `"${escapeMetadataValue(innerVal)}"`;
          }).join(",");
          return `${key}=[${values}]`;
        } else if (Number.isInteger(value)) {
          return `${key}=${escapeMetadataValue(String(value))}`;
        } else {
          return value.toString();
        }
      }).join("|");
    }
    __name(encode_context, "encode_context");
    function build_eager(transformations) {
      return toArray(transformations).map((transformation) => {
        const transformationString = utils.generate_transformation_string(clone(transformation));
        const format = transformation.format;
        return format == null ? transformationString : `${transformationString}/${format}`;
      }).join("|");
    }
    __name(build_eager, "build_eager");
    function build_custom_headers(headers) {
      switch (true) {
        case headers == null:
          return void 0;
        case isArray(headers):
          return headers.join("\n");
        case isObject3(headers):
          return entries(headers).map(([k3, v4]) => `${k3}:${v4}`).join("\n");
        default:
          return headers;
      }
    }
    __name(build_custom_headers, "build_custom_headers");
    function generate_transformation_string(options) {
      if (utils.isString(options)) {
        return options;
      }
      if (isArray(options)) {
        return options.map((t2) => utils.generate_transformation_string(clone(t2))).filter(utils.present).join("/");
      }
      let responsive_width = consumeOption(options, "responsive_width", config2().responsive_width);
      let width = options.width;
      let height = options.height;
      let size = consumeOption(options, "size");
      if (size) {
        [width, height] = size.split("x");
        [options.width, options.height] = [width, height];
      }
      let has_layer = options.overlay || options.underlay;
      let crop = consumeOption(options, "crop");
      let angle = toArray(consumeOption(options, "angle")).join(".");
      let no_html_sizes = has_layer || utils.present(angle) || crop === "fit" || crop === "limit" || responsive_width;
      if (width && (width.toString().indexOf("auto") === 0 || no_html_sizes || parseFloat(width) < 1)) {
        delete options.width;
      }
      if (height && (no_html_sizes || parseFloat(height) < 1)) {
        delete options.height;
      }
      let background = consumeOption(options, "background");
      background = background && background.replace(/^#/, "rgb:");
      let color = consumeOption(options, "color");
      color = color && color.replace(/^#/, "rgb:");
      let base_transformations = toArray(consumeOption(options, "transformation", []));
      let named_transformation = [];
      if (base_transformations.some(isObject3)) {
        base_transformations = base_transformations.map((tr) => utils.generate_transformation_string(
          isObject3(tr) ? clone(tr) : { transformation: tr }
        ));
      } else {
        named_transformation = base_transformations.join(".");
        base_transformations = [];
      }
      let effect = consumeOption(options, "effect");
      if (isArray(effect)) {
        effect = effect.join(":");
      } else if (isObject3(effect)) {
        effect = entries(effect).map(
          ([key, value]) => `${key}:${value}`
        );
      }
      let border = consumeOption(options, "border");
      if (isObject3(border)) {
        border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : "black").replace(/^#/, "rgb:")}`;
      } else if (/^\d+$/.exec(border)) {
        options.border = border;
        border = void 0;
      }
      let flags = toArray(consumeOption(options, "flags")).join(".");
      let dpr = consumeOption(options, "dpr", config2().dpr);
      if (options.offset != null) {
        [options.start_offset, options.end_offset] = split_range(consumeOption(options, "offset"));
      }
      if (options.start_offset) {
        options.start_offset = normalize_expression(options.start_offset);
      }
      if (options.end_offset) {
        options.end_offset = normalize_expression(options.end_offset);
      }
      let overlay = process_layer(consumeOption(options, "overlay"));
      let radius = process_radius(consumeOption(options, "radius"));
      let underlay = process_layer(consumeOption(options, "underlay"));
      let ifValue = process_if(consumeOption(options, "if"));
      let custom_function = process_custom_function(consumeOption(options, "custom_function"));
      let custom_pre_function = process_custom_pre_function(consumeOption(options, "custom_pre_function"));
      let fps = consumeOption(options, "fps");
      if (isArray(fps)) {
        fps = fps.join("-");
      }
      let params = {
        a: normalize_expression(angle),
        ar: normalize_expression(consumeOption(options, "aspect_ratio")),
        b: background,
        bo: border,
        c: crop,
        co: color,
        dpr: normalize_expression(dpr),
        e: normalize_expression(effect),
        fl: flags,
        fn: custom_function || custom_pre_function,
        fps,
        h: normalize_expression(height),
        ki: normalize_expression(consumeOption(options, "keyframe_interval")),
        l: overlay,
        o: normalize_expression(consumeOption(options, "opacity")),
        q: normalize_expression(consumeOption(options, "quality")),
        r: radius,
        t: named_transformation,
        u: underlay,
        w: normalize_expression(width),
        x: normalize_expression(consumeOption(options, "x")),
        y: normalize_expression(consumeOption(options, "y")),
        z: normalize_expression(consumeOption(options, "zoom"))
      };
      SIMPLE_PARAMS.forEach(([name, short]) => {
        let value = consumeOption(options, name);
        if (value !== void 0) {
          params[short] = value;
        }
      });
      if (params.vc != null) {
        params.vc = process_video_params(params.vc);
      }
      ["so", "eo", "du"].forEach((short) => {
        if (params[short] !== void 0) {
          params[short] = norm_range_value(params[short]);
        }
      });
      let variablesParam = consumeOption(options, "variables", []);
      let variables = entries(options).filter(([key, value]) => key.startsWith("$")).map(([key, value]) => {
        delete options[key];
        return `${key}_${normalize_expression(value)}`;
      }).sort().concat(
        variablesParam.map(([name, value]) => `${name}_${normalize_expression(value)}`)
      ).join(",");
      let transformations = entries(params).filter(([key, value]) => utils.present(value)).map(([key, value]) => key + "_" + value).sort().join(",");
      let raw_transformation = consumeOption(options, "raw_transformation");
      transformations = compact([ifValue, variables, transformations, raw_transformation]).join(",");
      base_transformations.push(transformations);
      transformations = base_transformations;
      if (responsive_width) {
        let responsive_width_transformation = config2().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;
        transformations.push(utils.generate_transformation_string(clone(responsive_width_transformation)));
      }
      if (String(width).startsWith("auto") || responsive_width) {
        options.responsive = true;
      }
      if (dpr === "auto") {
        options.hidpi = true;
      }
      return filter(transformations, utils.present).join("/");
    }
    __name(generate_transformation_string, "generate_transformation_string");
    function updateable_resource_params(options, params = {}) {
      if (options.access_control != null) {
        params.access_control = utils.jsonArrayParam(options.access_control);
      }
      if (options.auto_tagging != null) {
        params.auto_tagging = options.auto_tagging;
      }
      if (options.background_removal != null) {
        params.background_removal = options.background_removal;
      }
      if (options.categorization != null) {
        params.categorization = options.categorization;
      }
      if (options.context != null) {
        params.context = utils.encode_context(options.context);
      }
      if (options.metadata != null) {
        params.metadata = utils.encode_context(options.metadata);
      }
      if (options.custom_coordinates != null) {
        params.custom_coordinates = encodeDoubleArray(options.custom_coordinates);
      }
      if (options.detection != null) {
        params.detection = options.detection;
      }
      if (options.face_coordinates != null) {
        params.face_coordinates = encodeDoubleArray(options.face_coordinates);
      }
      if (options.headers != null) {
        params.headers = utils.build_custom_headers(options.headers);
      }
      if (options.notification_url != null) {
        params.notification_url = options.notification_url;
      }
      if (options.ocr != null) {
        params.ocr = options.ocr;
      }
      if (options.raw_convert != null) {
        params.raw_convert = options.raw_convert;
      }
      if (options.similarity_search != null) {
        params.similarity_search = options.similarity_search;
      }
      if (options.tags != null) {
        params.tags = toArray(options.tags).join(",");
      }
      if (options.quality_override != null) {
        params.quality_override = options.quality_override;
      }
      if (options.asset_folder != null) {
        params.asset_folder = options.asset_folder;
      }
      if (options.display_name != null) {
        params.display_name = options.display_name;
      }
      if (options.unique_display_name != null) {
        params.unique_display_name = options.unique_display_name;
      }
      if (options.visual_search != null) {
        params.visual_search = options.visual_search;
      }
      if (options.regions != null) {
        params.regions = JSON.stringify(options.regions);
      }
      const autoTranscription = options.auto_transcription;
      if (autoTranscription != null) {
        if (typeof autoTranscription === "boolean") {
          params.auto_transcription = utils.as_safe_bool(autoTranscription);
        } else {
          const isAutoTranscriptionObject = typeof autoTranscription === "object" && !Array.isArray(autoTranscription);
          if (isAutoTranscriptionObject && Object.keys(autoTranscription).includes("translate")) {
            params.auto_transcription = JSON.stringify(autoTranscription);
          }
        }
      }
      return params;
    }
    __name(updateable_resource_params, "updateable_resource_params");
    var URL_KEYS = [
      "api_secret",
      "auth_token",
      "cdn_subdomain",
      "cloud_name",
      "cname",
      "format",
      "long_url_signature",
      "private_cdn",
      "resource_type",
      "secure",
      "secure_cdn_subdomain",
      "secure_distribution",
      "shorten",
      "sign_url",
      "ssl_detected",
      "type",
      "url_suffix",
      "use_root_path",
      "version"
    ];
    function extractUrlParams(options) {
      return pickOnlyExistingValues(options, ...URL_KEYS);
    }
    __name(extractUrlParams, "extractUrlParams");
    function extractTransformationParams(options) {
      return pickOnlyExistingValues(options, ...TRANSFORMATION_PARAMS);
    }
    __name(extractTransformationParams, "extractTransformationParams");
    function patchFetchFormat(options = {}) {
      if (options.type === "fetch") {
        if (options.fetch_format == null) {
          options.fetch_format = consumeOption(options, "format");
        }
      }
    }
    __name(patchFetchFormat, "patchFetchFormat");
    function build_distribution_domain(source, options) {
      const cloud_name = consumeOption(options, "cloud_name", config2().cloud_name);
      if (!cloud_name) {
        throw new Error("Must supply cloud_name in tag or in configuration");
      }
      let secure = consumeOption(options, "secure", true);
      const ssl_detected = consumeOption(options, "ssl_detected", config2().ssl_detected);
      if (secure === null) {
        secure = ssl_detected || config2().secure;
      }
      const private_cdn = consumeOption(options, "private_cdn", config2().private_cdn);
      const cname = consumeOption(options, "cname", config2().cname);
      const secure_distribution = consumeOption(options, "secure_distribution", config2().secure_distribution);
      const cdn_subdomain = consumeOption(options, "cdn_subdomain", config2().cdn_subdomain);
      const secure_cdn_subdomain = consumeOption(options, "secure_cdn_subdomain", config2().secure_cdn_subdomain);
      return unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
    }
    __name(build_distribution_domain, "build_distribution_domain");
    function url(public_id, options = {}) {
      let signature, source_to_sign;
      utils.patchFetchFormat(options);
      let type2 = consumeOption(options, "type", null);
      let transformation = utils.generate_transformation_string(options);
      let resource_type = consumeOption(options, "resource_type", "image");
      let version4 = consumeOption(options, "version");
      let force_version = consumeOption(options, "force_version", config2().force_version);
      if (force_version == null) {
        force_version = true;
      }
      let long_url_signature = !!consumeOption(options, "long_url_signature", config2().long_url_signature);
      let format = consumeOption(options, "format");
      let shorten = consumeOption(options, "shorten", config2().shorten);
      let sign_url = consumeOption(options, "sign_url", config2().sign_url);
      let api_secret = consumeOption(options, "api_secret", config2().api_secret);
      let url_suffix = consumeOption(options, "url_suffix");
      let use_root_path = consumeOption(options, "use_root_path", config2().use_root_path);
      let signature_algorithm = consumeOption(options, "signature_algorithm", config2().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM);
      if (long_url_signature) {
        signature_algorithm = "sha256";
      }
      let auth_token = consumeOption(options, "auth_token");
      if (auth_token !== false) {
        auth_token = exports.merge(config2().auth_token, auth_token);
      }
      let preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
      if (preloaded) {
        resource_type = preloaded[1];
        type2 = preloaded[2];
        version4 = preloaded[3];
        public_id = preloaded[4];
      }
      let original_source = public_id;
      if (public_id == null) {
        return original_source;
      }
      public_id = public_id.toString();
      if (type2 === null && public_id.match(/^https?:\//i)) {
        return original_source;
      }
      [resource_type, type2] = finalize_resource_type(resource_type, type2, url_suffix, use_root_path, shorten);
      [public_id, source_to_sign] = finalize_source(public_id, format, url_suffix);
      if (version4 == null && force_version && source_to_sign.indexOf("/") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
        version4 = 1;
      }
      if (version4 != null) {
        version4 = `v${version4}`;
      } else {
        version4 = null;
      }
      transformation = transformation.replace(/([^:])\/\//g, "$1/");
      if (sign_url && isEmpty(auth_token)) {
        let to_sign = [transformation, source_to_sign].filter(function(part) {
          return part != null && part !== "";
        }).join("/");
        const signatureConfig = {};
        if (long_url_signature) {
          signatureConfig.algorithm = "sha256";
          signatureConfig.signatureLength = 32;
        } else {
          signatureConfig.algorithm = signature_algorithm;
          signatureConfig.signatureLength = 8;
        }
        const truncated = compute_hash(to_sign + api_secret, signatureConfig.algorithm, "base64").slice(0, signatureConfig.signatureLength).replace(/\//g, "_").replace(/\+/g, "-");
        signature = `s--${truncated}--`;
      }
      let prefix = build_distribution_domain(public_id, options);
      let resultUrl = [prefix, resource_type, type2, signature, transformation, version4, public_id].filter(function(part) {
        return part != null && part !== "";
      }).join("/").replace(/ /g, "%20");
      if (sign_url && !isEmpty(auth_token)) {
        auth_token.url = urlParse2(resultUrl).path;
        let token = generate_token(auth_token);
        resultUrl += `?${token}`;
      }
      const urlAnalytics = ensureOption(options, "urlAnalytics", ensureOption(options, "analytics", true));
      if (urlAnalytics === true) {
        let {
          sdkCode: sdkCodeDefault,
          sdkSemver: sdkSemverDefault,
          techVersion: techVersionDefault,
          product: productDefault
        } = getSDKVersions();
        const sdkCode = ensureOption(options, "sdkCode", ensureOption(options, "sdk_code", sdkCodeDefault));
        const sdkSemver = ensureOption(options, "sdkSemver", ensureOption(options, "sdk_semver", sdkSemverDefault));
        const techVersion = ensureOption(options, "techVersion", ensureOption(options, "tech_version", techVersionDefault));
        const product2 = ensureOption(options, "product", productDefault);
        let sdkVersions = {
          sdkCode,
          sdkSemver,
          techVersion,
          product: product2,
          urlAnalytics
        };
        let analyticsOptions = getAnalyticsOptions(
          Object.assign({}, options, sdkVersions)
        );
        let sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);
        let appender = "?";
        if (resultUrl.indexOf("?") >= 0) {
          appender = "&";
        }
        resultUrl = `${resultUrl}${appender}_a=${sdkAnalyticsSignature}`;
      }
      return resultUrl;
    }
    __name(url, "url");
    function video_url(public_id, options) {
      options = extend({
        resource_type: "video"
      }, options);
      return utils.url(public_id, options);
    }
    __name(video_url, "video_url");
    function finalize_source(source, format, url_suffix) {
      let source_to_sign;
      source = source.replace(/([^:])\/\//g, "$1/");
      if (source.match(/^https?:\//i)) {
        source = smart_escape(source);
        source_to_sign = source;
      } else {
        source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, ":").replace(/%2F/g, "/");
        source_to_sign = source;
        if (url_suffix) {
          if (url_suffix.match(/[\.\/]/)) {
            throw new Error("url_suffix should not include . or /");
          }
          source = source + "/" + url_suffix;
        }
        if (format != null) {
          source = source + "." + format;
          source_to_sign = source_to_sign + "." + format;
        }
      }
      return [source, source_to_sign];
    }
    __name(finalize_source, "finalize_source");
    function video_thumbnail_url(public_id, options) {
      options = extend({}, DEFAULT_POSTER_OPTIONS, options);
      return utils.url(public_id, options);
    }
    __name(video_thumbnail_url, "video_thumbnail_url");
    function finalize_resource_type(resource_type, type2, url_suffix, use_root_path, shorten) {
      if (type2 == null) {
        type2 = "upload";
      }
      if (url_suffix != null) {
        if (resource_type === "image" && type2 === "upload") {
          resource_type = "images";
          type2 = null;
        } else if (resource_type === "image" && type2 === "private") {
          resource_type = "private_images";
          type2 = null;
        } else if (resource_type === "image" && type2 === "authenticated") {
          resource_type = "authenticated_images";
          type2 = null;
        } else if (resource_type === "raw" && type2 === "upload") {
          resource_type = "files";
          type2 = null;
        } else if (resource_type === "video" && type2 === "upload") {
          resource_type = "videos";
          type2 = null;
        } else {
          throw new Error("URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload");
        }
      }
      if (use_root_path) {
        if (resource_type === "image" && type2 === "upload" || resource_type === "images" && type2 == null) {
          resource_type = null;
          type2 = null;
        } else {
          throw new Error("Root path only supported for image/upload");
        }
      }
      if (shorten && resource_type === "image" && type2 === "upload") {
        resource_type = "iu";
        type2 = null;
      }
      return [resource_type, type2];
    }
    __name(finalize_resource_type, "finalize_resource_type");
    function unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
      let prefix;
      if (cloud_name.indexOf("/") === 0) {
        return "/res" + cloud_name;
      }
      let shared_domain = !private_cdn;
      if (secure) {
        if (secure_distribution == null || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
          secure_distribution = private_cdn ? cloud_name + "-res.cloudinary.com" : exports.SHARED_CDN;
        }
        if (shared_domain == null) {
          shared_domain = secure_distribution === exports.SHARED_CDN;
        }
        if (secure_cdn_subdomain == null && shared_domain) {
          secure_cdn_subdomain = cdn_subdomain;
        }
        if (secure_cdn_subdomain) {
          secure_distribution = secure_distribution.replace("res.cloudinary.com", "res-" + (crc32(source) % 5 + 1 + ".cloudinary.com"));
        }
        prefix = "https://" + secure_distribution;
      } else if (cname) {
        let subdomain = cdn_subdomain ? "a" + (crc32(source) % 5 + 1) + "." : "";
        prefix = "http://" + subdomain + cname;
      } else {
        let cdn_part = private_cdn ? cloud_name + "-" : "";
        let subdomain_part = cdn_subdomain ? "-" + (crc32(source) % 5 + 1) : "";
        let host = [cdn_part, "res", subdomain_part, ".cloudinary.com"].join("");
        prefix = "http://" + host;
      }
      if (shared_domain) {
        prefix += "/" + cloud_name;
      }
      return prefix;
    }
    __name(unsigned_url_prefix, "unsigned_url_prefix");
    function base_api_url_v1_1() {
      return base_api_url("v1_1");
    }
    __name(base_api_url_v1_1, "base_api_url_v1_1");
    function base_api_url_v2() {
      return base_api_url("v2");
    }
    __name(base_api_url_v2, "base_api_url_v2");
    function base_api_url(api_version) {
      if (!api_version || api_version.length === 0) {
        throw new Error("api_version needs to be a non-empty string");
      }
      return (path2 = [], options = []) => {
        let cloudinary2 = ensureOption(options, "upload_prefix", UPLOAD_PREFIX);
        let cloud_name = ensureOption(options, "cloud_name");
        let encode_path = /* @__PURE__ */ __name((unencoded_path) => encodeURIComponent(unencoded_path).replace("'", "%27"), "encode_path");
        let encoded_path = Array.isArray(path2) ? path2.map(encode_path) : encode_path(path2);
        return [cloudinary2, api_version, cloud_name].concat(encoded_path).join("/");
      };
    }
    __name(base_api_url, "base_api_url");
    function api_url(action = "upload", options = {}) {
      let resource_type = options.resource_type || "image";
      return base_api_url_v1_1()([resource_type, action], options);
    }
    __name(api_url, "api_url");
    function random_public_id() {
      return crypto2.randomBytes(12).toString("base64").replace(/[^a-z0-9]/g, "");
    }
    __name(random_public_id, "random_public_id");
    function signed_preloaded_image(result) {
      return `${result.resource_type}/upload/v${result.version}/${filter([result.public_id, result.format], utils.present).join(".")}#${result.signature}`;
    }
    __name(signed_preloaded_image, "signed_preloaded_image");
    function api_sign_request(params_to_sign, api_secret) {
      let to_sign = entries(params_to_sign).filter(
        ([k3, v4]) => utils.present(v4)
      ).map(
        ([k3, v4]) => `${k3}=${toArray(v4).join(",")}`
      ).sort().join("&");
      return compute_hash(to_sign + api_secret, config2().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM, "hex");
    }
    __name(api_sign_request, "api_sign_request");
    function compute_hash(input, signature_algorithm, encoding) {
      if (!SUPPORTED_SIGNATURE_ALGORITHMS.includes(signature_algorithm)) {
        throw new Error(`Signature algorithm ${signature_algorithm} is not supported. Supported algorithms: ${SUPPORTED_SIGNATURE_ALGORITHMS.join(", ")}`);
      }
      const hash2 = crypto2.createHash(signature_algorithm).update(input).digest();
      return Buffer.from(hash2).toString(encoding);
    }
    __name(compute_hash, "compute_hash");
    function clear_blank(hash2) {
      let filtered_hash = {};
      entries(hash2).filter(
        ([k3, v4]) => utils.present(v4)
      ).forEach(
        ([k3, v4]) => {
          filtered_hash[k3] = v4.filter ? v4.filter((x3) => x3) : v4;
        }
      );
      return filtered_hash;
    }
    __name(clear_blank, "clear_blank");
    function sort_object_by_key(object) {
      return Object.keys(object).sort().reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
      }, {});
    }
    __name(sort_object_by_key, "sort_object_by_key");
    function merge2(hash1, hash2) {
      return { ...hash1, ...hash2 };
    }
    __name(merge2, "merge");
    function sign_request(params, options = {}) {
      let apiKey = ensureOption(options, "api_key");
      let apiSecret = ensureOption(options, "api_secret");
      params = exports.clear_blank(params);
      params.signature = exports.api_sign_request(params, apiSecret);
      params.api_key = apiKey;
      return params;
    }
    __name(sign_request, "sign_request");
    function webhook_signature(data, timestamp2, options = {}) {
      ensurePresenceOf({
        data,
        timestamp: timestamp2
      });
      let api_secret = ensureOption(options, "api_secret");
      let signature_algorithm = ensureOption(options, "signature_algorithm", DEFAULT_SIGNATURE_ALGORITHM);
      return compute_hash(data + timestamp2 + api_secret, signature_algorithm, "hex");
    }
    __name(webhook_signature, "webhook_signature");
    function verifyNotificationSignature(body, timestamp2, signature, valid_for = 7200) {
      if (timestamp2 < Math.round(Date.now() / 1e3) - valid_for) {
        return false;
      }
      const payload_hash = utils.webhook_signature(body, timestamp2, {
        api_secret: config2().api_secret,
        signature_algorithm: config2().signature_algorithm
      });
      return signature === payload_hash;
    }
    __name(verifyNotificationSignature, "verifyNotificationSignature");
    function process_request_params(params, options) {
      if (options.unsigned != null && options.unsigned) {
        params = exports.clear_blank(params);
        delete params.timestamp;
      } else if (options.oauth_token || config2().oauth_token) {
        params = exports.clear_blank(params);
      } else if (options.signature) {
        params = exports.clear_blank(options);
      } else {
        params = exports.sign_request(params, options);
      }
      return params;
    }
    __name(process_request_params, "process_request_params");
    function private_download_url(public_id, format, options = {}) {
      let params = exports.sign_request({
        timestamp: options.timestamp || exports.timestamp(),
        public_id,
        format,
        type: options.type,
        attachment: options.attachment,
        expires_at: options.expires_at
      }, options);
      return exports.api_url("download", options) + "?" + querystring.stringify(params);
    }
    __name(private_download_url, "private_download_url");
    function zip_download_url(tag2, options = {}) {
      let params = exports.sign_request({
        timestamp: options.timestamp || exports.timestamp(),
        tag: tag2,
        transformation: utils.generate_transformation_string(options)
      }, options);
      return exports.api_url("download_tag.zip", options) + "?" + hashToQuery(params);
    }
    __name(zip_download_url, "zip_download_url");
    function download_backedup_asset(asset_id, version_id, options = {}) {
      let params = exports.sign_request({
        timestamp: options.timestamp || exports.timestamp(),
        asset_id,
        version_id
      }, options);
      return exports.base_api_url_v1()(["download_backup"], options) + "?" + hashToQuery(params);
    }
    __name(download_backedup_asset, "download_backedup_asset");
    function api_download_url(action, params, options) {
      const download_params = {
        ...params,
        mode: "download"
      };
      let cloudinary_params = exports.sign_request(download_params, options);
      return exports.api_url(action, options) + "?" + hashToQuery(cloudinary_params);
    }
    __name(api_download_url, "api_download_url");
    function download_archive_url(options = {}) {
      const params = exports.archive_params(merge2(options, {
        mode: "download"
      }));
      return api_download_url("generate_archive", params, options);
    }
    __name(download_archive_url, "download_archive_url");
    function download_zip_url(options = {}) {
      return exports.download_archive_url(merge2(options, {
        target_format: "zip"
      }));
    }
    __name(download_zip_url, "download_zip_url");
    function download_folder(folder_path, options = {}) {
      options.resource_type = options.resource_type || "all";
      options.prefixes = folder_path;
      let cloudinary_params = exports.sign_request(exports.archive_params(merge2(options, {
        mode: "download"
      })), options);
      return exports.api_url("generate_archive", options) + "?" + hashToQuery(cloudinary_params);
    }
    __name(download_folder, "download_folder");
    function join_pair(key, value) {
      if (!value) {
        return void 0;
      }
      return value === true ? key : key + "='" + value + "'";
    }
    __name(join_pair, "join_pair");
    function escapeQuotes(value) {
      return isString(value) ? value.replace(/\"/g, "&#34;").replace(/\'/g, "&#39;") : value;
    }
    __name(escapeQuotes, "escapeQuotes");
    exports.html_attrs = /* @__PURE__ */ __name(function html_attrs(attrs) {
      return filter(map2(attrs, function(value, key) {
        return join_pair(key, escapeQuotes(value));
      })).sort().join(" ");
    }, "html_attrs");
    var CLOUDINARY_JS_CONFIG_PARAMS = ["api_key", "cloud_name", "private_cdn", "secure_distribution", "cdn_subdomain"];
    function cloudinary_js_config() {
      let params = pickOnlyExistingValues(config2(), ...CLOUDINARY_JS_CONFIG_PARAMS);
      return `<script type='text/javascript'>
$.cloudinary.config(${JSON.stringify(params)});
<\/script>`;
    }
    __name(cloudinary_js_config, "cloudinary_js_config");
    function v1_result_adapter(callback2) {
      if (callback2 == null) {
        return void 0;
      }
      return function(result) {
        if (result.error != null) {
          return callback2(result.error);
        }
        return callback2(void 0, result);
      };
    }
    __name(v1_result_adapter, "v1_result_adapter");
    function v1_adapter(name, num_pass_args, v1) {
      return function(...args) {
        let pass_args = take(args, num_pass_args);
        let options = args[num_pass_args];
        let callback2 = args[num_pass_args + 1];
        if (callback2 == null && isFunction(options)) {
          callback2 = options;
          options = {};
        }
        callback2 = v1_result_adapter(callback2);
        args = pass_args.concat([callback2, options]);
        return v1[name].apply(this, args);
      };
    }
    __name(v1_adapter, "v1_adapter");
    function v1_adapters(exports2, v1, mapping) {
      return Object.keys(mapping).map((name) => {
        let num_pass_args = mapping[name];
        exports2[name] = v1_adapter(name, num_pass_args, v1);
        return exports2[name];
      });
    }
    __name(v1_adapters, "v1_adapters");
    function as_safe_bool(value) {
      if (value == null) {
        return void 0;
      }
      if (value === true || value === "true" || value === "1") {
        value = 1;
      }
      if (value === false || value === "false" || value === "0") {
        value = 0;
      }
      return value;
    }
    __name(as_safe_bool, "as_safe_bool");
    var NUMBER_PATTERN = "([0-9]*)\\.([0-9]+)|([0-9]+)";
    var OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
    var RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}$`);
    var OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);
    function split_range(range) {
      switch (range.constructor) {
        case String:
          if (!OFFSET_ANY_PATTERN_RE.test(range)) {
            return range;
          }
          return range.split("..");
        case Array:
          return [first(range), last(range)];
        default:
          return [null, null];
      }
    }
    __name(split_range, "split_range");
    function norm_range_value(value) {
      let offset = String(value).match(RANGE_VALUE_RE);
      if (offset) {
        let modifier = offset[5] ? "p" : "";
        value = `${offset[1] || offset[4]}${modifier}`;
      }
      return value;
    }
    __name(norm_range_value, "norm_range_value");
    function process_video_params(param) {
      switch (param.constructor) {
        case Object: {
          let video = "";
          if ("codec" in param) {
            video = param.codec;
            if ("profile" in param) {
              video += ":" + param.profile;
              if ("level" in param) {
                video += ":" + param.level;
              }
            }
          }
          return video;
        }
        case String:
          return param;
        default:
          return null;
      }
    }
    __name(process_video_params, "process_video_params");
    function archive_params(options = {}) {
      return {
        allow_missing: exports.as_safe_bool(options.allow_missing),
        async: exports.as_safe_bool(options.async),
        expires_at: options.expires_at,
        flatten_folders: exports.as_safe_bool(options.flatten_folders),
        flatten_transformations: exports.as_safe_bool(options.flatten_transformations),
        keep_derived: exports.as_safe_bool(options.keep_derived),
        mode: options.mode,
        notification_url: options.notification_url,
        prefixes: options.prefixes && toArray(options.prefixes),
        fully_qualified_public_ids: options.fully_qualified_public_ids && toArray(options.fully_qualified_public_ids),
        public_ids: options.public_ids && toArray(options.public_ids),
        skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),
        tags: options.tags && toArray(options.tags),
        target_format: options.target_format,
        target_public_id: options.target_public_id,
        target_tags: options.target_tags && toArray(options.target_tags),
        timestamp: options.timestamp || exports.timestamp(),
        transformations: utils.build_eager(options.transformations),
        type: options.type,
        use_original_filename: exports.as_safe_bool(options.use_original_filename)
      };
    }
    __name(archive_params, "archive_params");
    exports.process_layer = process_layer;
    exports.create_source_tag = /* @__PURE__ */ __name(function create_source_tag(src, source_type, codecs = null) {
      let video_type = source_type === "ogv" ? "ogg" : source_type;
      let mime_type = `video/${video_type}`;
      if (!isEmpty(codecs)) {
        let codecs_str = isArray(codecs) ? codecs.join(", ") : codecs;
        mime_type += `; codecs=${codecs_str}`;
      }
      return `<source ${utils.html_attrs({
        src,
        type: mime_type
      })}>`;
    }, "create_source_tag");
    function build_explicit_api_params(public_id, options = {}) {
      return [exports.build_upload_params(extend({}, { public_id }, options))];
    }
    __name(build_explicit_api_params, "build_explicit_api_params");
    function generate_responsive_breakpoints_string(breakpoints) {
      if (breakpoints == null) {
        return null;
      }
      breakpoints = clone(breakpoints);
      if (!isArray(breakpoints)) {
        breakpoints = [breakpoints];
      }
      for (let j3 = 0; j3 < breakpoints.length; j3++) {
        let breakpoint_settings = breakpoints[j3];
        if (breakpoint_settings != null) {
          if (breakpoint_settings.transformation) {
            breakpoint_settings.transformation = utils.generate_transformation_string(
              clone(breakpoint_settings.transformation)
            );
          }
        }
      }
      return JSON.stringify(breakpoints);
    }
    __name(generate_responsive_breakpoints_string, "generate_responsive_breakpoints_string");
    function build_streaming_profiles_param(options = {}) {
      let params = pickOnlyExistingValues(options, "display_name", "representations");
      if (isArray(params.representations)) {
        params.representations = JSON.stringify(params.representations.map(
          (r3) => ({
            transformation: utils.generate_transformation_string(r3.transformation)
          })
        ));
      }
      return params;
    }
    __name(build_streaming_profiles_param, "build_streaming_profiles_param");
    function hashToParameters(hash2) {
      return entries(hash2).reduce((parameters, [key, value]) => {
        if (isArray(value)) {
          key = key.endsWith("[]") ? key : key + "[]";
          const items = value.map((v4) => [key, v4]);
          parameters = parameters.concat(items);
        } else {
          parameters.push([key, value]);
        }
        return parameters;
      }, []);
    }
    __name(hashToParameters, "hashToParameters");
    function hashToQuery(hash2) {
      return hashToParameters(hash2).map(
        ([key, value]) => `${querystring.escape(key)}=${querystring.escape(value)}`
      ).join("&");
    }
    __name(hashToQuery, "hashToQuery");
    function present(value) {
      return value != null && ("" + value).length > 0;
    }
    __name(present, "present");
    function pickOnlyExistingValues(source, ...keys) {
      let result = {};
      if (source) {
        keys.forEach((key) => {
          if (source[key] != null) {
            result[key] = source[key];
          }
        });
      }
      return result;
    }
    __name(pickOnlyExistingValues, "pickOnlyExistingValues");
    function jsonArrayParam(data, modifier) {
      if (!data) {
        return null;
      }
      if (isString(data)) {
        data = JSON.parse(data);
      }
      if (!isArray(data)) {
        data = [data];
      }
      if (isFunction(modifier)) {
        data = modifier(data);
      }
      return JSON.stringify(data);
    }
    __name(jsonArrayParam, "jsonArrayParam");
    exports.NOP = function() {
    };
    exports.generate_auth_token = generate_auth_token;
    exports.getUserAgent = getUserAgent;
    exports.build_upload_params = build_upload_params;
    exports.build_multi_and_sprite_params = build_multi_and_sprite_params;
    exports.api_download_url = api_download_url;
    exports.timestamp = () => Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    exports.option_consume = consumeOption;
    exports.build_array = toArray;
    exports.encode_double_array = encodeDoubleArray;
    exports.encode_key_value = encode_key_value;
    exports.encode_context = encode_context;
    exports.build_eager = build_eager;
    exports.build_custom_headers = build_custom_headers;
    exports.generate_transformation_string = generate_transformation_string;
    exports.updateable_resource_params = updateable_resource_params;
    exports.extractUrlParams = extractUrlParams;
    exports.extractTransformationParams = extractTransformationParams;
    exports.patchFetchFormat = patchFetchFormat;
    exports.url = url;
    exports.video_url = video_url;
    exports.video_thumbnail_url = video_thumbnail_url;
    exports.api_url = api_url;
    exports.random_public_id = random_public_id;
    exports.signed_preloaded_image = signed_preloaded_image;
    exports.api_sign_request = api_sign_request;
    exports.clear_blank = clear_blank;
    exports.merge = merge2;
    exports.sign_request = sign_request;
    exports.webhook_signature = webhook_signature;
    exports.verifyNotificationSignature = verifyNotificationSignature;
    exports.process_request_params = process_request_params;
    exports.private_download_url = private_download_url;
    exports.zip_download_url = zip_download_url;
    exports.download_archive_url = download_archive_url;
    exports.download_zip_url = download_zip_url;
    exports.cloudinary_js_config = cloudinary_js_config;
    exports.v1_adapters = v1_adapters;
    exports.as_safe_bool = as_safe_bool;
    exports.archive_params = archive_params;
    exports.build_explicit_api_params = build_explicit_api_params;
    exports.generate_responsive_breakpoints_string = generate_responsive_breakpoints_string;
    exports.build_streaming_profiles_param = build_streaming_profiles_param;
    exports.hashToParameters = hashToParameters;
    exports.present = present;
    exports.only = pickOnlyExistingValues;
    exports.pickOnlyExistingValues = pickOnlyExistingValues;
    exports.jsonArrayParam = jsonArrayParam;
    exports.download_folder = download_folder;
    exports.base_api_url_v1 = base_api_url_v1_1;
    exports.base_api_url_v2 = base_api_url_v2;
    exports.download_backedup_asset = download_backedup_asset;
    exports.compute_hash = compute_hash;
    exports.build_distribution_domain = build_distribution_domain;
    exports.sort_object_by_key = sort_object_by_key;
    exports.DEFAULT_POSTER_OPTIONS = DEFAULT_POSTER_OPTIONS;
    exports.DEFAULT_VIDEO_SOURCE_TYPES = DEFAULT_VIDEO_SOURCE_TYPES;
    Object.assign(module.exports, {
      normalize_expression,
      at,
      clone,
      extend,
      filter,
      includes,
      isArray,
      isEmpty,
      isNumber,
      isObject: isObject3,
      isRemoteUrl,
      isString,
      isUndefined,
      keys: (source) => Object.keys(source),
      ensurePresenceOf
    });
  }
});

// node_modules/.pnpm/q@1.5.1/node_modules/q/q.js
var require_q = __commonJS({
  "node_modules/.pnpm/q@1.5.1/node_modules/q/q.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    (function(definition) {
      "use strict";
      if (typeof bootstrap === "function") {
        bootstrap("promise", definition);
      } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();
      } else if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        var global2 = typeof window !== "undefined" ? window : self;
        var previousQ = global2.Q;
        global2.Q = definition();
        global2.Q.noConflict = function() {
          global2.Q = previousQ;
          return this;
        };
      } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
      }
    })(function() {
      "use strict";
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e2) {
        hasStacks = !!e2.stack;
      }
      var qStartingLine = captureLine();
      var qFileName;
      var noop2 = /* @__PURE__ */ __name(function() {
      }, "noop");
      var nextTick3 = function() {
        var head = { task: void 0, next: null };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        var laterQueue = [];
        function flush() {
          var task, domain2;
          while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain2 = head.domain;
            if (domain2) {
              head.domain = void 0;
              domain2.enter();
            }
            runSingle(task, domain2);
          }
          while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
          }
          flushing = false;
        }
        __name(flush, "flush");
        function runSingle(task, domain2) {
          try {
            task();
          } catch (e2) {
            if (isNodeJS) {
              if (domain2) {
                domain2.exit();
              }
              setTimeout(flush, 0);
              if (domain2) {
                domain2.enter();
              }
              throw e2;
            } else {
              setTimeout(function() {
                throw e2;
              }, 0);
            }
          }
          if (domain2) {
            domain2.exit();
          }
        }
        __name(runSingle, "runSingle");
        nextTick3 = /* @__PURE__ */ __name(function(task) {
          tail = tail.next = {
            task,
            domain: isNodeJS && process.domain,
            next: null
          };
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        }, "nextTick");
        if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
          isNodeJS = true;
          requestTick = /* @__PURE__ */ __name(function() {
            process.nextTick(flush);
          }, "requestTick");
        } else if (typeof setImmediate === "function") {
          if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
          } else {
            requestTick = /* @__PURE__ */ __name(function() {
              setImmediate(flush);
            }, "requestTick");
          }
        } else if (typeof MessageChannel !== "undefined") {
          var channel2 = new MessageChannel();
          channel2.port1.onmessage = function() {
            requestTick = requestPortTick;
            channel2.port1.onmessage = flush;
            flush();
          };
          var requestPortTick = /* @__PURE__ */ __name(function() {
            channel2.port2.postMessage(0);
          }, "requestPortTick");
          requestTick = /* @__PURE__ */ __name(function() {
            setTimeout(flush, 0);
            requestPortTick();
          }, "requestTick");
        } else {
          requestTick = /* @__PURE__ */ __name(function() {
            setTimeout(flush, 0);
          }, "requestTick");
        }
        nextTick3.runAfter = function(task) {
          laterQueue.push(task);
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        return nextTick3;
      }();
      var call = Function.call;
      function uncurryThis(f4) {
        return function() {
          return call.apply(f4, arguments);
        };
      }
      __name(uncurryThis, "uncurryThis");
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(
        Array.prototype.reduce || function(callback2, basis) {
          var index = 0, length = this.length;
          if (arguments.length === 1) {
            do {
              if (index in this) {
                basis = this[index++];
                break;
              }
              if (++index >= length) {
                throw new TypeError();
              }
            } while (1);
          }
          for (; index < length; index++) {
            if (index in this) {
              basis = callback2(basis, this[index], index);
            }
          }
          return basis;
        }
      );
      var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function(value) {
          for (var i3 = 0; i3 < this.length; i3++) {
            if (this[i3] === value) {
              return i3;
            }
          }
          return -1;
        }
      );
      var array_map = uncurryThis(
        Array.prototype.map || function(callback2, thisp) {
          var self2 = this;
          var collect = [];
          array_reduce(self2, function(undefined2, value, index) {
            collect.push(callback2.call(thisp, value, index, self2));
          }, void 0);
          return collect;
        }
      );
      var object_create = Object.create || function(prototype) {
        function Type() {
        }
        __name(Type, "Type");
        Type.prototype = prototype;
        return new Type();
      };
      var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
        obj[prop] = descriptor.value;
        return obj;
      };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function(object) {
        var keys = [];
        for (var key in object) {
          if (object_hasOwnProperty(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isObject3(value) {
        return value === Object(value);
      }
      __name(isObject3, "isObject");
      function isStopIteration(exception) {
        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
      }
      __name(isStopIteration, "isStopIteration");
      var QReturnValue;
      if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = /* @__PURE__ */ __name(function(value) {
          this.value = value;
        }, "QReturnValue");
      }
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error4, promise2) {
        if (hasStacks && promise2.stack && typeof error4 === "object" && error4 !== null && error4.stack) {
          var stacks = [];
          for (var p5 = promise2; !!p5; p5 = p5.source) {
            if (p5.stack && (!error4.__minimumStackCounter__ || error4.__minimumStackCounter__ > p5.stackCounter)) {
              object_defineProperty(error4, "__minimumStackCounter__", { value: p5.stackCounter, configurable: true });
              stacks.unshift(p5.stack);
            }
          }
          stacks.unshift(error4.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          var stack = filterStackString(concatedStacks);
          object_defineProperty(error4, "stack", { value: stack, configurable: true });
        }
      }
      __name(makeStackTraceLong, "makeStackTraceLong");
      function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i3 = 0; i3 < lines.length; ++i3) {
          var line = lines[i3];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      __name(filterStackString, "filterStackString");
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      __name(isNodeFrame, "isNodeFrame");
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      __name(getFileNameAndLineNumber, "getFileNameAndLineNumber");
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      __name(isInternalFrame, "isInternalFrame");
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e2) {
          var lines = e2.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          qFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      __name(captureLine, "captureLine");
      function deprecate(callback2, name, alternative) {
        return function() {
          if (typeof console !== "undefined" && typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
          }
          return callback2.apply(callback2, arguments);
        };
      }
      __name(deprecate, "deprecate");
      function Q(value) {
        if (value instanceof Promise2) {
          return value;
        }
        if (isPromiseAlike(value)) {
          return coerce2(value);
        } else {
          return fulfill(value);
        }
      }
      __name(Q, "Q");
      Q.resolve = Q;
      Q.nextTick = nextTick3;
      Q.longStackSupport = false;
      var longStackCounter = 1;
      if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
      }
      Q.defer = defer;
      function defer() {
        var messages = [], progressListeners = [], resolvedPromise;
        var deferred = object_create(defer.prototype);
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, operands) {
          var args = array_slice(arguments);
          if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            Q.nextTick(function() {
              resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
          }
        };
        promise2.valueOf = function() {
          if (messages) {
            return promise2;
          }
          var nearerValue = nearer(resolvedPromise);
          if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue;
          }
          return nearerValue;
        };
        promise2.inspect = function() {
          if (!resolvedPromise) {
            return { state: "pending" };
          }
          return resolvedPromise.inspect();
        };
        if (Q.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e2) {
            promise2.stack = e2.stack.substring(e2.stack.indexOf("\n") + 1);
            promise2.stackCounter = longStackCounter++;
          }
        }
        function become(newPromise) {
          resolvedPromise = newPromise;
          if (Q.longStackSupport && hasStacks) {
            promise2.source = newPromise;
          }
          array_reduce(messages, function(undefined2, message2) {
            Q.nextTick(function() {
              newPromise.promiseDispatch.apply(newPromise, message2);
            });
          }, void 0);
          messages = void 0;
          progressListeners = void 0;
        }
        __name(become, "become");
        deferred.promise = promise2;
        deferred.resolve = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(Q(value));
        };
        deferred.fulfill = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(fulfill(value));
        };
        deferred.reject = function(reason) {
          if (resolvedPromise) {
            return;
          }
          become(reject(reason));
        };
        deferred.notify = function(progress2) {
          if (resolvedPromise) {
            return;
          }
          array_reduce(progressListeners, function(undefined2, progressListener) {
            Q.nextTick(function() {
              progressListener(progress2);
            });
          }, void 0);
        };
        return deferred;
      }
      __name(defer, "defer");
      defer.prototype.makeNodeResolver = function() {
        var self2 = this;
        return function(error4, value) {
          if (error4) {
            self2.reject(error4);
          } else if (arguments.length > 2) {
            self2.resolve(array_slice(arguments, 1));
          } else {
            self2.resolve(value);
          }
        };
      };
      Q.Promise = promise;
      Q.promise = promise;
      function promise(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
          resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
          deferred.reject(reason);
        }
        return deferred.promise;
      }
      __name(promise, "promise");
      promise.race = race;
      promise.all = all;
      promise.reject = reject;
      promise.resolve = Q;
      Q.passByCopy = function(object) {
        return object;
      };
      Promise2.prototype.passByCopy = function() {
        return this;
      };
      Q.join = function(x3, y3) {
        return Q(x3).join(y3);
      };
      Promise2.prototype.join = function(that) {
        return Q([this, that]).spread(function(x3, y3) {
          if (x3 === y3) {
            return x3;
          } else {
            throw new Error("Q can't join: not the same: " + x3 + " " + y3);
          }
        });
      };
      Q.race = race;
      function race(answerPs) {
        return promise(function(resolve, reject2) {
          for (var i3 = 0, len = answerPs.length; i3 < len; i3++) {
            Q(answerPs[i3]).then(resolve, reject2);
          }
        });
      }
      __name(race, "race");
      Promise2.prototype.race = function() {
        return this.then(Q.race);
      };
      Q.makePromise = Promise2;
      function Promise2(descriptor, fallback, inspect2) {
        if (fallback === void 0) {
          fallback = /* @__PURE__ */ __name(function(op) {
            return reject(new Error(
              "Promise does not support operation: " + op
            ));
          }, "fallback");
        }
        if (inspect2 === void 0) {
          inspect2 = /* @__PURE__ */ __name(function() {
            return { state: "unknown" };
          }, "inspect");
        }
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise2, args);
            } else {
              result = fallback.call(promise2, op, args);
            }
          } catch (exception) {
            result = reject(exception);
          }
          if (resolve) {
            resolve(result);
          }
        };
        promise2.inspect = inspect2;
        if (inspect2) {
          var inspected = inspect2();
          if (inspected.state === "rejected") {
            promise2.exception = inspected.reason;
          }
          promise2.valueOf = function() {
            var inspected2 = inspect2();
            if (inspected2.state === "pending" || inspected2.state === "rejected") {
              return promise2;
            }
            return inspected2.value;
          };
        }
        return promise2;
      }
      __name(Promise2, "Promise");
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.then = function(fulfilled, rejected, progressed) {
        var self2 = this;
        var deferred = defer();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
          } catch (exception) {
            return reject(exception);
          }
        }
        __name(_fulfilled, "_fulfilled");
        function _rejected(exception) {
          if (typeof rejected === "function") {
            makeStackTraceLong(exception, self2);
            try {
              return rejected(exception);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception);
        }
        __name(_rejected, "_rejected");
        function _progressed(value) {
          return typeof progressed === "function" ? progressed(value) : value;
        }
        __name(_progressed, "_progressed");
        Q.nextTick(function() {
          self2.promiseDispatch(function(value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, "when", [function(exception) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_rejected(exception));
          }]);
        });
        self2.promiseDispatch(void 0, "when", [void 0, function(value) {
          var newValue;
          var threw = false;
          try {
            newValue = _progressed(value);
          } catch (e2) {
            threw = true;
            if (Q.onerror) {
              Q.onerror(e2);
            } else {
              throw e2;
            }
          }
          if (!threw) {
            deferred.notify(newValue);
          }
        }]);
        return deferred.promise;
      };
      Q.tap = function(promise2, callback2) {
        return Q(promise2).tap(callback2);
      };
      Promise2.prototype.tap = function(callback2) {
        callback2 = Q(callback2);
        return this.then(function(value) {
          return callback2.fcall(value).thenResolve(value);
        });
      };
      Q.when = when;
      function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
      }
      __name(when, "when");
      Promise2.prototype.thenResolve = function(value) {
        return this.then(function() {
          return value;
        });
      };
      Q.thenResolve = function(promise2, value) {
        return Q(promise2).thenResolve(value);
      };
      Promise2.prototype.thenReject = function(reason) {
        return this.then(function() {
          throw reason;
        });
      };
      Q.thenReject = function(promise2, reason) {
        return Q(promise2).thenReject(reason);
      };
      Q.nearer = nearer;
      function nearer(value) {
        if (isPromise(value)) {
          var inspected = value.inspect();
          if (inspected.state === "fulfilled") {
            return inspected.value;
          }
        }
        return value;
      }
      __name(nearer, "nearer");
      Q.isPromise = isPromise;
      function isPromise(object) {
        return object instanceof Promise2;
      }
      __name(isPromise, "isPromise");
      Q.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return isObject3(object) && typeof object.then === "function";
      }
      __name(isPromiseAlike, "isPromiseAlike");
      Q.isPending = isPending;
      function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
      }
      __name(isPending, "isPending");
      Promise2.prototype.isPending = function() {
        return this.inspect().state === "pending";
      };
      Q.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
      }
      __name(isFulfilled, "isFulfilled");
      Promise2.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
      };
      Q.isRejected = isRejected;
      function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
      }
      __name(isRejected, "isRejected");
      Promise2.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
      };
      var unhandledReasons = [];
      var unhandledRejections = [];
      var reportedUnhandledRejections = [];
      var trackUnhandledRejections = true;
      function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        if (!trackUnhandledRejections) {
          trackUnhandledRejections = true;
        }
      }
      __name(resetUnhandledRejections, "resetUnhandledRejections");
      function trackRejection(promise2, reason) {
        if (!trackUnhandledRejections) {
          return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            if (array_indexOf(unhandledRejections, promise2) !== -1) {
              process.emit("unhandledRejection", reason, promise2);
              reportedUnhandledRejections.push(promise2);
            }
          });
        }
        unhandledRejections.push(promise2);
        if (reason && typeof reason.stack !== "undefined") {
          unhandledReasons.push(reason.stack);
        } else {
          unhandledReasons.push("(no stack) " + reason);
        }
      }
      __name(trackRejection, "trackRejection");
      function untrackRejection(promise2) {
        if (!trackUnhandledRejections) {
          return;
        }
        var at = array_indexOf(unhandledRejections, promise2);
        if (at !== -1) {
          if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function() {
              var atReport = array_indexOf(reportedUnhandledRejections, promise2);
              if (atReport !== -1) {
                process.emit("rejectionHandled", unhandledReasons[at], promise2);
                reportedUnhandledRejections.splice(atReport, 1);
              }
            });
          }
          unhandledRejections.splice(at, 1);
          unhandledReasons.splice(at, 1);
        }
      }
      __name(untrackRejection, "untrackRejection");
      Q.resetUnhandledRejections = resetUnhandledRejections;
      Q.getUnhandledReasons = function() {
        return unhandledReasons.slice();
      };
      Q.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
      };
      resetUnhandledRejections();
      Q.reject = reject;
      function reject(reason) {
        var rejection = Promise2({
          "when": function(rejected) {
            if (rejected) {
              untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
          }
        }, /* @__PURE__ */ __name(function fallback() {
          return this;
        }, "fallback"), /* @__PURE__ */ __name(function inspect2() {
          return { state: "rejected", reason };
        }, "inspect"));
        trackRejection(rejection, reason);
        return rejection;
      }
      __name(reject, "reject");
      Q.fulfill = fulfill;
      function fulfill(value) {
        return Promise2({
          "when": function() {
            return value;
          },
          "get": function(name) {
            return value[name];
          },
          "set": function(name, rhs) {
            value[name] = rhs;
          },
          "delete": function(name) {
            delete value[name];
          },
          "post": function(name, args) {
            if (name === null || name === void 0) {
              return value.apply(void 0, args);
            } else {
              return value[name].apply(value, args);
            }
          },
          "apply": function(thisp, args) {
            return value.apply(thisp, args);
          },
          "keys": function() {
            return object_keys(value);
          }
        }, void 0, /* @__PURE__ */ __name(function inspect2() {
          return { state: "fulfilled", value };
        }, "inspect"));
      }
      __name(fulfill, "fulfill");
      function coerce2(promise2) {
        var deferred = defer();
        Q.nextTick(function() {
          try {
            promise2.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
            deferred.reject(exception);
          }
        });
        return deferred.promise;
      }
      __name(coerce2, "coerce");
      Q.master = master;
      function master(object) {
        return Promise2({
          "isDef": function() {
          }
        }, /* @__PURE__ */ __name(function fallback(op, args) {
          return dispatch(object, op, args);
        }, "fallback"), function() {
          return Q(object).inspect();
        });
      }
      __name(master, "master");
      Q.spread = spread;
      function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
      }
      __name(spread, "spread");
      Promise2.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
          return fulfilled.apply(void 0, array);
        }, rejected);
      };
      Q.async = async;
      function async(makeGenerator) {
        return function() {
          function continuer(verb, arg) {
            var result;
            if (typeof StopIteration === "undefined") {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                return reject(exception);
              }
              if (result.done) {
                return Q(result.value);
              } else {
                return when(result.value, callback2, errback);
              }
            } else {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                if (isStopIteration(exception)) {
                  return Q(exception.value);
                } else {
                  return reject(exception);
                }
              }
              return when(result, callback2, errback);
            }
          }
          __name(continuer, "continuer");
          var generator = makeGenerator.apply(this, arguments);
          var callback2 = continuer.bind(continuer, "next");
          var errback = continuer.bind(continuer, "throw");
          return callback2();
        };
      }
      __name(async, "async");
      Q.spawn = spawn;
      function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
      }
      __name(spawn, "spawn");
      Q["return"] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      __name(_return, "_return");
      Q.promised = promised;
      function promised(callback2) {
        return function() {
          return spread([this, all(arguments)], function(self2, args) {
            return callback2.apply(self2, args);
          });
        };
      }
      __name(promised, "promised");
      Q.dispatch = dispatch;
      function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
      }
      __name(dispatch, "dispatch");
      Promise2.prototype.dispatch = function(op, args) {
        var self2 = this;
        var deferred = defer();
        Q.nextTick(function() {
          self2.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      };
      Q.get = function(object, key) {
        return Q(object).dispatch("get", [key]);
      };
      Promise2.prototype.get = function(key) {
        return this.dispatch("get", [key]);
      };
      Q.set = function(object, key, value) {
        return Q(object).dispatch("set", [key, value]);
      };
      Promise2.prototype.set = function(key, value) {
        return this.dispatch("set", [key, value]);
      };
      Q.del = // XXX legacy
      Q["delete"] = function(object, key) {
        return Q(object).dispatch("delete", [key]);
      };
      Promise2.prototype.del = // XXX legacy
      Promise2.prototype["delete"] = function(key) {
        return this.dispatch("delete", [key]);
      };
      Q.mapply = // XXX As proposed by "Redsandro"
      Q.post = function(object, name, args) {
        return Q(object).dispatch("post", [name, args]);
      };
      Promise2.prototype.mapply = // XXX As proposed by "Redsandro"
      Promise2.prototype.post = function(name, args) {
        return this.dispatch("post", [name, args]);
      };
      Q.send = // XXX Mark Miller's proposed parlance
      Q.mcall = // XXX As proposed by "Redsandro"
      Q.invoke = function(object, name) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
      };
      Promise2.prototype.send = // XXX Mark Miller's proposed parlance
      Promise2.prototype.mcall = // XXX As proposed by "Redsandro"
      Promise2.prototype.invoke = function(name) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
      };
      Q.fapply = function(object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
      };
      Promise2.prototype.fapply = function(args) {
        return this.dispatch("apply", [void 0, args]);
      };
      Q["try"] = Q.fcall = function(object) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
      };
      Promise2.prototype.fcall = function() {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
      };
      Q.fbind = function(object) {
        var promise2 = Q(object);
        var args = array_slice(arguments, 1);
        return /* @__PURE__ */ __name(function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        }, "fbound");
      };
      Promise2.prototype.fbind = function() {
        var promise2 = this;
        var args = array_slice(arguments);
        return /* @__PURE__ */ __name(function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        }, "fbound");
      };
      Q.keys = function(object) {
        return Q(object).dispatch("keys", []);
      };
      Promise2.prototype.keys = function() {
        return this.dispatch("keys", []);
      };
      Q.all = all;
      function all(promises2) {
        return when(promises2, function(promises3) {
          var pendingCount = 0;
          var deferred = defer();
          array_reduce(promises3, function(undefined2, promise2, index) {
            var snapshot;
            if (isPromise(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
              promises3[index] = snapshot.value;
            } else {
              ++pendingCount;
              when(
                promise2,
                function(value) {
                  promises3[index] = value;
                  if (--pendingCount === 0) {
                    deferred.resolve(promises3);
                  }
                },
                deferred.reject,
                function(progress2) {
                  deferred.notify({ index, value: progress2 });
                }
              );
            }
          }, void 0);
          if (pendingCount === 0) {
            deferred.resolve(promises3);
          }
          return deferred.promise;
        });
      }
      __name(all, "all");
      Promise2.prototype.all = function() {
        return all(this);
      };
      Q.any = any;
      function any(promises2) {
        if (promises2.length === 0) {
          return Q.resolve();
        }
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises2, function(prev, current, index) {
          var promise2 = promises2[index];
          pendingCount++;
          when(promise2, onFulfilled, onRejected, onProgress);
          function onFulfilled(result) {
            deferred.resolve(result);
          }
          __name(onFulfilled, "onFulfilled");
          function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
              var rejection = err || new Error("" + err);
              rejection.message = "Q can't get fulfillment value from any promise, all promises were rejected. Last error message: " + rejection.message;
              deferred.reject(rejection);
            }
          }
          __name(onRejected, "onRejected");
          function onProgress(progress2) {
            deferred.notify({
              index,
              value: progress2
            });
          }
          __name(onProgress, "onProgress");
        }, void 0);
        return deferred.promise;
      }
      __name(any, "any");
      Promise2.prototype.any = function() {
        return any(this);
      };
      Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
      function allResolved(promises2) {
        return when(promises2, function(promises3) {
          promises3 = array_map(promises3, Q);
          return when(all(array_map(promises3, function(promise2) {
            return when(promise2, noop2, noop2);
          })), function() {
            return promises3;
          });
        });
      }
      __name(allResolved, "allResolved");
      Promise2.prototype.allResolved = function() {
        return allResolved(this);
      };
      Q.allSettled = allSettled;
      function allSettled(promises2) {
        return Q(promises2).allSettled();
      }
      __name(allSettled, "allSettled");
      Promise2.prototype.allSettled = function() {
        return this.then(function(promises2) {
          return all(array_map(promises2, function(promise2) {
            promise2 = Q(promise2);
            function regardless() {
              return promise2.inspect();
            }
            __name(regardless, "regardless");
            return promise2.then(regardless, regardless);
          }));
        });
      };
      Q.fail = // XXX legacy
      Q["catch"] = function(object, rejected) {
        return Q(object).then(void 0, rejected);
      };
      Promise2.prototype.fail = // XXX legacy
      Promise2.prototype["catch"] = function(rejected) {
        return this.then(void 0, rejected);
      };
      Q.progress = progress;
      function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
      }
      __name(progress, "progress");
      Promise2.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
      };
      Q.fin = // XXX legacy
      Q["finally"] = function(object, callback2) {
        return Q(object)["finally"](callback2);
      };
      Promise2.prototype.fin = // XXX legacy
      Promise2.prototype["finally"] = function(callback2) {
        if (!callback2 || typeof callback2.apply !== "function") {
          throw new Error("Q can't apply finally callback");
        }
        callback2 = Q(callback2);
        return this.then(function(value) {
          return callback2.fcall().then(function() {
            return value;
          });
        }, function(reason) {
          return callback2.fcall().then(function() {
            throw reason;
          });
        });
      };
      Q.done = function(object, fulfilled, rejected, progress2) {
        return Q(object).done(fulfilled, rejected, progress2);
      };
      Promise2.prototype.done = function(fulfilled, rejected, progress2) {
        var onUnhandledError = /* @__PURE__ */ __name(function(error4) {
          Q.nextTick(function() {
            makeStackTraceLong(error4, promise2);
            if (Q.onerror) {
              Q.onerror(error4);
            } else {
              throw error4;
            }
          });
        }, "onUnhandledError");
        var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
        if (typeof process === "object" && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        promise2.then(void 0, onUnhandledError);
      };
      Q.timeout = function(object, ms2, error4) {
        return Q(object).timeout(ms2, error4);
      };
      Promise2.prototype.timeout = function(ms2, error4) {
        var deferred = defer();
        var timeoutId = setTimeout(function() {
          if (!error4 || "string" === typeof error4) {
            error4 = new Error(error4 || "Timed out after " + ms2 + " ms");
            error4.code = "ETIMEDOUT";
          }
          deferred.reject(error4);
        }, ms2);
        this.then(function(value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function(exception) {
          clearTimeout(timeoutId);
          deferred.reject(exception);
        }, deferred.notify);
        return deferred.promise;
      };
      Q.delay = function(object, timeout) {
        if (timeout === void 0) {
          timeout = object;
          object = void 0;
        }
        return Q(object).delay(timeout);
      };
      Promise2.prototype.delay = function(timeout) {
        return this.then(function(value) {
          var deferred = defer();
          setTimeout(function() {
            deferred.resolve(value);
          }, timeout);
          return deferred.promise;
        });
      };
      Q.nfapply = function(callback2, args) {
        return Q(callback2).nfapply(args);
      };
      Promise2.prototype.nfapply = function(args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfcall = function(callback2) {
        var args = array_slice(arguments, 1);
        return Q(callback2).nfapply(args);
      };
      Promise2.prototype.nfcall = function() {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfbind = Q.denodeify = function(callback2) {
        if (callback2 === void 0) {
          throw new Error("Q can't wrap an undefined function");
        }
        var baseArgs = array_slice(arguments, 1);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          Q(callback2).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
      };
      Q.nbind = function(callback2, thisp) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          function bound() {
            return callback2.apply(thisp, arguments);
          }
          __name(bound, "bound");
          Q(bound).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nbind = function() {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
      };
      Q.nmapply = // XXX As proposed by "Redsandro"
      Q.npost = function(object, name, args) {
        return Q(object).npost(name, args);
      };
      Promise2.prototype.nmapply = // XXX As proposed by "Redsandro"
      Promise2.prototype.npost = function(name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nsend = // XXX Based on Mark Miller's proposed "send"
      Q.nmcall = // XXX Based on "Redsandro's" proposal
      Q.ninvoke = function(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Promise2.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
      Promise2.prototype.nmcall = // XXX Based on "Redsandro's" proposal
      Promise2.prototype.ninvoke = function(name) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nodeify = nodeify;
      function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
      }
      __name(nodeify, "nodeify");
      Promise2.prototype.nodeify = function(nodeback) {
        if (nodeback) {
          this.then(function(value) {
            Q.nextTick(function() {
              nodeback(null, value);
            });
          }, function(error4) {
            Q.nextTick(function() {
              nodeback(error4);
            });
          });
        } else {
          return this;
        }
      };
      Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
      };
      var qEndingLine = captureLine();
      return Q;
    });
  }
});

// node-built-in-modules:stream
import libDefault2 from "stream";
var require_stream = __commonJS({
  "node-built-in-modules:stream"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = libDefault2;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/https/index.mjs
var Server, Agent, globalAgent, get, createServer, request, https_default;
var init_https = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/https/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_proxy();
    Server = notImplementedClass("https.Server");
    Agent = proxy_default.__createMock__("https.Agent");
    globalAgent = new Agent();
    get = notImplemented("https.get");
    createServer = notImplemented("https.createServer");
    request = notImplemented("https.request");
    https_default = {
      Server,
      Agent,
      globalAgent,
      get,
      createServer,
      request
    };
  }
});

// node-built-in-modules:https
var require_https = __commonJS({
  "node-built-in-modules:https"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_https();
    module.exports = https_default;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/consts.mjs
var consts_exports = {};
__export(consts_exports, {
  METHODS: () => METHODS2,
  STATUS_CODES: () => STATUS_CODES,
  maxHeaderSize: () => maxHeaderSize
});
var METHODS2, STATUS_CODES, maxHeaderSize;
var init_consts = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/consts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    METHODS2 = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PRI",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      103: "Early Hints",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      208: "Already Reported",
      226: "IM Used",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Payload Too Large",
      414: "URI Too Long",
      415: "Unsupported Media Type",
      416: "Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a Teapot",
      421: "Misdirected Request",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Too Early",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      451: "Unavailable For Legal Reasons",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      508: "Loop Detected",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    maxHeaderSize = 16384;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/async_hooks/$cloudflare.mjs
var workerdAsyncHooks, AsyncLocalStorage, AsyncResource;
var init_cloudflare5 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/async_hooks/$cloudflare.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    workerdAsyncHooks = process.getBuiltinModule("node:async_hooks");
    ({ AsyncLocalStorage, AsyncResource } = workerdAsyncHooks);
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/events/internal/events.mjs
function isEventTarget(emitter) {
  return typeof emitter?.addEventListener === "function";
}
function checkListener(listener) {
}
function addCatch(that, promise, type2, args) {
  if (!that[kCapture]) {
    return;
  }
  try {
    const then = promise.then;
    if (typeof then === "function") {
      then.call(promise, void 0, function(err) {
        process.nextTick(emitUnhandledRejectionOrErr, that, err, type2, args);
      });
    }
  } catch (error_) {
    that.emit("error", error_);
  }
}
function emitUnhandledRejectionOrErr(ee, err, type2, args) {
  if (typeof ee[kRejection] === "function") {
    ee[kRejection](err, type2, ...args);
  } else {
    const prev = ee[kCapture];
    try {
      ee[kCapture] = false;
      ee.emit("error", err);
    } finally {
      ee[kCapture] = prev;
    }
  }
}
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return defaultMaxListeners;
  return that._maxListeners;
}
function enhanceStackTrace(err, own) {
  let ctorInfo = "";
  try {
    const { name } = this.constructor;
    if (name !== "EventEmitter")
      ctorInfo = ` on ${name} instance`;
  } catch {
  }
  const sep = `
Emitted 'error' event${ctorInfo} at:
`;
  const ownStack = (own.stack || "").split("\n").slice(1);
  return err.stack + sep + ownStack.join("\n");
}
function _addListener(target, type2, listener, prepend) {
  let m5;
  let events;
  let existing;
  checkListener(listener);
  events = target._events;
  if (events === void 0) {
    events = target._events = { __proto__: null };
    target._eventsCount = 0;
  } else {
    if (events.newListener !== void 0) {
      target.emit("newListener", type2, listener.listener ?? listener);
      events = target._events;
    }
    existing = events[type2];
  }
  if (existing === void 0) {
    events[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m5 = _getMaxListeners(target);
    if (m5 > 0 && existing.length > m5 && !existing.warned) {
      existing.warned = true;
      const w3 = new genericNodeError(
        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type2)} listeners added to ${inspect(target, { depth: -1 })}. MaxListeners is ${m5}. Use emitter.setMaxListeners() to increase limit`,
        {
          // @ts-expect-error
          name: "MaxListenersExceededWarning",
          emitter: target,
          type: type2,
          count: existing.length
        }
      );
      process.emitWarning(w3);
    }
  }
  return target;
}
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  const state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
  const wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
function _listeners(target, type2, unwrap3) {
  const events = target._events;
  if (events === void 0)
    return [];
  const evlistener = events[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
function arrayClone(arr) {
  switch (arr.length) {
    case 2:
      return [arr[0], arr[1]];
    case 3:
      return [arr[0], arr[1], arr[2]];
    case 4:
      return [arr[0], arr[1], arr[2], arr[3]];
    case 5:
      return [arr[0], arr[1], arr[2], arr[3], arr[4]];
    case 6:
      return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
  }
  return Array.prototype.slice(arr);
}
function unwrapListeners(arr) {
  const ret = arrayClone(arr);
  for (let i3 = 0; i3 < ret.length; ++i3) {
    const orig = ret[i3].listener;
    if (typeof orig === "function")
      ret[i3] = orig;
  }
  return ret;
}
function createIterResult(value, done) {
  return { value, done };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function") {
    emitter.removeListener(name, listener);
  } else if (typeof emitter.removeEventListener === "function") {
    emitter.removeEventListener(
      name,
      listener,
      flags
    );
  } else {
    throw new ERR_INVALID_ARG_TYPE2("emitter", "EventEmitter", emitter);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags?.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, listener, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE2("emitter", "EventEmitter", emitter);
  }
}
function listenersController() {
  const listeners2 = [];
  return {
    addEventListener(emitter, event, handler, flags) {
      eventTargetAgnosticAddListener(emitter, event, handler, flags);
      Array.prototype.push(listeners2, [emitter, event, handler, flags]);
    },
    removeAll() {
      while (listeners2.length > 0) {
        Reflect.apply(
          eventTargetAgnosticRemoveListener,
          void 0,
          listeners2.pop()
        );
      }
    }
  };
}
function spliceOne2(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
var defaultMaxListeners, AsyncIteratorPrototype, inspect, ERR_INVALID_THIS, ERR_UNHANDLED_ERROR, ERR_INVALID_ARG_TYPE2, AbortError, genericNodeError, kRejection, kCapture, kErrorMonitor, kShapeMode, kMaxEventTargetListeners, kEnhanceStackBeforeInspector, kWatermarkData, kEventEmitter, kAsyncResource, kFirstEventParam, kResistStopPropagation, kMaxEventTargetListenersWarned, __EventEmitter, _EventEmitter, EventEmitterAsyncResource, EventEmitterReferencingAsyncResource, on2, once2, addAbortListener, getEventListeners, getMaxListeners2, kSize, kMask, FixedCircularBuffer, FixedQueue;
var init_events = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/events/internal/events.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_cloudflare5();
    defaultMaxListeners = 10;
    AsyncIteratorPrototype = Object.getPrototypeOf(
      Object.getPrototypeOf(async function* () {
      }).prototype
    );
    inspect = /* @__PURE__ */ __name((value, _opts) => value, "inspect");
    ERR_INVALID_THIS = Error;
    ERR_UNHANDLED_ERROR = Error;
    ERR_INVALID_ARG_TYPE2 = Error;
    AbortError = Error;
    genericNodeError = Error;
    kRejection = Symbol.for("nodejs.rejection");
    kCapture = Symbol.for("kCapture");
    kErrorMonitor = Symbol.for("events.errorMonitor");
    kShapeMode = Symbol.for("shapeMode");
    kMaxEventTargetListeners = Symbol.for("events.maxEventTargetListeners");
    kEnhanceStackBeforeInspector = Symbol.for("kEnhanceStackBeforeInspector");
    kWatermarkData = Symbol.for("nodejs.watermarkData");
    kEventEmitter = Symbol.for("kEventEmitter");
    kAsyncResource = Symbol.for("kAsyncResource");
    kFirstEventParam = Symbol.for("kFirstEventParam");
    kResistStopPropagation = Symbol.for("kResistStopPropagation");
    kMaxEventTargetListenersWarned = Symbol.for(
      "events.maxEventTargetListenersWarned"
    );
    __EventEmitter = class {
      // Internal state
      _events = void 0;
      _eventsCount = 0;
      _maxListeners = defaultMaxListeners;
      [kCapture] = false;
      [kShapeMode] = false;
      // backwards compatibilit
      static get on() {
        return on2;
      }
      static get once() {
        return once2;
      }
      static get getEventListeners() {
        return getEventListeners;
      }
      static get getMaxListeners() {
        return getMaxListeners2;
      }
      static get addAbortListener() {
        return addAbortListener;
      }
      static get EventEmitterAsyncResource() {
        return EventEmitterAsyncResource;
      }
      static get EventEmitter() {
        return __EventEmitter;
      }
      static setMaxListeners(n3 = defaultMaxListeners, ...eventTargets) {
        if (eventTargets.length === 0) {
          defaultMaxListeners = n3;
        } else {
          for (const target of eventTargets) {
            if (isEventTarget(target)) {
              target[kMaxEventTargetListeners] = n3;
              target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
              target.setMaxListeners(n3);
            } else {
              throw new ERR_INVALID_ARG_TYPE2(
                "eventTargets",
                ["EventEmitter", "EventTarget"],
                // @ts-expect-error
                target
              );
            }
          }
        }
      }
      static listenerCount(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        }
        __EventEmitter.prototype.listenerCount.call(emitter, type2);
      }
      static init() {
        throw new Error("EventEmitter.init() is not implemented.");
      }
      static get captureRejections() {
        return this[kCapture];
      }
      static set captureRejections(value) {
        this[kCapture] = value;
      }
      static get defaultMaxListeners() {
        return defaultMaxListeners;
      }
      static set defaultMaxListeners(arg) {
        defaultMaxListeners = arg;
      }
      // Constructor
      constructor(opts) {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = { __proto__: null };
          this._eventsCount = 0;
          this[kShapeMode] = false;
        } else {
          this[kShapeMode] = true;
        }
        this._maxListeners = this._maxListeners || void 0;
        if (opts?.captureRejections) {
          this[kCapture] = Boolean(opts.captureRejections);
        } else {
          this[kCapture] = __EventEmitter.prototype[kCapture];
        }
      }
      /**
       * Increases the max listeners of the event emitter.
       * @param {number} n
       * @returns {EventEmitter}
       */
      setMaxListeners(n3) {
        this._maxListeners = n3;
        return this;
      }
      /**
       * Returns the current max listener value for the event emitter.
       * @returns {number}
       */
      getMaxListeners() {
        return _getMaxListeners(this);
      }
      /**
       * Synchronously calls each of the listeners registered
       * for the event.
       * @param {...any} [args]
       * @returns {boolean}
       */
      emit(type2, ...args) {
        let doError = type2 === "error";
        const events = this._events;
        if (events !== void 0) {
          if (doError && events[kErrorMonitor] !== void 0)
            this.emit(kErrorMonitor, ...args);
          doError = doError && events.error === void 0;
        } else if (!doError)
          return false;
        if (doError) {
          let er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            try {
              const capture = {};
              Error.captureStackTrace?.(capture, __EventEmitter.prototype.emit);
              Object.defineProperty(er, kEnhanceStackBeforeInspector, {
                // @ts-expect-error
                __proto__: null,
                value: Function.prototype.bind(
                  enhanceStackTrace,
                  this,
                  er,
                  capture
                ),
                configurable: true
              });
            } catch {
            }
            throw er;
          }
          let stringifiedEr;
          try {
            stringifiedEr = inspect(er);
          } catch {
            stringifiedEr = er;
          }
          const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
          err.context = er;
          throw err;
        }
        const handler = events[type2];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          const result = handler.apply(this, args);
          if (result !== void 0 && result !== null) {
            addCatch(this, result, type2, args);
          }
        } else {
          const len = handler.length;
          const listeners2 = arrayClone(handler);
          for (let i3 = 0; i3 < len; ++i3) {
            const result = listeners2[i3].apply(this, args);
            if (result !== void 0 && result !== null) {
              addCatch(this, result, type2, args);
            }
          }
        }
        return true;
      }
      /**
       * Adds a listener to the event emitter.
       * @returns {EventEmitter}
       */
      addListener(type2, listener) {
        _addListener(this, type2, listener, false);
        return this;
      }
      on(type2, listener) {
        return this.addListener(type2, listener);
      }
      /**
       * Adds the `listener` function to the beginning of
       * the listeners array.
       */
      prependListener(type2, listener) {
        _addListener(this, type2, listener, true);
        return this;
      }
      /**
       * Adds a one-time `listener` function to the event emitter.
       */
      once(type2, listener) {
        checkListener(listener);
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      }
      /**
       * Adds a one-time `listener` function to the beginning of
       * the listeners array.
       */
      prependOnceListener(type2, listener) {
        checkListener(listener);
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      }
      /**
       * Removes the specified `listener` from the listeners array.
       * @param {string | symbol} type
       * @param {Function} listener
       * @returns {EventEmitter}
       */
      removeListener(type2, listener) {
        checkListener(listener);
        const events = this._events;
        if (events === void 0)
          return this;
        const list = events[type2];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          this._eventsCount -= 1;
          if (this[kShapeMode]) {
            events[type2] = void 0;
          } else if (this._eventsCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          let position = -1;
          for (let i3 = list.length - 1; i3 >= 0; i3--) {
            if (list[i3] === listener || list[i3].listener === listener) {
              position = i3;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne2(list, position);
          }
          if (list.length === 1)
            events[type2] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type2, listener);
        }
        return this;
      }
      off(type2, listener) {
        return this.removeListener(type2, listener);
      }
      /**
       * Removes all listeners from the event emitter. (Only
       * removes listeners for a specific event name if specified
       * as `type`).
       */
      removeAllListeners(type2) {
        const events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = { __proto__: null };
            this._eventsCount = 0;
          } else if (events[type2] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = { __proto__: null };
            else
              delete events[type2];
          }
          this[kShapeMode] = false;
          return this;
        }
        if (arguments.length === 0) {
          for (const key of Reflect.ownKeys(events)) {
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = { __proto__: null };
          this._eventsCount = 0;
          this[kShapeMode] = false;
          return this;
        }
        const listeners2 = events[type2];
        if (typeof listeners2 === "function") {
          this.removeListener(type2, listeners2);
        } else if (listeners2 !== void 0) {
          for (let i3 = listeners2.length - 1; i3 >= 0; i3--) {
            this.removeListener(type2, listeners2[i3]);
          }
        }
        return this;
      }
      /**
       * Returns a copy of the array of listeners for the event name
       * specified as `type`.
       * @param {string | symbol} type
       * @returns {Function[]}
       */
      listeners(type2) {
        return _listeners(this, type2, true);
      }
      /**
       * Returns a copy of the array of listeners and wrappers for
       * the event name specified as `type`.
       * @returns {Function[]}
       */
      rawListeners(type2) {
        return _listeners(this, type2, false);
      }
      /**
       * Returns an array listing the events for which
       * the emitter has registered listeners.
       * @returns {any[]}
       */
      eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      }
      /**
       * Returns the number of listeners listening to event name
       */
      listenerCount(eventName, listener) {
        const events = this._events;
        if (events !== void 0) {
          const evlistener = events[eventName];
          if (typeof evlistener === "function") {
            if (listener != null) {
              return listener === evlistener || listener === evlistener.listener ? 1 : 0;
            }
            return 1;
          } else if (evlistener !== void 0) {
            if (listener != null) {
              let matching = 0;
              for (let i3 = 0, l3 = evlistener.length; i3 < l3; i3++) {
                if (evlistener[i3] === listener || evlistener[i3].listener === listener) {
                  matching++;
                }
              }
              return matching;
            }
            return evlistener.length;
          }
        }
        return 0;
      }
    };
    _EventEmitter = __EventEmitter;
    __name(_EventEmitter, "_EventEmitter");
    // Symbols
    __publicField(_EventEmitter, "captureRejectionSymbol", kRejection);
    __publicField(_EventEmitter, "errorMonitor", kErrorMonitor);
    __publicField(_EventEmitter, "kMaxEventTargetListeners", kMaxEventTargetListeners);
    __publicField(_EventEmitter, "kMaxEventTargetListenersWarned", kMaxEventTargetListenersWarned);
    // Static utils
    __publicField(_EventEmitter, "usingDomains", false);
    EventEmitterAsyncResource = class extends _EventEmitter {
      /**
       * @param {{
       *   name?: string,
       *   triggerAsyncId?: number,
       *   requireManualDestroy?: boolean,
       * }} [options]
       */
      constructor(options) {
        let name;
        if (typeof options === "string") {
          name = options;
          options = void 0;
        } else {
          name = options?.name || new.target.name;
        }
        super(options);
        this[kAsyncResource] = new EventEmitterReferencingAsyncResource(
          this,
          name,
          options
        );
      }
      /**
       * @param {symbol,string} event
       * @param  {...any} args
       * @returns {boolean}
       */
      emit(event, ...args) {
        if (this[kAsyncResource] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterAsyncResource");
        const { asyncResource } = this;
        Array.prototype.unshift(args, super.emit, this, event);
        return Reflect.apply(
          asyncResource.runInAsyncScope,
          asyncResource,
          args
        );
      }
      /**
       * @returns {void}
       */
      emitDestroy() {
        if (this[kAsyncResource] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterAsyncResource");
        this.asyncResource.emitDestroy();
      }
      /**
       * @type {number}
       */
      get asyncId() {
        if (this[kAsyncResource] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterAsyncResource");
        return this.asyncResource.asyncId();
      }
      /**
       * @type {number}
       */
      get triggerAsyncId() {
        if (this[kAsyncResource] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterAsyncResource");
        return this.asyncResource.triggerAsyncId();
      }
      /**
       * @type {EventEmitterReferencingAsyncResource}
       */
      get asyncResource() {
        if (this[kAsyncResource] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterAsyncResource");
        return this[kAsyncResource];
      }
    };
    __name(EventEmitterAsyncResource, "EventEmitterAsyncResource");
    EventEmitterReferencingAsyncResource = class extends AsyncResource {
      /**
       * @param {EventEmitter} ee
       * @param {string} [type]
       * @param {{
       *   triggerAsyncId?: number,
       *   requireManualDestroy?: boolean,
       * }} [options]
       */
      constructor(ee, type2, options) {
        super(type2, options);
        this[kEventEmitter] = ee;
      }
      /**
       * @type {EventEmitter}
       */
      get eventEmitter() {
        if (this[kEventEmitter] === void 0)
          throw new ERR_INVALID_THIS("EventEmitterReferencingAsyncResource");
        return this[kEventEmitter];
      }
    };
    __name(EventEmitterReferencingAsyncResource, "EventEmitterReferencingAsyncResource");
    on2 = /* @__PURE__ */ __name(function on22(emitter, event, options = {}) {
      const signal2 = options.signal;
      if (signal2?.aborted) {
        throw new AbortError(void 0, { cause: signal2?.reason });
      }
      const highWatermark = options.highWaterMark ?? options.highWatermark ?? Number.MAX_SAFE_INTEGER;
      const lowWatermark = options.lowWaterMark ?? options.lowWatermark ?? 1;
      const unconsumedEvents = new FixedQueue();
      const unconsumedPromises = new FixedQueue();
      let paused = false;
      let error4 = null;
      let finished2 = false;
      let size = 0;
      const iterator = Object.setPrototypeOf(
        {
          next() {
            if (size) {
              const value = unconsumedEvents.shift();
              size--;
              if (paused && size < lowWatermark) {
                emitter.resume?.();
                paused = false;
              }
              return Promise.resolve(createIterResult(value, false));
            }
            if (error4) {
              const p5 = Promise.reject(error4);
              error4 = null;
              return p5;
            }
            if (finished2)
              return closeHandler();
            return new Promise(function(resolve, reject) {
              unconsumedPromises.push({ resolve, reject });
            });
          },
          return() {
            return closeHandler();
          },
          throw(err) {
            if (!err || !(err instanceof Error)) {
              throw new ERR_INVALID_ARG_TYPE2(
                "EventEmitter.AsyncIterator",
                "Error",
                // @ts-expect-error
                err
              );
            }
            errorHandler2(err);
          },
          [Symbol.asyncIterator]() {
            return this;
          },
          [kWatermarkData]: {
            /**
             * The current queue size
             */
            get size() {
              return size;
            },
            /**
             * The low watermark. The emitter is resumed every time size is lower than it
             */
            get low() {
              return lowWatermark;
            },
            /**
             * The high watermark. The emitter is paused every time size is higher than it
             */
            get high() {
              return highWatermark;
            },
            /**
             * It checks whether the emitter is paused by the watermark controller or not
             */
            get isPaused() {
              return paused;
            }
          }
        },
        AsyncIteratorPrototype
      );
      const { addEventListener: addEventListener2, removeAll } = listenersController();
      addEventListener2(
        emitter,
        event,
        options[kFirstEventParam] ? eventHandler : function(...args) {
          return eventHandler(args);
        }
      );
      if (event !== "error" && typeof emitter.on === "function") {
        addEventListener2(emitter, "error", errorHandler2);
      }
      const closeEvents = options?.close;
      if (closeEvents?.length) {
        for (const closeEvent of closeEvents) {
          addEventListener2(emitter, closeEvent, closeHandler);
        }
      }
      const abortListenerDisposable = signal2 ? addAbortListener(signal2, abortListener) : null;
      return iterator;
      function abortListener() {
        errorHandler2(new AbortError(void 0, { cause: signal2?.reason }));
      }
      __name(abortListener, "abortListener");
      function eventHandler(value) {
        if (unconsumedPromises.isEmpty()) {
          size++;
          if (!paused && size > highWatermark) {
            paused = true;
            emitter.pause?.();
          }
          unconsumedEvents.push(value);
        } else
          unconsumedPromises.shift().resolve(createIterResult(value, false));
      }
      __name(eventHandler, "eventHandler");
      function errorHandler2(err) {
        if (unconsumedPromises.isEmpty())
          error4 = err;
        else
          unconsumedPromises.shift().reject(err);
        closeHandler();
      }
      __name(errorHandler2, "errorHandler");
      function closeHandler() {
        abortListenerDisposable?.[Symbol.dispose]();
        removeAll();
        finished2 = true;
        const doneResult = createIterResult(void 0, true);
        while (!unconsumedPromises.isEmpty()) {
          unconsumedPromises.shift().resolve(doneResult);
        }
        return Promise.resolve(doneResult);
      }
      __name(closeHandler, "closeHandler");
    }, "on2");
    once2 = /* @__PURE__ */ __name(async function once22(emitter, name, options = {}) {
      const signal2 = options?.signal;
      if (signal2?.aborted) {
        throw new AbortError(void 0, { cause: signal2?.reason });
      }
      return new Promise((resolve, reject) => {
        const errorListener = /* @__PURE__ */ __name((err) => {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener(name, resolver);
          }
          if (signal2 != null) {
            eventTargetAgnosticRemoveListener(signal2, "abort", abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = /* @__PURE__ */ __name((...args) => {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          if (signal2 != null) {
            eventTargetAgnosticRemoveListener(signal2, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        const opts = {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, opts);
        if (name !== "error" && typeof emitter.once === "function") {
          emitter.once("error", errorListener);
        }
        function abortListener() {
          eventTargetAgnosticRemoveListener(emitter, name, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(void 0, { cause: signal2?.reason }));
        }
        __name(abortListener, "abortListener");
        if (signal2 != null) {
          eventTargetAgnosticAddListener(signal2, "abort", abortListener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
        }
      });
    }, "once2");
    addAbortListener = /* @__PURE__ */ __name(function addAbortListener2(signal2, listener) {
      if (signal2 === void 0) {
        throw new ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal2);
      }
      let removeEventListener;
      if (signal2.aborted) {
        queueMicrotask(() => listener());
      } else {
        signal2.addEventListener("abort", listener, {
          // @ts-expect-error
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        });
        removeEventListener = /* @__PURE__ */ __name(() => {
          signal2.removeEventListener("abort", listener);
        }, "removeEventListener");
      }
      return {
        __proto__: null,
        [Symbol.dispose]() {
          removeEventListener?.();
        }
      };
    }, "addAbortListener2");
    getEventListeners = /* @__PURE__ */ __name(function getEventListeners2(emitterOrTarget, type2) {
      if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type2);
      }
      if (isEventTarget(emitterOrTarget)) {
        const root = emitterOrTarget[kEvents].get(type2);
        const listeners2 = [];
        let handler = root?.next;
        while (handler?.listener !== void 0) {
          const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
          listeners2.push(listener);
          handler = handler.next;
        }
        return listeners2;
      }
      throw new ERR_INVALID_ARG_TYPE2(
        "emitter",
        ["EventEmitter", "EventTarget"],
        // @ts-expect-error
        emitterOrTarget
      );
    }, "getEventListeners2");
    getMaxListeners2 = /* @__PURE__ */ __name(function getMaxListeners22(emitterOrTarget) {
      if (typeof emitterOrTarget?.getMaxListeners === "function") {
        return _getMaxListeners(emitterOrTarget);
      } else if (emitterOrTarget?.[kMaxEventTargetListeners]) {
        return emitterOrTarget[kMaxEventTargetListeners];
      }
      throw new ERR_INVALID_ARG_TYPE2(
        "emitter",
        ["EventEmitter", "EventTarget"],
        // @ts-expect-error
        emitterOrTarget
      );
    }, "getMaxListeners2");
    kSize = 2048;
    kMask = kSize - 1;
    FixedCircularBuffer = class {
      bottom;
      top;
      list;
      next;
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    __name(FixedCircularBuffer, "FixedCircularBuffer");
    FixedQueue = class {
      head;
      tail;
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
          tail.next = null;
        }
        return next;
      }
    };
    __name(FixedQueue, "FixedQueue");
    __name(isEventTarget, "isEventTarget");
    __name(checkListener, "checkListener");
    __name(addCatch, "addCatch");
    __name(emitUnhandledRejectionOrErr, "emitUnhandledRejectionOrErr");
    __name(_getMaxListeners, "_getMaxListeners");
    __name(enhanceStackTrace, "enhanceStackTrace");
    __name(_addListener, "_addListener");
    __name(onceWrapper, "onceWrapper");
    __name(_onceWrap, "_onceWrap");
    __name(_listeners, "_listeners");
    __name(arrayClone, "arrayClone");
    __name(unwrapListeners, "unwrapListeners");
    __name(createIterResult, "createIterResult");
    __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
    __name(listenersController, "listenersController");
    __name(spliceOne2, "spliceOne");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/events/index.mjs
var usingDomains, captureRejectionSymbol, errorMonitor, defaultMaxListeners2, setMaxListeners2, listenerCount2, init;
var init_events2 = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/events/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_events();
    init_events();
    usingDomains = _EventEmitter.usingDomains;
    captureRejectionSymbol = _EventEmitter.captureRejectionSymbol;
    errorMonitor = _EventEmitter.errorMonitor;
    defaultMaxListeners2 = _EventEmitter.defaultMaxListeners;
    setMaxListeners2 = _EventEmitter.setMaxListeners;
    listenerCount2 = _EventEmitter.listenerCount;
    init = _EventEmitter.init;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/readable.mjs
var _Readable, Readable;
var init_readable = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/readable.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_events2();
    _Readable = class extends _EventEmitter {
      __unenv__ = true;
      readableEncoding = null;
      readableEnded = true;
      readableFlowing = false;
      readableHighWaterMark = 0;
      readableLength = 0;
      readableObjectMode = false;
      readableAborted = false;
      readableDidRead = false;
      closed = false;
      errored = null;
      readable = false;
      destroyed = false;
      static from(_iterable, options) {
        return new _Readable(options);
      }
      constructor(_opts) {
        super();
      }
      _read(_size) {
      }
      read(_size) {
      }
      setEncoding(_encoding) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      isPaused() {
        return true;
      }
      unpipe(_destination) {
        return this;
      }
      unshift(_chunk, _encoding) {
      }
      wrap(_oldStream) {
        return this;
      }
      push(_chunk, _encoding) {
        return false;
      }
      _destroy(_error, _callback) {
        this.removeAllListeners();
      }
      destroy(error4) {
        this.destroyed = true;
        this._destroy(error4);
        return this;
      }
      pipe(_destenition, _options) {
        return {};
      }
      compose(stream2, options) {
        throw new Error("[unenv] Method not implemented.");
      }
      [Symbol.asyncDispose]() {
        this.destroy();
        return Promise.resolve();
      }
      // eslint-disable-next-line require-yield
      async *[Symbol.asyncIterator]() {
        throw createNotImplementedError("Readable.asyncIterator");
      }
      iterator(options) {
        throw createNotImplementedError("Readable.iterator");
      }
      map(fn3, options) {
        throw createNotImplementedError("Readable.map");
      }
      filter(fn3, options) {
        throw createNotImplementedError("Readable.filter");
      }
      forEach(fn3, options) {
        throw createNotImplementedError("Readable.forEach");
      }
      reduce(fn3, initialValue, options) {
        throw createNotImplementedError("Readable.reduce");
      }
      find(fn3, options) {
        throw createNotImplementedError("Readable.find");
      }
      findIndex(fn3, options) {
        throw createNotImplementedError("Readable.findIndex");
      }
      some(fn3, options) {
        throw createNotImplementedError("Readable.some");
      }
      toArray(options) {
        throw createNotImplementedError("Readable.toArray");
      }
      every(fn3, options) {
        throw createNotImplementedError("Readable.every");
      }
      flatMap(fn3, options) {
        throw createNotImplementedError("Readable.flatMap");
      }
      drop(limit, options) {
        throw createNotImplementedError("Readable.drop");
      }
      take(limit, options) {
        throw createNotImplementedError("Readable.take");
      }
      asIndexedPairs(options) {
        throw createNotImplementedError("Readable.asIndexedPairs");
      }
    };
    __name(_Readable, "_Readable");
    Readable = globalThis.Readable || _Readable;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/writable.mjs
var _Writable, Writable2;
var init_writable = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/writable.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_events2();
    _Writable = class extends _EventEmitter {
      __unenv__ = true;
      writable = true;
      writableEnded = false;
      writableFinished = false;
      writableHighWaterMark = 0;
      writableLength = 0;
      writableObjectMode = false;
      writableCorked = 0;
      closed = false;
      errored = null;
      writableNeedDrain = false;
      destroyed = false;
      _data;
      _encoding = "utf-8";
      constructor(_opts) {
        super();
      }
      pipe(_destenition, _options) {
        return {};
      }
      _write(chunk, encoding, callback2) {
        if (this.writableEnded) {
          if (callback2) {
            callback2();
          }
          return;
        }
        if (this._data === void 0) {
          this._data = chunk;
        } else {
          const a4 = typeof this._data === "string" ? Buffer.from(this._data, this._encoding || encoding || "utf8") : this._data;
          const b3 = typeof chunk === "string" ? Buffer.from(chunk, encoding || this._encoding || "utf8") : chunk;
          this._data = Buffer.concat([a4, b3]);
        }
        this._encoding = encoding;
        if (callback2) {
          callback2();
        }
      }
      _writev(_chunks, _callback) {
      }
      _destroy(_error, _callback) {
      }
      _final(_callback) {
      }
      write(chunk, arg2, arg3) {
        const encoding = typeof arg2 === "string" ? this._encoding : "utf-8";
        const cb = typeof arg2 === "function" ? arg2 : typeof arg3 === "function" ? arg3 : void 0;
        this._write(chunk, encoding, cb);
        return true;
      }
      setDefaultEncoding(_encoding) {
        return this;
      }
      end(arg1, arg2, arg3) {
        const callback2 = typeof arg1 === "function" ? arg1 : typeof arg2 === "function" ? arg2 : typeof arg3 === "function" ? arg3 : void 0;
        if (this.writableEnded) {
          if (callback2) {
            callback2();
          }
          return this;
        }
        const data = arg1 === callback2 ? void 0 : arg1;
        if (data) {
          const encoding = arg2 === callback2 ? void 0 : arg2;
          this.write(data, encoding, callback2);
        }
        this.writableEnded = true;
        this.writableFinished = true;
        this.emit("close");
        this.emit("finish");
        return this;
      }
      cork() {
      }
      uncork() {
      }
      destroy(_error) {
        this.destroyed = true;
        delete this._data;
        this.removeAllListeners();
        return this;
      }
      compose(stream2, options) {
        throw new Error("[h3] Method not implemented.");
      }
    };
    __name(_Writable, "_Writable");
    Writable2 = globalThis.Writable || _Writable;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/duplex.mjs
function getDuplex() {
  Object.assign(__Duplex.prototype, Readable.prototype);
  Object.assign(__Duplex.prototype, Writable2.prototype);
  return __Duplex;
}
var __Duplex, _Duplex, Duplex;
var init_duplex = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/internal/duplex.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_readable();
    init_writable();
    __Duplex = /* @__PURE__ */ __name(class {
      allowHalfOpen = true;
      _destroy;
      constructor(readable = new Readable(), writable = new Writable2()) {
        Object.assign(this, readable);
        Object.assign(this, writable);
        this._destroy = mergeFns(readable._destroy, writable._destroy);
      }
    }, "__Duplex");
    __name(getDuplex, "getDuplex");
    _Duplex = /* @__PURE__ */ getDuplex();
    Duplex = globalThis.Duplex || _Duplex;
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/net/internal/socket.mjs
var Socket;
var init_socket = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/net/internal/socket.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_duplex();
    Socket = class extends Duplex {
      __unenv__ = true;
      bufferSize = 0;
      bytesRead = 0;
      bytesWritten = 0;
      connecting = false;
      destroyed = false;
      pending = false;
      localAddress = "";
      localPort = 0;
      remoteAddress = "";
      remoteFamily = "";
      remotePort = 0;
      autoSelectFamilyAttemptedAddresses = [];
      readyState = "readOnly";
      constructor(_options) {
        super();
      }
      write(_buffer, _arg1, _arg2) {
        return false;
      }
      connect(_arg1, _arg2, _arg3) {
        return this;
      }
      end(_arg1, _arg2, _arg3) {
        return this;
      }
      setEncoding(_encoding) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      setTimeout(_timeout, _callback) {
        return this;
      }
      setNoDelay(_noDelay) {
        return this;
      }
      setKeepAlive(_enable, _initialDelay) {
        return this;
      }
      address() {
        return {};
      }
      unref() {
        return this;
      }
      ref() {
        return this;
      }
      destroySoon() {
        this.destroy();
      }
      resetAndDestroy() {
        const err = new Error("ERR_SOCKET_CLOSED");
        err.code = "ERR_SOCKET_CLOSED";
        this.destroy(err);
        return this;
      }
    };
    __name(Socket, "Socket");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/net/index.mjs
var createServer2, Server2, BlockList, connect, createConnection, getDefaultAutoSelectFamily, setDefaultAutoSelectFamily, getDefaultAutoSelectFamilyAttemptTimeout, setDefaultAutoSelectFamilyAttemptTimeout, _createServerHandle, _normalizeArgs, _setSimultaneousAccepts;
var init_net = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/net/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_socket();
    createServer2 = notImplemented(
      "net.createServer"
    );
    Server2 = notImplementedClass("net.Server");
    BlockList = notImplementedClass(
      "net.BlockList"
    );
    connect = notImplemented("net.connect");
    createConnection = notImplemented(
      "net.createConnection"
    );
    getDefaultAutoSelectFamily = notImplemented(
      "net.getDefaultAutoSelectFamily"
    );
    setDefaultAutoSelectFamily = notImplemented(
      "net.setDefaultAutoSelectFamily"
    );
    getDefaultAutoSelectFamilyAttemptTimeout = notImplemented(
      "net.getDefaultAutoSelectFamilyAttemptTimeout"
    );
    setDefaultAutoSelectFamilyAttemptTimeout = notImplemented(
      "net.setDefaultAutoSelectFamilyAttemptTimeout"
    );
    _createServerHandle = notImplemented("net._createServerHandle");
    _normalizeArgs = notImplemented("net._normalizeArgs");
    _setSimultaneousAccepts = notImplemented(
      "net._setSimultaneousAccepts"
    );
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/request.mjs
function _distinct(obj) {
  const d3 = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key) {
      d3[key] = (Array.isArray(value) ? value : [value]).filter(
        Boolean
      );
    }
  }
  return d3;
}
var IncomingMessage;
var init_request = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/request.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_net();
    init_readable();
    init_utils();
    IncomingMessage = class extends Readable {
      __unenv__ = {};
      aborted = false;
      httpVersion = "1.1";
      httpVersionMajor = 1;
      httpVersionMinor = 1;
      complete = true;
      connection;
      socket;
      headers = {};
      trailers = {};
      method = "GET";
      url = "/";
      statusCode = 200;
      statusMessage = "";
      closed = false;
      errored = null;
      readable = false;
      constructor(socket) {
        super();
        this.socket = this.connection = socket || new Socket();
      }
      get rawHeaders() {
        return rawHeaders(this.headers);
      }
      get rawTrailers() {
        return [];
      }
      setTimeout(_msecs, _callback) {
        return this;
      }
      get headersDistinct() {
        return _distinct(this.headers);
      }
      get trailersDistinct() {
        return _distinct(this.trailers);
      }
    };
    __name(IncomingMessage, "IncomingMessage");
    __name(_distinct, "_distinct");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/index.mjs
var Stream, PassThrough, pipeline, finished, addAbortSignal, isDisturbed, isReadable, compose2, isErrored, destroy, _isUint8Array, _uint8ArrayToBuffer;
var init_stream = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/stream/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_proxy();
    init_utils();
    init_writable();
    Stream = proxy_default.__createMock__("Stream");
    PassThrough = proxy_default.__createMock__("PassThrough");
    pipeline = notImplemented(
      "stream.pipeline"
    );
    finished = notImplemented(
      "stream.finished"
    );
    addAbortSignal = notImplemented(
      "stream.addAbortSignal"
    );
    isDisturbed = notImplemented("stream.isDisturbed");
    isReadable = notImplemented("stream.isReadable");
    compose2 = notImplemented("stream.compose");
    isErrored = notImplemented("stream.isErrored");
    destroy = notImplemented("stream.destroy");
    _isUint8Array = notImplemented("stream._isUint8Array");
    _uint8ArrayToBuffer = notImplemented("stream._uint8ArrayToBuffer");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/response.mjs
var ServerResponse;
var init_response = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/internal/response.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_stream();
    ServerResponse = class extends Writable2 {
      __unenv__ = true;
      statusCode = 200;
      statusMessage = "";
      upgrading = false;
      chunkedEncoding = false;
      shouldKeepAlive = false;
      useChunkedEncodingByDefault = false;
      sendDate = false;
      finished = false;
      headersSent = false;
      strictContentLength = false;
      connection = null;
      socket = null;
      req;
      _headers = {};
      constructor(req) {
        super();
        this.req = req;
      }
      assignSocket(socket) {
        socket._httpMessage = this;
        this.socket = socket;
        this.connection = socket;
        this.emit("socket", socket);
        this._flush();
      }
      _flush() {
        this.flushHeaders();
      }
      detachSocket(_socket) {
      }
      writeContinue(_callback) {
      }
      writeHead(statusCode, arg1, arg2) {
        if (statusCode) {
          this.statusCode = statusCode;
        }
        if (typeof arg1 === "string") {
          this.statusMessage = arg1;
          arg1 = void 0;
        }
        const headers = arg2 || arg1;
        if (headers) {
          if (Array.isArray(headers)) {
          } else {
            for (const key in headers) {
              this.setHeader(key, headers[key]);
            }
          }
        }
        this.headersSent = true;
        return this;
      }
      writeProcessing() {
      }
      setTimeout(_msecs, _callback) {
        return this;
      }
      appendHeader(name, value) {
        name = name.toLowerCase();
        const current = this._headers[name];
        const all = [
          ...Array.isArray(current) ? current : [current],
          ...Array.isArray(value) ? value : [value]
        ].filter(Boolean);
        this._headers[name] = all.length > 1 ? all : all[0];
        return this;
      }
      setHeader(name, value) {
        this._headers[name.toLowerCase()] = value;
        return this;
      }
      getHeader(name) {
        return this._headers[name.toLowerCase()];
      }
      getHeaders() {
        return this._headers;
      }
      getHeaderNames() {
        return Object.keys(this._headers);
      }
      hasHeader(name) {
        return name.toLowerCase() in this._headers;
      }
      removeHeader(name) {
        delete this._headers[name.toLowerCase()];
      }
      addTrailers(_headers) {
      }
      flushHeaders() {
      }
      writeEarlyHints(_headers, cb) {
        if (typeof cb === "function") {
          cb();
        }
      }
    };
    __name(ServerResponse, "ServerResponse");
  }
});

// node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/index.mjs
var createServer3, request2, get2, Server3, OutgoingMessage, ClientRequest, Agent2, globalAgent2, validateHeaderName, validateHeaderValue, setMaxIdleHTTPParsers, _connectionListener, WebSocket2, CloseEvent, MessageEvent, http_default;
var init_http = __esm({
  "node_modules/.pnpm/unenv-nightly@2.0.0-20240919-125358-9a64854/node_modules/unenv-nightly/runtime/node/http/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_utils();
    init_proxy();
    init_consts();
    init_request();
    init_response();
    init_consts();
    init_request();
    init_response();
    createServer3 = notImplemented("http.createServer");
    request2 = notImplemented("http.request");
    get2 = notImplemented("http.get");
    Server3 = proxy_default.__createMock__("http.Server");
    OutgoingMessage = proxy_default.__createMock__(
      "http.OutgoingMessage"
    );
    ClientRequest = proxy_default.__createMock__("http.ClientRequest");
    Agent2 = proxy_default.__createMock__("http.Agent");
    globalAgent2 = new Agent2();
    validateHeaderName = notImplemented("http.validateHeaderName");
    validateHeaderValue = notImplemented("http.validateHeaderValue");
    setMaxIdleHTTPParsers = notImplemented("http.setMaxIdleHTTPParsers");
    _connectionListener = notImplemented("http._connectionListener");
    WebSocket2 = globalThis.WebSocket || notImplementedClass("WebSocket");
    CloseEvent = globalThis.CloseEvent || notImplementedClass("CloseEvent");
    MessageEvent = globalThis.MessageEvent || notImplementedClass("MessageEvent");
    http_default = {
      ...consts_exports,
      IncomingMessage,
      ServerResponse,
      WebSocket: WebSocket2,
      CloseEvent,
      MessageEvent,
      createServer: createServer3,
      request: request2,
      get: get2,
      Server: Server3,
      OutgoingMessage,
      ClientRequest,
      Agent: Agent2,
      globalAgent: globalAgent2,
      validateHeaderName,
      validateHeaderValue,
      setMaxIdleHTTPParsers,
      _connectionListener
    };
  }
});

// node-built-in-modules:http
var require_http = __commonJS({
  "node-built-in-modules:http"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    init_http();
    module.exports = http_default;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/cache.js
var require_cache = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/cache.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var CACHE = Symbol.for("com.cloudinary.cache");
    var CACHE_ADAPTER = Symbol.for("com.cloudinary.cacheAdapter");
    var { ensurePresenceOf, generate_transformation_string } = require_utils();
    var CacheAdapter = class {
      /**
       * Get a value from the cache
       * @param {string} publicId
       * @param {string} type
       * @param {string} resourceType
       * @param {string} transformation
       * @param {string} format
       * @return {*} the value associated with the provided arguments
       */
      get(publicId, type2, resourceType, transformation, format) {
      }
      /**
       * Set a new value in the cache
       * @param {string} publicId
       * @param {string} type
       * @param {string} resourceType
       * @param {string} transformation
       * @param {string} format
       * @param {*} value
       */
      set(publicId, type2, resourceType, transformation, format, value) {
      }
      /**
       * Delete all values in the cache
       */
      flushAll() {
      }
    };
    __name(CacheAdapter, "CacheAdapter");
    var Cache = {
      /**
       * The adapter interface. Extend this class to implement a specific adapter.
       * @type CacheAdapter
       */
      CacheAdapter,
      /**
       * Set the cache adapter
       * @param {CacheAdapter} adapter The cache adapter
       */
      setAdapter(adapter) {
        if (this.adapter) {
          console.warn("Overriding existing cache adapter");
        }
        this.adapter = adapter;
      },
      /**
       * Get the adapter the Cache is using
       * @return {CacheAdapter} the current cache adapter
       */
      getAdapter() {
        return this.adapter;
      },
      /**
       * Get an item from the cache
       * @param {string} publicId
       * @param {object} options
       * @return {*}
       */
      get(publicId, options) {
        if (!this.adapter) {
          return void 0;
        }
        ensurePresenceOf({ publicId });
        let transformation = generate_transformation_string({ ...options });
        return this.adapter.get(
          publicId,
          options.type || "upload",
          options.resource_type || "image",
          transformation,
          options.format
        );
      },
      /**
       * Set a new value in the cache
       * @param {string} publicId
       * @param {object} options
       * @param {*} value
       * @return {*}
       */
      set(publicId, options, value) {
        if (!this.adapter) {
          return void 0;
        }
        ensurePresenceOf({ publicId, value });
        let transformation = generate_transformation_string({ ...options });
        return this.adapter.set(
          publicId,
          options.type || "upload",
          options.resource_type || "image",
          transformation,
          options.format,
          value
        );
      },
      /**
       * Clear all items in the cache
       * @return {*} Returns the value from the adapter's flushAll() method
       */
      flushAll() {
        if (!this.adapter) {
          return void 0;
        }
        return this.adapter.flushAll();
      }
    };
    Object.defineProperty(Cache, "instance", {
      get() {
        return global[CACHE];
      }
    });
    Object.defineProperty(Cache, "adapter", {
      /**
       *
       * @return {CacheAdapter} The current cache adapter
       */
      get() {
        return global[CACHE_ADAPTER];
      },
      /**
       * Set the cache adapter to be used by Cache
       * @param {CacheAdapter} adapter Cache adapter
       */
      set(adapter) {
        global[CACHE_ADAPTER] = adapter;
      }
    });
    Object.freeze(Cache);
    var symbols = Object.getOwnPropertySymbols(global);
    if (symbols.indexOf(CACHE) < 0) {
      global[CACHE] = Cache;
    }
    module.exports = Cache;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/upload_stream.js
var require_upload_stream = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/upload_stream.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Transform = require_stream().Transform;
    var UploadStream = class extends Transform {
      constructor(options) {
        super();
        this.boundary = options.boundary;
      }
      _transform(data, encoding, next) {
        let buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, encoding);
        this.push(buffer);
        next();
      }
      _flush(next) {
        this.push(Buffer.from("\r\n", "ascii"));
        this.push(Buffer.from("--" + this.boundary + "--", "ascii"));
        return next();
      }
    };
    __name(UploadStream, "UploadStream");
    module.exports = UploadStream;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/uploader.js
var require_uploader = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/uploader.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var fs = require_fs();
    var { extname, basename } = require_path();
    var Q = require_q();
    var Writable3 = require_stream().Writable;
    var urlLib = require_url();
    var { upload_prefix } = require_config()();
    var isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === "http:");
    var https = isSecure ? require_https() : require_http();
    var Cache = require_cache();
    var utils = require_utils();
    var UploadStream = require_upload_stream();
    var config2 = require_config();
    var ensureOption = require_ensureOption().defaults(config2());
    var agent = config2.api_proxy ? new https.Agent(config2.api_proxy) : null;
    var {
      build_upload_params,
      extend,
      includes,
      isEmpty,
      isObject: isObject3,
      isRemoteUrl,
      merge: merge2,
      pickOnlyExistingValues
    } = utils;
    exports.unsigned_upload_stream = /* @__PURE__ */ __name(function unsigned_upload_stream(upload_preset, callback2, options = {}) {
      return exports.upload_stream(callback2, merge2(options, {
        unsigned: true,
        upload_preset
      }));
    }, "unsigned_upload_stream");
    exports.upload_stream = /* @__PURE__ */ __name(function upload_stream(callback2, options = {}) {
      return exports.upload(null, callback2, extend({
        stream: true
      }, options));
    }, "upload_stream");
    exports.unsigned_upload = /* @__PURE__ */ __name(function unsigned_upload(file, upload_preset, callback2, options = {}) {
      return exports.upload(file, callback2, merge2(options, {
        unsigned: true,
        upload_preset
      }));
    }, "unsigned_upload");
    exports.upload = /* @__PURE__ */ __name(function upload(file, callback2, options = {}) {
      return call_api("upload", callback2, options, function() {
        let params = build_upload_params(options);
        return isRemoteUrl(file) ? [params, { file }] : [params, {}, file];
      });
    }, "upload");
    exports.upload_large = /* @__PURE__ */ __name(function upload_large(path2, callback2, options = {}) {
      if (path2 != null && isRemoteUrl(path2)) {
        return exports.upload(path2, callback2, options);
      }
      if (path2 != null && !options.filename) {
        options.filename = path2.split(/(\\|\/)/g).pop().replace(/\.[^/.]+$/, "");
      }
      return exports.upload_chunked(path2, callback2, extend({
        resource_type: "raw"
      }, options));
    }, "upload_large");
    exports.upload_chunked = /* @__PURE__ */ __name(function upload_chunked(path2, callback2, options) {
      let file_reader = fs.createReadStream(path2);
      let out_stream = exports.upload_chunked_stream(callback2, options);
      return file_reader.pipe(out_stream);
    }, "upload_chunked");
    var Chunkable = class extends Writable3 {
      constructor(options) {
        super(options);
        this.chunk_size = options.chunk_size != null ? options.chunk_size : 2e7;
        this.buffer = Buffer.alloc(0);
        this.active = true;
        this.on("finish", () => {
          if (this.active) {
            this.emit("ready", this.buffer, true, function() {
            });
          }
        });
      }
      _write(data, encoding, done) {
        if (!this.active) {
          done();
        }
        if (this.buffer.length + data.length <= this.chunk_size) {
          this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);
          done();
        } else {
          const grab = this.chunk_size - this.buffer.length;
          this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);
          this.emit("ready", this.buffer, false, (active) => {
            this.active = active;
            if (this.active) {
              const remaining = data.slice(grab);
              this.buffer = Buffer.alloc(0);
              this._write(remaining, encoding, done);
            }
          });
        }
      }
    };
    __name(Chunkable, "Chunkable");
    exports.upload_large_stream = /* @__PURE__ */ __name(function upload_large_stream(_unused_, callback2, options = {}) {
      return exports.upload_chunked_stream(callback2, extend({
        resource_type: "raw"
      }, options));
    }, "upload_large_stream");
    exports.upload_chunked_stream = /* @__PURE__ */ __name(function upload_chunked_stream(callback2, options = {}) {
      options = extend({}, options, {
        stream: true
      });
      options.x_unique_upload_id = utils.random_public_id();
      let params = build_upload_params(options);
      let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;
      let chunker = new Chunkable({
        chunk_size
      });
      let sent = 0;
      chunker.on("ready", function(buffer, is_last, done) {
        let chunk_start = sent;
        sent += buffer.length;
        options.content_range = `bytes ${chunk_start}-${sent - 1}/${is_last ? sent : -1}`;
        params.timestamp = utils.timestamp();
        let finished_part = /* @__PURE__ */ __name(function(result) {
          const errorOrLast = result.error != null || is_last;
          if (errorOrLast && typeof callback2 === "function") {
            callback2(result);
          }
          return done(!errorOrLast);
        }, "finished_part");
        let stream2 = call_api("upload", finished_part, options, function() {
          return [params, {}, buffer];
        });
        return stream2.write(buffer, "buffer", function() {
          return stream2.end();
        });
      });
      return chunker;
    }, "upload_chunked_stream");
    exports.explicit = /* @__PURE__ */ __name(function explicit(public_id, callback2, options = {}) {
      return call_api("explicit", callback2, options, function() {
        return utils.build_explicit_api_params(public_id, options);
      });
    }, "explicit");
    exports.create_archive = /* @__PURE__ */ __name(function create_archive(callback2, options = {}, target_format = null) {
      return call_api("generate_archive", callback2, options, function() {
        let opt = utils.archive_params(options);
        if (target_format) {
          opt.target_format = target_format;
        }
        return [opt];
      });
    }, "create_archive");
    exports.create_zip = /* @__PURE__ */ __name(function create_zip(callback2, options = {}) {
      return exports.create_archive(callback2, options, "zip");
    }, "create_zip");
    exports.create_slideshow = /* @__PURE__ */ __name(function create_slideshow(options, callback2) {
      options.resource_type = ensureOption(options, "resource_type", "video");
      return call_api("create_slideshow", callback2, options, function() {
        const manifest_transformation = utils.generate_transformation_string(extend({}, options.manifest_transformation));
        const transformation = utils.generate_transformation_string(extend({}, ensureOption(options, "transformation", {})));
        return [
          {
            timestamp: utils.timestamp(),
            manifest_transformation,
            upload_preset: options.upload_preset,
            overwrite: options.overwrite,
            public_id: options.public_id,
            notification_url: options.notification_url,
            manifest_json: options.manifest_json,
            tags: options.tags,
            transformation
          }
        ];
      });
    }, "create_slideshow");
    exports.destroy = /* @__PURE__ */ __name(function destroy2(public_id, callback2, options = {}) {
      return call_api("destroy", callback2, options, function() {
        return [
          {
            timestamp: utils.timestamp(),
            type: options.type,
            invalidate: options.invalidate,
            public_id,
            notification_url: options.notification_url
          }
        ];
      });
    }, "destroy");
    exports.rename = /* @__PURE__ */ __name(function rename3(from_public_id, to_public_id, callback2, options = {}) {
      return call_api("rename", callback2, options, function() {
        return [
          {
            timestamp: utils.timestamp(),
            type: options.type,
            from_public_id,
            to_public_id,
            overwrite: options.overwrite,
            invalidate: options.invalidate,
            to_type: options.to_type,
            context: options.context,
            metadata: options.metadata,
            notification_url: options.notification_url
          }
        ];
      });
    }, "rename");
    var TEXT_PARAMS = ["public_id", "font_family", "font_size", "font_color", "text_align", "font_weight", "font_style", "background", "opacity", "text_decoration", "font_hinting", "font_antialiasing"];
    exports.text = /* @__PURE__ */ __name(function text2(content, callback2, options = {}) {
      return call_api("text", callback2, options, function() {
        let textParams = pickOnlyExistingValues(options, ...TEXT_PARAMS);
        let params = {
          timestamp: utils.timestamp(),
          text: content,
          ...textParams
        };
        return [params];
      });
    }, "text");
    exports.generate_sprite = /* @__PURE__ */ __name(function generate_sprite(tag2, callback2, options = {}) {
      return call_api("sprite", callback2, options, function() {
        return [utils.build_multi_and_sprite_params(tag2, options)];
      });
    }, "generate_sprite");
    exports.download_generated_sprite = /* @__PURE__ */ __name(function download_generated_sprite(tag2, options = {}) {
      return utils.api_download_url("sprite", utils.build_multi_and_sprite_params(tag2, options), options);
    }, "download_generated_sprite");
    exports.download_multi = /* @__PURE__ */ __name(function download_multi(tag2, options = {}) {
      return utils.api_download_url("multi", utils.build_multi_and_sprite_params(tag2, options), options);
    }, "download_multi");
    exports.multi = /* @__PURE__ */ __name(function multi(tag2, callback2, options = {}) {
      return call_api("multi", callback2, options, function() {
        return [utils.build_multi_and_sprite_params(tag2, options)];
      });
    }, "multi");
    exports.explode = /* @__PURE__ */ __name(function explode(public_id, callback2, options = {}) {
      return call_api("explode", callback2, options, function() {
        const transformation = utils.generate_transformation_string(extend({}, options));
        return [
          {
            timestamp: utils.timestamp(),
            public_id,
            transformation,
            format: options.format,
            type: options.type,
            notification_url: options.notification_url
          }
        ];
      });
    }, "explode");
    exports.add_tag = /* @__PURE__ */ __name(function add_tag(tag2, public_ids = [], callback2, options = {}) {
      const exclusive = utils.option_consume("exclusive", options);
      const command = exclusive ? "set_exclusive" : "add";
      return call_tags_api(tag2, command, public_ids, callback2, options);
    }, "add_tag");
    exports.remove_tag = /* @__PURE__ */ __name(function remove_tag(tag2, public_ids = [], callback2, options = {}) {
      return call_tags_api(tag2, "remove", public_ids, callback2, options);
    }, "remove_tag");
    exports.remove_all_tags = /* @__PURE__ */ __name(function remove_all_tags(public_ids = [], callback2, options = {}) {
      return call_tags_api(null, "remove_all", public_ids, callback2, options);
    }, "remove_all_tags");
    exports.replace_tag = /* @__PURE__ */ __name(function replace_tag(tag2, public_ids = [], callback2, options = {}) {
      return call_tags_api(tag2, "replace", public_ids, callback2, options);
    }, "replace_tag");
    function call_tags_api(tag2, command, public_ids = [], callback2, options = {}) {
      return call_api("tags", callback2, options, function() {
        let params = {
          timestamp: utils.timestamp(),
          public_ids: utils.build_array(public_ids),
          command,
          type: options.type
        };
        if (tag2 != null) {
          params.tag = tag2;
        }
        return [params];
      });
    }
    __name(call_tags_api, "call_tags_api");
    exports.add_context = /* @__PURE__ */ __name(function add_context(context2, public_ids = [], callback2, options = {}) {
      return call_context_api(context2, "add", public_ids, callback2, options);
    }, "add_context");
    exports.remove_all_context = /* @__PURE__ */ __name(function remove_all_context(public_ids = [], callback2, options = {}) {
      return call_context_api(null, "remove_all", public_ids, callback2, options);
    }, "remove_all_context");
    function call_context_api(context2, command, public_ids = [], callback2, options = {}) {
      return call_api("context", callback2, options, function() {
        let params = {
          timestamp: utils.timestamp(),
          public_ids: utils.build_array(public_ids),
          command,
          type: options.type
        };
        if (context2 != null) {
          params.context = utils.encode_context(context2);
        }
        return [params];
      });
    }
    __name(call_context_api, "call_context_api");
    function cacheResults(result, { type: type2, resource_type }) {
      if (result.responsive_breakpoints) {
        result.responsive_breakpoints.forEach(
          ({
            transformation,
            url,
            breakpoints
          }) => Cache.set(
            result.public_id,
            { type: type2, resource_type, raw_transformation: transformation, format: extname(breakpoints[0].url).slice(1) },
            breakpoints.map((i3) => i3.width)
          )
        );
      }
    }
    __name(cacheResults, "cacheResults");
    function parseResult(buffer, res) {
      let result = "";
      try {
        result = JSON.parse(buffer);
        if (result.error && !result.error.name) {
          result.error.name = "Error";
        }
      } catch (jsonError) {
        result = {
          error: {
            message: `Server return invalid JSON response. Status Code ${res.statusCode}. ${jsonError}`,
            name: "Error"
          }
        };
      }
      return result;
    }
    __name(parseResult, "parseResult");
    function call_api(action, callback2, options, get_params) {
      if (typeof callback2 !== "function") {
        callback2 = /* @__PURE__ */ __name(function() {
        }, "callback");
      }
      const USE_PROMISES = !options.disable_promises;
      let deferred = Q.defer();
      if (options == null) {
        options = {};
      }
      let [params, unsigned_params, file] = get_params.call();
      params = utils.process_request_params(params, options);
      params = extend(params, unsigned_params);
      let api_url = utils.api_url(action, options);
      let boundary = utils.random_public_id();
      let errorRaised = false;
      let handle_response = /* @__PURE__ */ __name(function(res) {
        if (errorRaised) {
        } else if (res.error) {
          errorRaised = true;
          if (USE_PROMISES) {
            deferred.reject(res);
          }
          callback2(res);
        } else if (includes([200, 400, 401, 404, 420, 500], res.statusCode)) {
          let buffer = "";
          res.on("data", (d3) => {
            buffer += d3;
            return buffer;
          });
          res.on("end", () => {
            let result2;
            if (errorRaised) {
              return;
            }
            result2 = parseResult(buffer, res);
            if (result2.error) {
              result2.error.http_code = res.statusCode;
              if (USE_PROMISES) {
                deferred.reject(result2.error);
              }
            } else {
              cacheResults(result2, options);
              if (USE_PROMISES) {
                deferred.resolve(result2);
              }
            }
            callback2(result2);
          });
          res.on("error", (error4) => {
            errorRaised = true;
            if (USE_PROMISES) {
              deferred.reject(error4);
            }
            callback2({ error: error4 });
          });
        } else {
          let error4 = {
            message: `Server returned unexpected status code - ${res.statusCode}`,
            http_code: res.statusCode,
            name: "UnexpectedResponse"
          };
          if (USE_PROMISES) {
            deferred.reject(error4);
          }
          callback2({ error: error4 });
        }
      }, "handle_response");
      let post_data = utils.hashToParameters(params).filter(([key, value]) => value != null).map(
        ([key, value]) => Buffer.from(encodeFieldPart(boundary, key, value), "utf8")
      );
      let result = post(api_url, post_data, boundary, file, handle_response, options);
      if (isObject3(result)) {
        return result;
      }
      if (USE_PROMISES) {
        return deferred.promise;
      }
    }
    __name(call_api, "call_api");
    function post(url, post_data, boundary, file, callback2, options) {
      let file_header;
      let finish_buffer = Buffer.from("--" + boundary + "--", "ascii");
      let oauth_token = options.oauth_token || config2().oauth_token;
      if (file != null || options.stream) {
        let filename = options.stream ? options.filename ? options.filename : "file" : basename(file);
        file_header = Buffer.from(encodeFilePart(boundary, "application/octet-stream", "file", filename), "binary");
      }
      let post_options = urlLib.parse(url);
      let headers = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`,
        "User-Agent": utils.getUserAgent()
      };
      if (options.content_range != null) {
        headers["Content-Range"] = options.content_range;
      }
      if (options.x_unique_upload_id != null) {
        headers["X-Unique-Upload-Id"] = options.x_unique_upload_id;
      }
      if (options.extra_headers !== null) {
        headers = merge2(headers, options.extra_headers);
      }
      if (oauth_token != null) {
        headers.Authorization = `Bearer ${oauth_token}`;
      }
      post_options = extend(post_options, {
        method: "POST",
        headers
      });
      if (options.agent != null) {
        post_options.agent = options.agent;
      }
      let proxy = options.api_proxy || config2().api_proxy;
      if (!isEmpty(proxy)) {
        if (!post_options.agent && agent) {
          post_options.agent = agent;
        } else if (!post_options.agent) {
          post_options.agent = new https.Agent(proxy);
        } else {
          console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
        }
      }
      let post_request = https.request(post_options, callback2);
      let upload_stream = new UploadStream({ boundary });
      upload_stream.pipe(post_request);
      let timeout = false;
      post_request.on("error", function(error4) {
        if (timeout) {
          error4 = {
            message: "Request Timeout",
            http_code: 499,
            name: "TimeoutError"
          };
        }
        return callback2({ error: error4 });
      });
      post_request.setTimeout(options.timeout != null ? options.timeout : 6e4, function() {
        timeout = true;
        return post_request.abort();
      });
      post_data.forEach((postDatum) => post_request.write(postDatum));
      if (options.stream) {
        post_request.write(file_header);
        return upload_stream;
      }
      if (file != null) {
        post_request.write(file_header);
        fs.createReadStream(file).on("error", function(error4) {
          callback2({
            error: error4
          });
          return post_request.abort();
        }).pipe(upload_stream);
      } else {
        post_request.write(finish_buffer);
        post_request.end();
      }
      return true;
    }
    __name(post, "post");
    function encodeFieldPart(boundary, name, value) {
      return [
        `--${boundary}\r
`,
        `Content-Disposition: form-data; name="${name}"\r
`,
        "\r\n",
        `${value}\r
`,
        ""
      ].join("");
    }
    __name(encodeFieldPart, "encodeFieldPart");
    function encodeFilePart(boundary, type2, name, filename) {
      return [
        `--${boundary}\r
`,
        `Content-Disposition: form-data; name="${name}"; filename="${filename}"\r
`,
        `Content-Type: ${type2}\r
`,
        "\r\n",
        ""
      ].join("");
    }
    __name(encodeFilePart, "encodeFilePart");
    exports.direct_upload = /* @__PURE__ */ __name(function direct_upload(callback_url, options = {}) {
      let params = build_upload_params(extend({
        callback: callback_url
      }, options));
      params = utils.process_request_params(params, options);
      let api_url = utils.api_url("upload", options);
      return {
        hidden_fields: params,
        form_attrs: {
          action: api_url,
          method: "POST",
          enctype: "multipart/form-data"
        }
      };
    }, "direct_upload");
    exports.upload_tag_params = /* @__PURE__ */ __name(function upload_tag_params(options = {}) {
      let params = build_upload_params(options);
      params = utils.process_request_params(params, options);
      return JSON.stringify(params);
    }, "upload_tag_params");
    exports.upload_url = /* @__PURE__ */ __name(function upload_url(options = {}) {
      if (options.resource_type == null) {
        options.resource_type = "auto";
      }
      return utils.api_url("upload", options);
    }, "upload_url");
    exports.image_upload_tag = /* @__PURE__ */ __name(function image_upload_tag(field, options = {}) {
      let html_options = options.html || {};
      let tag_options = extend({
        type: "file",
        name: "file",
        "data-url": exports.upload_url(options),
        "data-form-data": exports.upload_tag_params(options),
        "data-cloudinary-field": field,
        "data-max-chunk-size": options.chunk_size,
        "class": [html_options.class, "cloudinary-fileupload"].join(" ")
      }, html_options);
      return `<input ${utils.html_attrs(tag_options)}/>`;
    }, "image_upload_tag");
    exports.unsigned_image_upload_tag = /* @__PURE__ */ __name(function unsigned_image_upload_tag(field, upload_preset, options = {}) {
      return exports.image_upload_tag(field, merge2(options, {
        unsigned: true,
        upload_preset
      }));
    }, "unsigned_image_upload_tag");
    exports.update_metadata = /* @__PURE__ */ __name(function update_metadata(metadata, public_ids, callback2, options = {}) {
      return call_api("metadata", callback2, options, function() {
        let params = {
          metadata: utils.encode_context(metadata),
          public_ids: utils.build_array(public_ids),
          timestamp: utils.timestamp(),
          type: options.type,
          clear_invalid: options.clear_invalid
        };
        return [params];
      });
    }, "update_metadata");
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/execute_request.js
var require_execute_request = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/execute_request.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var config2 = require_config();
    var https = /^http:/.test(config2().upload_prefix) ? require_http() : require_https();
    var querystring = require_querystring();
    var Q = require_q();
    var url = require_url();
    var utils = require_utils();
    var ensureOption = require_ensureOption().defaults(config2());
    var { extend, includes, isEmpty } = utils;
    var agent = config2.api_proxy ? new https.Agent(config2.api_proxy) : null;
    function execute_request(method, params, auth, api_url, callback2, options = {}) {
      method = method.toUpperCase();
      const deferred = Q.defer();
      let query_params, handle_response;
      let key = auth.key;
      let secret = auth.secret;
      let oauth_token = auth.oauth_token;
      let content_type = "application/x-www-form-urlencoded";
      if (options.content_type === "json") {
        query_params = JSON.stringify(params);
        content_type = "application/json";
      } else {
        query_params = querystring.stringify(params);
      }
      if (method === "GET") {
        api_url += "?" + query_params;
      }
      let request_options = url.parse(api_url);
      request_options = extend(request_options, {
        method,
        headers: {
          "Content-Type": content_type,
          "User-Agent": utils.getUserAgent()
        }
      });
      if (oauth_token) {
        request_options.headers.Authorization = `Bearer ${oauth_token}`;
      } else {
        request_options.auth = key + ":" + secret;
      }
      if (options.agent != null) {
        request_options.agent = options.agent;
      }
      let proxy = options.api_proxy || config2().api_proxy;
      if (!isEmpty(proxy)) {
        if (!request_options.agent && agent) {
          request_options.agent = agent;
        } else if (!request_options.agent) {
          request_options.agent = new https.Agent(proxy);
        } else {
          console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
        }
      }
      if (method !== "GET") {
        request_options.headers["Content-Length"] = Buffer.byteLength(query_params);
      }
      handle_response = /* @__PURE__ */ __name(function(res) {
        const { hide_sensitive = false } = config2();
        const sanitizedOptions = { ...request_options };
        if (hide_sensitive === true) {
          if ("auth" in sanitizedOptions) {
            delete sanitizedOptions.auth;
          }
          if ("Authorization" in sanitizedOptions.headers) {
            delete sanitizedOptions.headers.Authorization;
          }
        }
        if (includes([200, 400, 401, 403, 404, 409, 420, 500], res.statusCode)) {
          let buffer = "";
          let error4 = false;
          res.on("data", function(d3) {
            buffer += d3;
            return buffer;
          });
          res.on("end", function() {
            let result;
            if (error4) {
              return;
            }
            try {
              result = JSON.parse(buffer);
            } catch (e2) {
              result = {
                error: {
                  message: "Server return invalid JSON response. Status Code " + res.statusCode
                }
              };
            }
            if (result.error) {
              result.error.http_code = res.statusCode;
            } else {
              if (res.headers["x-featureratelimit-limit"]) {
                result.rate_limit_allowed = parseInt(res.headers["x-featureratelimit-limit"]);
              }
              if (res.headers["x-featureratelimit-reset"]) {
                result.rate_limit_reset_at = new Date(res.headers["x-featureratelimit-reset"]);
              }
              if (res.headers["x-featureratelimit-remaining"]) {
                result.rate_limit_remaining = parseInt(res.headers["x-featureratelimit-remaining"]);
              }
            }
            if (result.error) {
              deferred.reject(Object.assign({
                request_options: sanitizedOptions,
                query_params
              }, result));
            } else {
              deferred.resolve(result);
            }
            if (typeof callback2 === "function") {
              callback2(result);
            }
          });
          res.on("error", function(e2) {
            error4 = true;
            let err_obj = {
              error: {
                message: e2,
                http_code: res.statusCode,
                request_options: sanitizedOptions,
                query_params
              }
            };
            deferred.reject(err_obj.error);
            if (typeof callback2 === "function") {
              callback2(err_obj);
            }
          });
        } else {
          let err_obj = {
            error: {
              message: "Server returned unexpected status code - " + res.statusCode,
              http_code: res.statusCode,
              request_options: sanitizedOptions,
              query_params
            }
          };
          deferred.reject(err_obj.error);
          if (typeof callback2 === "function") {
            callback2(err_obj);
          }
        }
      }, "handle_response");
      const request3 = https.request(request_options, handle_response);
      request3.on("error", function(e2) {
        deferred.reject(e2);
        return typeof callback2 === "function" ? callback2({ error: e2 }) : void 0;
      });
      request3.setTimeout(ensureOption(options, "timeout", 6e4));
      if (method !== "GET") {
        request3.write(query_params);
      }
      request3.end();
      return deferred.promise;
    }
    __name(execute_request, "execute_request");
    module.exports = execute_request;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_api.js
var require_call_api = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_api.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var config2 = require_config();
    var utils = require_utils();
    var ensureOption = require_ensureOption().defaults(config2());
    var execute_request = require_execute_request();
    var { ensurePresenceOf } = utils;
    function call_api(method, uri, params, callback2, options) {
      ensurePresenceOf({ method, uri });
      const api_url = utils.base_api_url_v1()(uri, options);
      let auth = {};
      if (options.oauth_token || config2().oauth_token) {
        auth = {
          oauth_token: ensureOption(options, "oauth_token")
        };
      } else {
        auth = {
          key: ensureOption(options, "api_key"),
          secret: ensureOption(options, "api_secret")
        };
      }
      return execute_request(method, params, auth, api_url, callback2, options);
    }
    __name(call_api, "call_api");
    module.exports = call_api;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utils = require_utils();
    var call_api = require_call_api();
    var {
      extend,
      pickOnlyExistingValues
    } = utils;
    var TRANSFORMATIONS_URI = "transformations";
    function deleteResourcesParams(options, params = {}) {
      return extend(params, pickOnlyExistingValues(options, "keep_original", "invalidate", "next_cursor", "transformations"));
    }
    __name(deleteResourcesParams, "deleteResourcesParams");
    function getResourceParams(options) {
      return pickOnlyExistingValues(options, "exif", "cinemagraph_analysis", "colors", "derived_next_cursor", "faces", "image_metadata", "media_metadata", "pages", "phash", "coordinates", "max_results", "versions", "accessibility_analysis", "related", "related_next_cursor");
    }
    __name(getResourceParams, "getResourceParams");
    exports.ping = /* @__PURE__ */ __name(function ping(callback2, options = {}) {
      return call_api("get", ["ping"], {}, callback2, options);
    }, "ping");
    exports.usage = /* @__PURE__ */ __name(function usage(callback2, options = {}) {
      const uri = ["usage"];
      if (options.date) {
        uri.push(options.date);
      }
      return call_api("get", uri, {}, callback2, options);
    }, "usage");
    exports.resource_types = /* @__PURE__ */ __name(function resource_types(callback2, options = {}) {
      return call_api("get", ["resources"], {}, callback2, options);
    }, "resource_types");
    exports.resources = /* @__PURE__ */ __name(function resources(callback2, options = {}) {
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type;
      uri = ["resources", resource_type];
      if (type2 != null) {
        uri.push(type2);
      }
      if (options.start_at != null && Object.prototype.toString.call(options.start_at) === "[object Date]") {
        options.start_at = options.start_at.toUTCString();
      }
      return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix", "tags", "context", "direction", "moderations", "start_at", "metadata", "fields"), callback2, options);
    }, "resources");
    exports.resources_by_tag = /* @__PURE__ */ __name(function resources_by_tag(tag2, callback2, options = {}) {
      let resource_type, uri;
      resource_type = options.resource_type || "image";
      uri = ["resources", resource_type, "tags", tag2];
      return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback2, options);
    }, "resources_by_tag");
    exports.resources_by_context = /* @__PURE__ */ __name(function resources_by_context(key, value, callback2, options = {}) {
      let params, resource_type, uri;
      resource_type = options.resource_type || "image";
      uri = ["resources", resource_type, "context"];
      params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields");
      params.key = key;
      if (value != null) {
        params.value = value;
      }
      return call_api("get", uri, params, callback2, options);
    }, "resources_by_context");
    exports.resources_by_moderation = /* @__PURE__ */ __name(function resources_by_moderation(kind, status, callback2, options = {}) {
      let resource_type, uri;
      resource_type = options.resource_type || "image";
      uri = ["resources", resource_type, "moderations", kind, status];
      return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback2, options);
    }, "resources_by_moderation");
    exports.resource_by_asset_id = /* @__PURE__ */ __name(function resource_by_asset_id(asset_id, callback2, options = {}) {
      const uri = ["resources", asset_id];
      return call_api("get", uri, getResourceParams(options), callback2, options);
    }, "resource_by_asset_id");
    exports.resources_by_asset_folder = /* @__PURE__ */ __name(function resources_by_asset_folder(asset_folder, callback2, options = {}) {
      let params, uri;
      uri = ["resources", "by_asset_folder"];
      params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "moderations", "fields");
      params.asset_folder = asset_folder;
      return call_api("get", uri, params, callback2, options);
    }, "resources_by_asset_folder");
    exports.resources_by_asset_ids = /* @__PURE__ */ __name(function resources_by_asset_ids(asset_ids, callback2, options = {}) {
      let params, uri;
      uri = ["resources", "by_asset_ids"];
      params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
      params["asset_ids[]"] = asset_ids;
      return call_api("get", uri, params, callback2, options);
    }, "resources_by_asset_ids");
    exports.resources_by_ids = /* @__PURE__ */ __name(function resources_by_ids(public_ids, callback2, options = {}) {
      let params, resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2];
      params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
      params["public_ids[]"] = public_ids;
      return call_api("get", uri, params, callback2, options);
    }, "resources_by_ids");
    exports.resource = /* @__PURE__ */ __name(function resource(public_id, callback2, options = {}) {
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2, public_id];
      return call_api("get", uri, getResourceParams(options), callback2, options);
    }, "resource");
    exports.restore = /* @__PURE__ */ __name(function restore(public_ids, callback2, options = {}) {
      options.content_type = "json";
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2, "restore"];
      return call_api("post", uri, {
        public_ids,
        versions: options.versions
      }, callback2, options);
    }, "restore");
    exports.update = /* @__PURE__ */ __name(function update(public_id, callback2, options = {}) {
      let params, resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2, public_id];
      params = utils.updateable_resource_params(options);
      if (options.moderation_status != null) {
        params.moderation_status = options.moderation_status;
      }
      if (options.clear_invalid != null) {
        params.clear_invalid = options.clear_invalid;
      }
      return call_api("post", uri, params, callback2, options);
    }, "update");
    exports.delete_resources = /* @__PURE__ */ __name(function delete_resources(public_ids, callback2, options = {}) {
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2];
      return call_api("delete", uri, deleteResourcesParams(options, {
        "public_ids[]": public_ids
      }), callback2, options);
    }, "delete_resources");
    exports.delete_resources_by_prefix = /* @__PURE__ */ __name(function delete_resources_by_prefix(prefix, callback2, options = {}) {
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2];
      return call_api("delete", uri, deleteResourcesParams(options, {
        prefix
      }), callback2, options);
    }, "delete_resources_by_prefix");
    exports.delete_resources_by_tag = /* @__PURE__ */ __name(function delete_resources_by_tag(tag2, callback2, options = {}) {
      let resource_type, uri;
      resource_type = options.resource_type || "image";
      uri = ["resources", resource_type, "tags", tag2];
      return call_api("delete", uri, deleteResourcesParams(options), callback2, options);
    }, "delete_resources_by_tag");
    exports.delete_all_resources = /* @__PURE__ */ __name(function delete_all_resources(callback2, options = {}) {
      let resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = ["resources", resource_type, type2];
      return call_api("delete", uri, deleteResourcesParams(options, {
        all: true
      }), callback2, options);
    }, "delete_all_resources");
    var createRelationParams = /* @__PURE__ */ __name((publicIds = []) => {
      return {
        assets_to_relate: Array.isArray(publicIds) ? publicIds : [publicIds]
      };
    }, "createRelationParams");
    var deleteRelationParams = /* @__PURE__ */ __name((publicIds = []) => {
      return {
        assets_to_unrelate: Array.isArray(publicIds) ? publicIds : [publicIds]
      };
    }, "deleteRelationParams");
    exports.add_related_assets = (publicId, assetsToRelate, callback2, options = {}) => {
      const params = createRelationParams(assetsToRelate);
      return call_api("post", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback2, options);
    };
    exports.add_related_assets_by_asset_id = (assetId, assetsToRelate, callback2, options = {}) => {
      const params = createRelationParams(assetsToRelate);
      return call_api("post", ["resources", "related_assets", assetId], params, callback2, options);
    };
    exports.delete_related_assets = (publicId, assetsToUnrelate, callback2, options = {}) => {
      const params = deleteRelationParams(assetsToUnrelate);
      return call_api("delete", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback2, options);
    };
    exports.delete_related_assets_by_asset_id = (assetId, assetsToUnrelate, callback2, options = {}) => {
      const params = deleteRelationParams(assetsToUnrelate);
      return call_api("delete", ["resources", "related_assets", assetId], params, callback2, options);
    };
    exports.delete_derived_resources = /* @__PURE__ */ __name(function delete_derived_resources(derived_resource_ids, callback2, options = {}) {
      let uri;
      uri = ["derived_resources"];
      return call_api("delete", uri, {
        "derived_resource_ids[]": derived_resource_ids
      }, callback2, options);
    }, "delete_derived_resources");
    exports.delete_derived_by_transformation = /* @__PURE__ */ __name(function delete_derived_by_transformation(public_ids, transformations, callback2, options = {}) {
      let params, resource_type, type2, uri;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      uri = "resources/" + resource_type + "/" + type2;
      params = extend({
        "public_ids[]": public_ids
      }, pickOnlyExistingValues(options, "invalidate"));
      params.keep_original = true;
      params.transformations = utils.build_eager(transformations);
      return call_api("delete", uri, params, callback2, options);
    }, "delete_derived_by_transformation");
    exports.tags = /* @__PURE__ */ __name(function tags(callback2, options = {}) {
      let resource_type, uri;
      resource_type = options.resource_type || "image";
      uri = ["tags", resource_type];
      return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix"), callback2, options);
    }, "tags");
    exports.transformations = /* @__PURE__ */ __name(function transformations(callback2, options = {}) {
      const params = pickOnlyExistingValues(options, "next_cursor", "max_results", "named");
      return call_api("get", TRANSFORMATIONS_URI, params, callback2, options);
    }, "transformations");
    exports.transformation = /* @__PURE__ */ __name(function transformation(transformationName, callback2, options = {}) {
      const params = pickOnlyExistingValues(options, "next_cursor", "max_results");
      params.transformation = utils.build_eager(transformationName);
      return call_api("get", TRANSFORMATIONS_URI, params, callback2, options);
    }, "transformation");
    exports.delete_transformation = /* @__PURE__ */ __name(function delete_transformation(transformationName, callback2, options = {}) {
      const params = {};
      params.transformation = utils.build_eager(transformationName);
      return call_api("delete", TRANSFORMATIONS_URI, params, callback2, options);
    }, "delete_transformation");
    exports.update_transformation = /* @__PURE__ */ __name(function update_transformation(transformationName, updates, callback2, options = {}) {
      const params = pickOnlyExistingValues(updates, "allowed_for_strict");
      params.transformation = utils.build_eager(transformationName);
      if (updates.unsafe_update != null) {
        params.unsafe_update = utils.build_eager(updates.unsafe_update);
      }
      return call_api("put", TRANSFORMATIONS_URI, params, callback2, options);
    }, "update_transformation");
    exports.create_transformation = /* @__PURE__ */ __name(function create_transformation(name, definition, callback2, options = {}) {
      const params = { name };
      params.transformation = utils.build_eager(definition);
      return call_api("post", TRANSFORMATIONS_URI, params, callback2, options);
    }, "create_transformation");
    exports.upload_presets = /* @__PURE__ */ __name(function upload_presets(callback2, options = {}) {
      return call_api("get", ["upload_presets"], pickOnlyExistingValues(options, "next_cursor", "max_results"), callback2, options);
    }, "upload_presets");
    exports.upload_preset = /* @__PURE__ */ __name(function upload_preset(name, callback2, options = {}) {
      let uri;
      uri = ["upload_presets", name];
      return call_api("get", uri, {}, callback2, options);
    }, "upload_preset");
    exports.delete_upload_preset = /* @__PURE__ */ __name(function delete_upload_preset(name, callback2, options = {}) {
      let uri;
      uri = ["upload_presets", name];
      return call_api("delete", uri, {}, callback2, options);
    }, "delete_upload_preset");
    exports.update_upload_preset = /* @__PURE__ */ __name(function update_upload_preset(name, callback2, options = {}) {
      let params, uri;
      uri = ["upload_presets", name];
      params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "unsigned", "disallow_public_id", "live"));
      return call_api("put", uri, params, callback2, options);
    }, "update_upload_preset");
    exports.create_upload_preset = /* @__PURE__ */ __name(function create_upload_preset(callback2, options = {}) {
      let params, uri;
      uri = ["upload_presets"];
      params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "name", "unsigned", "disallow_public_id", "live"));
      return call_api("post", uri, params, callback2, options);
    }, "create_upload_preset");
    exports.root_folders = /* @__PURE__ */ __name(function root_folders(callback2, options = {}) {
      let uri, params;
      uri = ["folders"];
      params = pickOnlyExistingValues(options, "next_cursor", "max_results");
      return call_api("get", uri, params, callback2, options);
    }, "root_folders");
    exports.sub_folders = /* @__PURE__ */ __name(function sub_folders(path2, callback2, options = {}) {
      let uri, params;
      uri = ["folders", path2];
      params = pickOnlyExistingValues(options, "next_cursor", "max_results");
      return call_api("get", uri, params, callback2, options);
    }, "sub_folders");
    exports.create_folder = /* @__PURE__ */ __name(function create_folder(path2, callback2, options = {}) {
      let uri;
      uri = ["folders", path2];
      return call_api("post", uri, {}, callback2, options);
    }, "create_folder");
    exports.delete_folder = /* @__PURE__ */ __name(function delete_folder(path2, callback2, options = {}) {
      let uri;
      uri = ["folders", path2];
      return call_api("delete", uri, {}, callback2, options);
    }, "delete_folder");
    exports.rename_folder = /* @__PURE__ */ __name(function rename_folder(old_path, new_path, callback2, options = {}) {
      let uri;
      uri = ["folders", old_path];
      let rename_folder_params = {
        to_folder: new_path
      };
      options.content_type = "json";
      return call_api("put", uri, rename_folder_params, callback2, options);
    }, "rename_folder");
    exports.upload_mappings = /* @__PURE__ */ __name(function upload_mappings(callback2, options = {}) {
      let params;
      params = pickOnlyExistingValues(options, "next_cursor", "max_results");
      return call_api("get", "upload_mappings", params, callback2, options);
    }, "upload_mappings");
    exports.upload_mapping = /* @__PURE__ */ __name(function upload_mapping(name, callback2, options = {}) {
      if (name == null) {
        name = null;
      }
      return call_api("get", "upload_mappings", {
        folder: name
      }, callback2, options);
    }, "upload_mapping");
    exports.delete_upload_mapping = /* @__PURE__ */ __name(function delete_upload_mapping(name, callback2, options = {}) {
      return call_api("delete", "upload_mappings", {
        folder: name
      }, callback2, options);
    }, "delete_upload_mapping");
    exports.update_upload_mapping = /* @__PURE__ */ __name(function update_upload_mapping(name, callback2, options = {}) {
      let params;
      params = pickOnlyExistingValues(options, "template");
      params.folder = name;
      return call_api("put", "upload_mappings", params, callback2, options);
    }, "update_upload_mapping");
    exports.create_upload_mapping = /* @__PURE__ */ __name(function create_upload_mapping(name, callback2, options = {}) {
      let params;
      params = pickOnlyExistingValues(options, "template");
      params.folder = name;
      return call_api("post", "upload_mappings", params, callback2, options);
    }, "create_upload_mapping");
    function publishResource(byKey, value, callback2, options = {}) {
      let params, resource_type, uri;
      params = pickOnlyExistingValues(options, "type", "invalidate", "overwrite");
      params[byKey] = value;
      resource_type = options.resource_type || "image";
      uri = ["resources", resource_type, "publish_resources"];
      options = extend({
        resource_type
      }, options);
      return call_api("post", uri, params, callback2, options);
    }
    __name(publishResource, "publishResource");
    exports.publish_by_prefix = /* @__PURE__ */ __name(function publish_by_prefix(prefix, callback2, options = {}) {
      return publishResource("prefix", prefix, callback2, options);
    }, "publish_by_prefix");
    exports.publish_by_tag = /* @__PURE__ */ __name(function publish_by_tag(tag2, callback2, options = {}) {
      return publishResource("tag", tag2, callback2, options);
    }, "publish_by_tag");
    exports.publish_by_ids = /* @__PURE__ */ __name(function publish_by_ids(public_ids, callback2, options = {}) {
      return publishResource("public_ids", public_ids, callback2, options);
    }, "publish_by_ids");
    exports.list_streaming_profiles = /* @__PURE__ */ __name(function list_streaming_profiles(callback2, options = {}) {
      return call_api("get", "streaming_profiles", {}, callback2, options);
    }, "list_streaming_profiles");
    exports.get_streaming_profile = /* @__PURE__ */ __name(function get_streaming_profile(name, callback2, options = {}) {
      return call_api("get", "streaming_profiles/" + name, {}, callback2, options);
    }, "get_streaming_profile");
    exports.delete_streaming_profile = /* @__PURE__ */ __name(function delete_streaming_profile(name, callback2, options = {}) {
      return call_api("delete", "streaming_profiles/" + name, {}, callback2, options);
    }, "delete_streaming_profile");
    exports.update_streaming_profile = /* @__PURE__ */ __name(function update_streaming_profile(name, callback2, options = {}) {
      let params;
      params = utils.build_streaming_profiles_param(options);
      return call_api("put", "streaming_profiles/" + name, params, callback2, options);
    }, "update_streaming_profile");
    exports.create_streaming_profile = /* @__PURE__ */ __name(function create_streaming_profile(name, callback2, options = {}) {
      let params;
      params = utils.build_streaming_profiles_param(options);
      params.name = name;
      return call_api("post", "streaming_profiles", params, callback2, options);
    }, "create_streaming_profile");
    function updateResourcesAccessMode(access_mode, by_key, value, callback2, options = {}) {
      let params, resource_type, type2;
      resource_type = options.resource_type || "image";
      type2 = options.type || "upload";
      params = {
        access_mode
      };
      params[by_key] = value;
      return call_api("post", "resources/" + resource_type + "/" + type2 + "/update_access_mode", params, callback2, options);
    }
    __name(updateResourcesAccessMode, "updateResourcesAccessMode");
    exports.search = /* @__PURE__ */ __name(function search(params, callback2, options = {}) {
      options.content_type = "json";
      return call_api("post", "resources/search", params, callback2, options);
    }, "search");
    exports.visual_search = /* @__PURE__ */ __name(function visual_search(params, callback2, options = {}) {
      const allowedParams = pickOnlyExistingValues(params, "image_url", "image_asset_id", "text");
      return call_api("get", ["resources", "visual_search"], allowedParams, callback2, options);
    }, "visual_search");
    exports.search_folders = /* @__PURE__ */ __name(function search_folders(params, callback2, options = {}) {
      options.content_type = "json";
      return call_api("post", "folders/search", params, callback2, options);
    }, "search_folders");
    exports.update_resources_access_mode_by_prefix = /* @__PURE__ */ __name(function update_resources_access_mode_by_prefix(access_mode, prefix, callback2, options = {}) {
      return updateResourcesAccessMode(access_mode, "prefix", prefix, callback2, options);
    }, "update_resources_access_mode_by_prefix");
    exports.update_resources_access_mode_by_tag = /* @__PURE__ */ __name(function update_resources_access_mode_by_tag(access_mode, tag2, callback2, options = {}) {
      return updateResourcesAccessMode(access_mode, "tag", tag2, callback2, options);
    }, "update_resources_access_mode_by_tag");
    exports.update_resources_access_mode_by_ids = /* @__PURE__ */ __name(function update_resources_access_mode_by_ids(access_mode, ids, callback2, options = {}) {
      return updateResourcesAccessMode(access_mode, "public_ids[]", ids, callback2, options);
    }, "update_resources_access_mode_by_ids");
    exports.add_metadata_field = /* @__PURE__ */ __name(function add_metadata_field(field, callback2, options = {}) {
      const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions");
      options.content_type = "json";
      return call_api("post", ["metadata_fields"], params, callback2, options);
    }, "add_metadata_field");
    exports.list_metadata_fields = /* @__PURE__ */ __name(function list_metadata_fields(callback2, options = {}) {
      return call_api("get", ["metadata_fields"], {}, callback2, options);
    }, "list_metadata_fields");
    exports.delete_metadata_field = /* @__PURE__ */ __name(function delete_metadata_field(field_external_id, callback2, options = {}) {
      return call_api("delete", ["metadata_fields", field_external_id], {}, callback2, options);
    }, "delete_metadata_field");
    exports.metadata_field_by_field_id = /* @__PURE__ */ __name(function metadata_field_by_field_id(external_id, callback2, options = {}) {
      return call_api("get", ["metadata_fields", external_id], {}, callback2, options);
    }, "metadata_field_by_field_id");
    exports.update_metadata_field = /* @__PURE__ */ __name(function update_metadata_field(external_id, field, callback2, options = {}) {
      const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions", "default_disabled");
      options.content_type = "json";
      return call_api("put", ["metadata_fields", external_id], params, callback2, options);
    }, "update_metadata_field");
    exports.update_metadata_field_datasource = /* @__PURE__ */ __name(function update_metadata_field_datasource(field_external_id, entries_external_id, callback2, options = {}) {
      const params = pickOnlyExistingValues(entries_external_id, "values");
      options.content_type = "json";
      return call_api("put", ["metadata_fields", field_external_id, "datasource"], params, callback2, options);
    }, "update_metadata_field_datasource");
    exports.delete_datasource_entries = /* @__PURE__ */ __name(function delete_datasource_entries(field_external_id, entries_external_id, callback2, options = {}) {
      options.content_type = "json";
      const params = { external_ids: entries_external_id };
      return call_api("delete", ["metadata_fields", field_external_id, "datasource"], params, callback2, options);
    }, "delete_datasource_entries");
    exports.restore_metadata_field_datasource = /* @__PURE__ */ __name(function restore_metadata_field_datasource(field_external_id, entries_external_id, callback2, options = {}) {
      options.content_type = "json";
      const params = { external_ids: entries_external_id };
      return call_api("post", ["metadata_fields", field_external_id, "datasource_restore"], params, callback2, options);
    }, "restore_metadata_field_datasource");
    exports.order_metadata_field_datasource = /* @__PURE__ */ __name(function order_metadata_field_datasource(field_external_id, sort_by, direction, callback2, options = {}) {
      options.content_type = "json";
      const params = {
        order_by: sort_by,
        direction
      };
      return call_api("post", ["metadata_fields", field_external_id, "datasource", "order"], params, callback2, options);
    }, "order_metadata_field_datasource");
    exports.reorder_metadata_fields = /* @__PURE__ */ __name(function reorder_metadata_fields(order_by, direction, callback2, options = {}) {
      options.content_type = "json";
      const params = {
        order_by,
        direction
      };
      return call_api("put", ["metadata_fields", "order"], params, callback2, options);
    }, "reorder_metadata_fields");
    exports.list_metadata_rules = /* @__PURE__ */ __name(function list_metadata_rules(callback2, options = {}) {
      return call_api("get", ["metadata_rules"], {}, callback2, options);
    }, "list_metadata_rules");
    exports.add_metadata_rule = /* @__PURE__ */ __name(function add_metadata_rule(metadata_rule, callback2, options = {}) {
      options.content_type = "json";
      const params = pickOnlyExistingValues(metadata_rule, "metadata_field_id", "condition", "result", "name");
      return call_api("post", ["metadata_rules"], params, callback2, options);
    }, "add_metadata_rule");
    exports.update_metadata_rule = /* @__PURE__ */ __name(function update_metadata_rule(field_external_id, updated_metadata_rule, callback2, options = {}) {
      options.content_type = "json";
      const params = pickOnlyExistingValues(updated_metadata_rule, "metadata_field_id", "condition", "result", "name", "state");
      return call_api("put", ["metadata_rules", field_external_id], params, callback2, options);
    }, "update_metadata_rule");
    exports.delete_metadata_rule = /* @__PURE__ */ __name(function delete_metadata_rule(field_external_id, callback2, options = {}) {
      return call_api("delete", ["metadata_rules", field_external_id], {}, callback2, options);
    }, "delete_metadata_rule");
    exports.config = /* @__PURE__ */ __name(function config2(callback2, options = {}) {
      const params = pickOnlyExistingValues(options, "settings");
      return call_api("get", ["config"], params, callback2, options);
    }, "config");
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_analysis_api.js
var require_call_analysis_api = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_analysis_api.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utils = require_utils();
    var config2 = require_config();
    var ensureOption = require_ensureOption().defaults(config2());
    var execute_request = require_execute_request();
    var { ensurePresenceOf } = utils;
    function call_analysis_api(method, uri, params, callback2, options) {
      ensurePresenceOf({
        method,
        uri
      });
      const api_url = utils.base_api_url_v2()(uri, options);
      let auth = {};
      if (options.oauth_token || config2().oauth_token) {
        auth = {
          oauth_token: ensureOption(options, "oauth_token")
        };
      } else {
        auth = {
          key: ensureOption(options, "api_key"),
          secret: ensureOption(options, "api_secret")
        };
      }
      options.content_type = "json";
      return execute_request(method, params, auth, api_url, callback2, options);
    }
    __name(call_analysis_api, "call_analysis_api");
    module.exports = {
      call_analysis_api
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/analysis/index.js
var require_analysis = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/analysis/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utils = require_utils();
    var { call_analysis_api } = require_call_analysis_api();
    function analyze_uri(uri, analysis_type, options = {}, callback2) {
      const params = {
        uri,
        analysis_type
      };
      if (analysis_type === "custom") {
        if (!("model_name" in options) || !("model_version" in options)) {
          throw new Error('Setting analysis_type to "custom" requires additional params: "model_name" and "model_version"');
        }
        params.parameters = {
          custom: {
            model_name: options.model_name,
            model_version: options.model_version
          }
        };
      }
      let api_uri = ["analysis", "analyze", "uri"];
      return call_analysis_api("POST", api_uri, params, callback2, options);
    }
    __name(analyze_uri, "analyze_uri");
    module.exports = {
      analyze_uri
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_account_api.js
var require_call_account_api = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/api_client/call_account_api.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var config2 = require_config();
    var utils = require_utils();
    var ensureOption = require_ensureOption().defaults(config2());
    var execute_request = require_execute_request();
    var { ensurePresenceOf } = utils;
    function call_account_api(method, uri, params, callback2, options) {
      ensurePresenceOf({ method, uri });
      const cloudinary2 = ensureOption(options, "upload_prefix", "https://api.cloudinary.com");
      const account_id = ensureOption(options, "account_id");
      const api_url = [cloudinary2, "v1_1", "provisioning", "accounts", account_id].concat(uri).join("/");
      const auth = {
        key: ensureOption(options, "provisioning_api_key"),
        secret: ensureOption(options, "provisioning_api_secret")
      };
      return execute_request(method, params, auth, api_url, callback2, options);
    }
    __name(call_account_api, "call_account_api");
    module.exports = call_account_api;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/provisioning/account.js
var require_account = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/provisioning/account.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utils = require_utils();
    var call_account_api = require_call_account_api();
    var { pickOnlyExistingValues } = utils;
    function sub_accounts(enabled, ids = [], prefix, options = {}, callback2) {
      let params = {
        enabled,
        ids,
        prefix
      };
      let uri = ["sub_accounts"];
      return call_account_api("GET", uri, params, callback2, options);
    }
    __name(sub_accounts, "sub_accounts");
    function sub_account(sub_account_id, options = {}, callback2) {
      let uri = ["sub_accounts", sub_account_id];
      return call_account_api("GET", uri, {}, callback2, options);
    }
    __name(sub_account, "sub_account");
    function create_sub_account(name, cloud_name, custom_attributes, enabled, base_account, options = {}, callback2) {
      let params = {
        cloud_name,
        name,
        custom_attributes,
        enabled,
        base_sub_account_id: base_account
      };
      options.content_type = "json";
      let uri = ["sub_accounts"];
      return call_account_api("POST", uri, params, callback2, options);
    }
    __name(create_sub_account, "create_sub_account");
    function delete_sub_account(sub_account_id, options = {}, callback2) {
      let uri = ["sub_accounts", sub_account_id];
      return call_account_api("DELETE", uri, {}, callback2, options);
    }
    __name(delete_sub_account, "delete_sub_account");
    function update_sub_account(sub_account_id, name, cloud_name, custom_attributes, enabled, options = {}, callback2) {
      let params = {
        cloud_name,
        name,
        custom_attributes,
        enabled
      };
      options.content_type = "json";
      let uri = ["sub_accounts", sub_account_id];
      return call_account_api("PUT", uri, params, callback2, options);
    }
    __name(update_sub_account, "update_sub_account");
    function user2(user_id, options = {}, callback2) {
      let uri = ["users", user_id];
      return call_account_api("GET", uri, {}, callback2, options);
    }
    __name(user2, "user");
    function users3(pending, user_ids, prefix, sub_account_id, options = {}, callback2) {
      let uri = ["users"];
      let params = {
        ids: user_ids,
        pending,
        prefix,
        sub_account_id
      };
      return call_account_api("GET", uri, pickOnlyExistingValues(params, "ids", "pending", "prefix", "sub_account_id"), callback2, options);
    }
    __name(users3, "users");
    function create_user(name, email, role, sub_account_ids, options = {}, callback2) {
      let uri = ["users"];
      let params = {
        name,
        email,
        role,
        sub_account_ids
      };
      options.content_type = "json";
      return call_account_api("POST", uri, params, callback2, options);
    }
    __name(create_user, "create_user");
    function update_user(user_id, name, email, role, sub_account_ids, options = {}, callback2) {
      let uri = ["users", user_id];
      let params = {
        name,
        email,
        role,
        sub_account_ids
      };
      options.content_type = "json";
      return call_account_api("PUT", uri, params, callback2, options);
    }
    __name(update_user, "update_user");
    function delete_user(user_id, options = {}, callback2) {
      let uri = ["users", user_id];
      return call_account_api("DELETE", uri, {}, callback2, options);
    }
    __name(delete_user, "delete_user");
    function create_user_group(name, options = {}, callback2) {
      let uri = ["user_groups"];
      options.content_type = "json";
      let params = {
        name
      };
      return call_account_api("POST", uri, params, callback2, options);
    }
    __name(create_user_group, "create_user_group");
    function update_user_group(group_id, name, options = {}, callback2) {
      let uri = ["user_groups", group_id];
      let params = {
        name
      };
      return call_account_api("PUT", uri, params, callback2, options);
    }
    __name(update_user_group, "update_user_group");
    function delete_user_group(group_id, options = {}, callback2) {
      let uri = ["user_groups", group_id];
      return call_account_api("DELETE", uri, {}, callback2, options);
    }
    __name(delete_user_group, "delete_user_group");
    function add_user_to_group(group_id, user_id, options = {}, callback2) {
      let uri = ["user_groups", group_id, "users", user_id];
      return call_account_api("POST", uri, {}, callback2, options);
    }
    __name(add_user_to_group, "add_user_to_group");
    function remove_user_from_group(group_id, user_id, options = {}, callback2) {
      let uri = ["user_groups", group_id, "users", user_id];
      return call_account_api("DELETE", uri, {}, callback2, options);
    }
    __name(remove_user_from_group, "remove_user_from_group");
    function user_group(group_id, options = {}, callback2) {
      let uri = ["user_groups", group_id];
      return call_account_api("GET", uri, {}, callback2, options);
    }
    __name(user_group, "user_group");
    function user_groups(options = {}, callback2) {
      let uri = ["user_groups"];
      return call_account_api("GET", uri, {}, callback2, options);
    }
    __name(user_groups, "user_groups");
    function user_group_users(group_id, options = {}, callback2) {
      let uri = ["user_groups", group_id, "users"];
      return call_account_api("GET", uri, {}, callback2, options);
    }
    __name(user_group_users, "user_group_users");
    function access_keys(sub_account_id, options = {}, callback2) {
      const params = pickOnlyExistingValues({
        page_size: options.page_size,
        page: options.page,
        sort_by: options.sort_by,
        sort_order: options.sort_order
      }, "page_size", "page", "sort_by", "sort_order");
      const uri = ["sub_accounts", sub_account_id, "access_keys"];
      return call_account_api("GET", uri, params, callback2, options);
    }
    __name(access_keys, "access_keys");
    function generate_access_key(sub_account_id, options = {}, callback2) {
      const params = pickOnlyExistingValues({
        name: options.name,
        enabled: options.enabled
      }, "name", "enabled");
      options.content_type = "json";
      const uri = ["sub_accounts", sub_account_id, "access_keys"];
      return call_account_api("POST", uri, params, callback2, options);
    }
    __name(generate_access_key, "generate_access_key");
    function update_access_key(sub_account_id, api_key, options = {}, callback2) {
      const params = pickOnlyExistingValues({
        name: options.name,
        enabled: options.enabled
      }, "name", "enabled");
      options.content_type = "json";
      const uri = ["sub_accounts", sub_account_id, "access_keys", api_key];
      return call_account_api("PUT", uri, params, callback2, options);
    }
    __name(update_access_key, "update_access_key");
    function delete_access_key(sub_account_id, api_key, options = {}, callback2) {
      const uri = ["sub_accounts", sub_account_id, "access_keys", api_key];
      return call_account_api("DELETE", uri, {}, callback2, options);
    }
    __name(delete_access_key, "delete_access_key");
    function delete_access_key_by_name(sub_account_id, options = {}, callback2) {
      const params = { name: options.name };
      const uri = ["sub_accounts", sub_account_id, "access_keys"];
      return call_account_api("DELETE", uri, params, callback2, options);
    }
    __name(delete_access_key_by_name, "delete_access_key_by_name");
    module.exports = {
      sub_accounts,
      create_sub_account,
      delete_sub_account,
      sub_account,
      update_sub_account,
      user: user2,
      users: users3,
      user_group,
      user_groups,
      user_group_users,
      remove_user_from_group,
      delete_user,
      update_user_group,
      update_user,
      create_user,
      create_user_group,
      add_user_to_group,
      delete_user_group,
      access_keys,
      generate_access_key,
      update_access_key,
      delete_access_key,
      delete_access_key_by_name
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/preloaded_file.js
var require_preloaded_file = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/preloaded_file.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var PRELOADED_CLOUDINARY_PATH;
    var config2;
    var utils;
    utils = require_utils();
    config2 = require_config();
    PRELOADED_CLOUDINARY_PATH = /^([^\/]+)\/([^\/]+)\/v(\d+)\/([^#]+)#([^\/]+)$/;
    var PreloadedFile = class {
      constructor(file_info) {
        let matches, public_id_and_format;
        matches = file_info.match(PRELOADED_CLOUDINARY_PATH);
        if (!matches) {
          throw "Invalid preloaded file info";
        }
        this.resource_type = matches[1];
        this.type = matches[2];
        this.version = matches[3];
        this.filename = matches[4];
        this.signature = matches[5];
        public_id_and_format = PreloadedFile.split_format(this.filename);
        this.public_id = public_id_and_format[0];
        this.format = public_id_and_format[1];
      }
      is_valid() {
        let expected_signature;
        expected_signature = utils.api_sign_request({
          public_id: this.public_id,
          version: this.version
        }, config2().api_secret);
        return this.signature === expected_signature;
      }
      static split_format(identifier) {
        let format, last_dot, public_id;
        last_dot = identifier.lastIndexOf(".");
        if (last_dot === -1) {
          return [identifier, null];
        }
        public_id = identifier.substr(0, last_dot);
        format = identifier.substr(last_dot + 1);
        return [public_id, format];
      }
      identifier() {
        return `v${this.version}/${this.filename}`;
      }
      toString() {
        return `${this.resource_type}/${this.type}/v${this.version}/${this.filename}#${this.signature}`;
      }
      toJSON() {
        let result = {};
        Object.getOwnPropertyNames(this).forEach((key) => {
          let val = this[key];
          if (typeof val !== "function") {
            result[key] = val;
          }
        });
        return result;
      }
    };
    __name(PreloadedFile, "PreloadedFile");
    module.exports = PreloadedFile;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/generateBreakpoints.js
var require_generateBreakpoints = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/generateBreakpoints.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    function generateBreakpoints(srcset) {
      let breakpoints = srcset.breakpoints || [];
      if (breakpoints.length) {
        return breakpoints;
      }
      let [min_width, max_width, max_images] = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number);
      if ([min_width, max_width, max_images].some(Number.isNaN)) {
        throw "Either (min_width, max_width, max_images) or breakpoints must be provided to the image srcset attribute";
      }
      if (min_width > max_width) {
        throw "min_width must be less than max_width";
      }
      if (max_images <= 0) {
        throw "max_images must be a positive integer";
      } else if (max_images === 1) {
        min_width = max_width;
      }
      let stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));
      for (let current = min_width; current < max_width; current += stepSize) {
        breakpoints.push(current);
      }
      breakpoints.push(max_width);
      return breakpoints;
    }
    __name(generateBreakpoints, "generateBreakpoints");
    module.exports = generateBreakpoints;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/srcsetUtils.js
var require_srcsetUtils = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/utils/srcsetUtils.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var utils = require_utils();
    var generateBreakpoints = require_generateBreakpoints();
    var Cache = require_cache();
    var isEmpty = utils.isEmpty;
    function scaledUrl(public_id, width, transformation, options = {}) {
      let configParams = utils.extractUrlParams(options);
      transformation = transformation || options;
      configParams.raw_transformation = utils.generate_transformation_string([utils.extend({}, transformation), { crop: "scale", width }]);
      return utils.url(public_id, configParams);
    }
    __name(scaledUrl, "scaledUrl");
    function getOrGenerateBreakpoints(public_id, srcset = {}, options = {}) {
      let breakpoints = [];
      if (srcset.useCache) {
        breakpoints = Cache.get(public_id, options);
        if (!breakpoints) {
          breakpoints = [];
        }
      } else {
        breakpoints = generateBreakpoints(srcset);
      }
      return breakpoints;
    }
    __name(getOrGenerateBreakpoints, "getOrGenerateBreakpoints");
    function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {
      options = utils.clone(options);
      utils.patchFetchFormat(options);
      return breakpoints.map((width) => `${scaledUrl(public_id, width, transformation, options)} ${width}w`).join(", ");
    }
    __name(generateSrcsetAttribute, "generateSrcsetAttribute");
    function generateSizesAttribute(breakpoints = []) {
      return breakpoints.map((width) => `(max-width: ${width}px) ${width}px`).join(", ");
    }
    __name(generateSizesAttribute, "generateSizesAttribute");
    function generateImageResponsiveAttributes(publicId, attributes = {}, srcsetData = {}, options = {}) {
      let responsiveAttributes = {};
      if (isEmpty(srcsetData)) {
        return responsiveAttributes;
      }
      const generateSizes = !attributes.sizes && srcsetData.sizes === true;
      const generateSrcset = !attributes.srcset;
      if (generateSrcset || generateSizes) {
        let breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);
        if (generateSrcset) {
          let transformation = srcsetData.transformation;
          let srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);
          if (!isEmpty(srcsetAttr)) {
            responsiveAttributes.srcset = srcsetAttr;
          }
        }
        if (generateSizes) {
          let sizesAttr = generateSizesAttribute(breakpoints);
          if (!isEmpty(sizesAttr)) {
            responsiveAttributes.sizes = sizesAttr;
          }
        }
      }
      return responsiveAttributes;
    }
    __name(generateImageResponsiveAttributes, "generateImageResponsiveAttributes");
    function generateMediaAttr(options = {}) {
      let mediaQuery = [];
      if (options.min_width != null) {
        mediaQuery.push(`(min-width: ${options.min_width}px)`);
      }
      if (options.max_width != null) {
        mediaQuery.push(`(max-width: ${options.max_width}px)`);
      }
      return mediaQuery.join(" and ");
    }
    __name(generateMediaAttr, "generateMediaAttr");
    module.exports = {
      srcsetUrl: scaledUrl,
      generateSrcsetAttribute,
      generateSizesAttribute,
      generateMediaAttr,
      generateImageResponsiveAttributes
    };
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/api.js
var require_api2 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/api.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var api = require_api();
    var v1_adapters = require_utils().v1_adapters;
    v1_adapters(exports, api, {
      ping: 0,
      usage: 0,
      resource_types: 0,
      resources: 0,
      resources_by_tag: 1,
      resources_by_context: 2,
      resources_by_moderation: 2,
      resource_by_asset_id: 1,
      resources_by_asset_ids: 1,
      resources_by_ids: 1,
      resources_by_asset_folder: 1,
      resource: 1,
      restore: 1,
      update: 1,
      delete_resources: 1,
      delete_resources_by_prefix: 1,
      delete_resources_by_tag: 1,
      delete_all_resources: 0,
      delete_derived_resources: 1,
      tags: 0,
      transformations: 0,
      transformation: 1,
      delete_transformation: 1,
      update_transformation: 2,
      create_transformation: 2,
      upload_presets: 0,
      upload_preset: 1,
      delete_upload_preset: 1,
      update_upload_preset: 1,
      create_upload_preset: 0,
      root_folders: 0,
      sub_folders: 1,
      delete_folder: 1,
      rename_folder: 2,
      create_folder: 1,
      upload_mappings: 0,
      upload_mapping: 1,
      delete_upload_mapping: 1,
      update_upload_mapping: 1,
      create_upload_mapping: 1,
      list_streaming_profiles: 0,
      get_streaming_profile: 1,
      delete_streaming_profile: 1,
      update_streaming_profile: 1,
      create_streaming_profile: 1,
      publish_by_ids: 1,
      publish_by_tag: 1,
      publish_by_prefix: 1,
      update_resources_access_mode_by_prefix: 2,
      update_resources_access_mode_by_tag: 2,
      update_resources_access_mode_by_ids: 2,
      search: 1,
      search_folders: 1,
      visual_search: 1,
      delete_derived_by_transformation: 2,
      add_metadata_field: 1,
      list_metadata_fields: 1,
      delete_metadata_field: 1,
      metadata_field_by_field_id: 1,
      update_metadata_field: 2,
      update_metadata_field_datasource: 2,
      delete_datasource_entries: 2,
      restore_metadata_field_datasource: 2,
      order_metadata_field_datasource: 3,
      reorder_metadata_fields: 2,
      list_metadata_rules: 1,
      add_metadata_rule: 1,
      delete_metadata_rule: 1,
      update_metadata_rule: 2,
      add_related_assets: 2,
      add_related_assets_by_asset_id: 2,
      delete_related_assets: 2,
      delete_related_assets_by_asset_id: 2,
      config: 0
    });
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/uploader.js
var require_uploader2 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/uploader.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var uploader = require_uploader();
    var v1_adapters = require_utils().v1_adapters;
    v1_adapters(exports, uploader, {
      unsigned_upload_stream: 1,
      upload_stream: 0,
      unsigned_upload: 2,
      upload: 1,
      upload_large_part: 0,
      upload_large: 1,
      upload_chunked: 1,
      upload_chunked_stream: 0,
      explicit: 1,
      destroy: 1,
      rename: 2,
      text: 1,
      generate_sprite: 1,
      multi: 1,
      explode: 1,
      add_tag: 2,
      remove_tag: 2,
      remove_all_tags: 1,
      add_context: 2,
      remove_all_context: 1,
      replace_tag: 2,
      create_archive: 0,
      create_zip: 0,
      update_metadata: 2
    });
    exports.direct_upload = uploader.direct_upload;
    exports.upload_tag_params = uploader.upload_tag_params;
    exports.upload_url = uploader.upload_url;
    exports.image_upload_tag = uploader.image_upload_tag;
    exports.unsigned_image_upload_tag = uploader.unsigned_image_upload_tag;
    exports.create_slideshow = uploader.create_slideshow;
    exports.download_generated_sprite = uploader.download_generated_sprite;
    exports.download_multi = uploader.download_multi;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/search.js
var require_search = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/search.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var api = require_api2();
    var config2 = require_config();
    var {
      isEmpty,
      isNumber,
      compute_hash,
      build_distribution_domain,
      clear_blank,
      sort_object_by_key
    } = require_utils();
    var { base64Encode } = require_base64Encode();
    var Search = /* @__PURE__ */ __name(class Search2 {
      constructor() {
        this.query_hash = {
          sort_by: [],
          aggregate: [],
          with_field: [],
          fields: []
        };
        this._ttl = 300;
      }
      static instance() {
        return new Search2();
      }
      static expression(value) {
        return this.instance().expression(value);
      }
      static max_results(value) {
        return this.instance().max_results(value);
      }
      static next_cursor(value) {
        return this.instance().next_cursor(value);
      }
      static aggregate(value) {
        return this.instance().aggregate(value);
      }
      static with_field(value) {
        return this.instance().with_field(value);
      }
      static fields(value) {
        return this.instance().fields(value);
      }
      static sort_by(field_name, dir3 = "asc") {
        return this.instance().sort_by(field_name, dir3);
      }
      static ttl(newTtl) {
        return this.instance().ttl(newTtl);
      }
      static execute(options, callback2) {
        return this.instance().execute(options, callback2);
      }
      expression(value) {
        this.query_hash.expression = value;
        return this;
      }
      max_results(value) {
        this.query_hash.max_results = value;
        return this;
      }
      next_cursor(value) {
        this.query_hash.next_cursor = value;
        return this;
      }
      aggregate(value) {
        const found = this.query_hash.aggregate.find((v4) => v4 === value);
        if (!found) {
          this.query_hash.aggregate.push(value);
        }
        return this;
      }
      with_field(value) {
        if (Array.isArray(value)) {
          this.query_hash.with_field = this.query_hash.with_field.concat(value);
        } else {
          this.query_hash.with_field.push(value);
        }
        this.query_hash.with_field = Array.from(new Set(this.query_hash.with_field));
        return this;
      }
      fields(value) {
        if (Array.isArray(value)) {
          this.query_hash.fields = this.query_hash.fields.concat(value);
        } else {
          this.query_hash.fields.push(value);
        }
        this.query_hash.fields = Array.from(new Set(this.query_hash.fields));
        return this;
      }
      sort_by(field_name, dir3 = "desc") {
        let sort_bucket;
        sort_bucket = {};
        sort_bucket[field_name] = dir3;
        const previously_sorted_obj = this.query_hash.sort_by.find((sort_by) => sort_by[field_name]);
        if (previously_sorted_obj) {
          previously_sorted_obj[field_name] = dir3;
        } else {
          this.query_hash.sort_by.push(sort_bucket);
        }
        return this;
      }
      ttl(newTtl) {
        if (isNumber(newTtl)) {
          this._ttl = newTtl;
          return this;
        }
        throw new Error("New TTL value has to be a Number.");
      }
      to_query() {
        Object.keys(this.query_hash).forEach((k3) => {
          let v4 = this.query_hash[k3];
          if (!isNumber(v4) && isEmpty(v4)) {
            delete this.query_hash[k3];
          }
        });
        return this.query_hash;
      }
      execute(options, callback2) {
        if (callback2 === null) {
          callback2 = options;
        }
        options = options || {};
        return api.search(this.to_query(), options, callback2);
      }
      to_url(ttl, next_cursor, options = {}) {
        const apiSecret = "api_secret" in options ? options.api_secret : config2().api_secret;
        if (!apiSecret) {
          throw new Error("Must supply api_secret");
        }
        const urlTtl = ttl || this._ttl;
        const query = this.to_query();
        let urlCursor = next_cursor;
        if (query.next_cursor && !next_cursor) {
          urlCursor = query.next_cursor;
        }
        delete query.next_cursor;
        const dataOrderedByKey = sort_object_by_key(clear_blank(query));
        const encodedQuery = base64Encode(JSON.stringify(dataOrderedByKey));
        const urlPrefix = build_distribution_domain(options.source, options);
        const signature = compute_hash(`${urlTtl}${encodedQuery}${apiSecret}`, "sha256", "hex");
        const urlWithoutCursor = `${urlPrefix}/search/${signature}/${urlTtl}/${encodedQuery}`;
        return urlCursor ? `${urlWithoutCursor}/${urlCursor}` : urlWithoutCursor;
      }
    }, "Search");
    module.exports = Search;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/search_folders.js
var require_search_folders = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/search_folders.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var Search = require_search();
    var api = require_api2();
    var SearchFolders = /* @__PURE__ */ __name(class SearchFolders2 extends Search {
      constructor() {
        super();
      }
      static instance() {
        return new SearchFolders2();
      }
      execute(options, callback2) {
        if (callback2 === null) {
          callback2 = options;
        }
        options = options || {};
        return api.search_folders(this.to_query(), options, callback2);
      }
    }, "SearchFolders");
    module.exports = SearchFolders;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/index.js
var require_v2 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/v2/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var v1 = require_cloudinary();
    var api = require_api2();
    var uploader = require_uploader2();
    var search = require_search();
    var search_folders = require_search_folders();
    var v22 = {
      ...v1,
      api,
      uploader,
      search,
      search_folders
    };
    module.exports = v22;
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/cloudinary.js
var require_cloudinary = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/lib/cloudinary.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    var _5 = require_lodash();
    exports.config = require_config();
    exports.utils = require_utils();
    exports.uploader = require_uploader();
    exports.api = require_api();
    exports.analysis = require_analysis();
    var account = require_account();
    exports.provisioning = {
      account
    };
    exports.PreloadedFile = require_preloaded_file();
    exports.Cache = require_cache();
    var cloudinary2 = module.exports;
    var optionConsume = cloudinary2.utils.option_consume;
    exports.url = /* @__PURE__ */ __name(function url(public_id, options) {
      options = _5.extend({}, options);
      return cloudinary2.utils.url(public_id, options);
    }, "url");
    var { generateImageResponsiveAttributes, generateMediaAttr } = require_srcsetUtils();
    function chainTransformations(options, transformation = []) {
      let urlOptions = cloudinary2.utils.extractUrlParams(options);
      let currentTransformation = cloudinary2.utils.extractTransformationParams(options);
      transformation = cloudinary2.utils.build_array(transformation);
      urlOptions.transformation = [currentTransformation, ...transformation];
      return urlOptions;
    }
    __name(chainTransformations, "chainTransformations");
    exports.image = /* @__PURE__ */ __name(function image(source, options) {
      let localOptions = _5.extend({}, options);
      let srcsetParam = optionConsume(localOptions, "srcset");
      let attributes = optionConsume(localOptions, "attributes", {});
      let src = cloudinary2.utils.url(source, localOptions);
      if ("html_width" in localOptions)
        localOptions.width = optionConsume(localOptions, "html_width");
      if ("html_height" in localOptions)
        localOptions.height = optionConsume(localOptions, "html_height");
      let client_hints = optionConsume(localOptions, "client_hints", cloudinary2.config().client_hints);
      let responsive = optionConsume(localOptions, "responsive");
      let hidpi = optionConsume(localOptions, "hidpi");
      if ((responsive || hidpi) && !client_hints) {
        localOptions["data-src"] = src;
        let classes = [responsive ? "cld-responsive" : "cld-hidpi"];
        let current_class = optionConsume(localOptions, "class");
        if (current_class)
          classes.push(current_class);
        localOptions.class = classes.join(" ");
        src = optionConsume(localOptions, "responsive_placeholder", cloudinary2.config().responsive_placeholder);
        if (src === "blank") {
          src = cloudinary2.BLANK;
        }
      }
      let html = "<img ";
      if (src)
        html += "src='" + src + "' ";
      let responsiveAttributes = {};
      if (cloudinary2.utils.isString(srcsetParam)) {
        responsiveAttributes.srcset = srcsetParam;
      } else {
        responsiveAttributes = generateImageResponsiveAttributes(source, attributes, srcsetParam, options);
      }
      if (!cloudinary2.utils.isEmpty(responsiveAttributes)) {
        delete localOptions.width;
        delete localOptions.height;
      }
      html += cloudinary2.utils.html_attrs(_5.extend(localOptions, responsiveAttributes, attributes)) + "/>";
      return html;
    }, "image");
    exports.video = /* @__PURE__ */ __name(function video(public_id, options) {
      options = _5.extend({}, options);
      public_id = public_id.replace(/\.(mp4|ogv|webm)$/, "");
      let source_types = optionConsume(options, "source_types", []);
      let source_transformation = optionConsume(options, "source_transformation", {});
      let sources = optionConsume(options, "sources", []);
      let fallback = optionConsume(options, "fallback_content", "");
      if (source_types.length === 0)
        source_types = cloudinary2.utils.DEFAULT_VIDEO_SOURCE_TYPES;
      let video_options = _5.cloneDeep(options);
      if (video_options.hasOwnProperty("poster")) {
        if (_5.isPlainObject(video_options.poster)) {
          if (video_options.poster.hasOwnProperty("public_id")) {
            video_options.poster = cloudinary2.utils.url(video_options.poster.public_id, video_options.poster);
          } else {
            video_options.poster = cloudinary2.utils.url(public_id, _5.extend({}, cloudinary2.utils.DEFAULT_POSTER_OPTIONS, video_options.poster));
          }
        }
      } else {
        video_options.poster = cloudinary2.utils.url(public_id, _5.extend({}, cloudinary2.utils.DEFAULT_POSTER_OPTIONS, options));
      }
      if (!video_options.poster)
        delete video_options.poster;
      let html = "<video ";
      if (!video_options.hasOwnProperty("resource_type"))
        video_options.resource_type = "video";
      let multi_source_types = _5.isArray(source_types) && source_types.length > 1;
      let has_sources = _5.isArray(sources) && sources.length > 0;
      let source = public_id;
      if (!multi_source_types && !has_sources) {
        source = source + "." + cloudinary2.utils.build_array(source_types)[0];
      }
      let src = cloudinary2.utils.url(source, video_options);
      if (!multi_source_types && !has_sources)
        video_options.src = src;
      if (video_options.hasOwnProperty("html_width"))
        video_options.width = optionConsume(video_options, "html_width");
      if (video_options.hasOwnProperty("html_height"))
        video_options.height = optionConsume(video_options, "html_height");
      html = html + cloudinary2.utils.html_attrs(video_options) + ">";
      if (multi_source_types && !has_sources) {
        sources = source_types.map((source_type) => ({
          type: source_type,
          transformations: source_transformation[source_type] || {}
        }));
      }
      if (_5.isArray(sources) && sources.length > 0) {
        html += sources.map((source_data) => {
          let source_type = source_data.type;
          let codecs = source_data.codecs;
          let transformation = source_data.transformations || {};
          src = cloudinary2.utils.url(source + "." + source_type, _5.extend({ resource_type: "video" }, _5.cloneDeep(options), _5.cloneDeep(transformation)));
          return cloudinary2.utils.create_source_tag(src, source_type, codecs);
        }).join("");
      }
      return `${html}${fallback}</video>`;
    }, "video");
    exports.source = /* @__PURE__ */ __name(function source(public_id, options = {}) {
      let srcsetParam = cloudinary2.utils.extend({}, options.srcset, cloudinary2.config().srcset);
      let attributes = options.attributes || {};
      cloudinary2.utils.extend(attributes, generateImageResponsiveAttributes(public_id, attributes, srcsetParam, options));
      if (!attributes.srcset) {
        attributes.srcset = cloudinary2.url(public_id, options);
      }
      if (!attributes.media && options.media) {
        attributes.media = generateMediaAttr(options.media);
      }
      return `<source ${cloudinary2.utils.html_attrs(attributes)}>`;
    }, "source");
    exports.picture = /* @__PURE__ */ __name(function picture(public_id, options = {}) {
      let sources = options.sources || [];
      options = cloudinary2.utils.clone(options);
      delete options.sources;
      cloudinary2.utils.patchFetchFormat(options);
      return "<picture>" + sources.map((source) => {
        let sourceOptions = chainTransformations(options, source.transformation);
        sourceOptions.media = source;
        return cloudinary2.source(public_id, sourceOptions);
      }).join("") + cloudinary2.image(public_id, options) + "</picture>";
    }, "picture");
    exports.cloudinary_js_config = cloudinary2.utils.cloudinary_js_config;
    exports.CF_SHARED_CDN = cloudinary2.utils.CF_SHARED_CDN;
    exports.AKAMAI_SHARED_CDN = cloudinary2.utils.AKAMAI_SHARED_CDN;
    exports.SHARED_CDN = cloudinary2.utils.SHARED_CDN;
    exports.BLANK = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    exports.v2 = require_v2();
  }
});

// node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/cloudinary.js
var require_cloudinary2 = __commonJS({
  "node_modules/.pnpm/cloudinary@2.5.1/node_modules/cloudinary/cloudinary.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    module.exports = require_cloudinary();
  }
});

// node_modules/.pnpm/cookie@0.6.0/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/.pnpm/cookie@0.6.0/node_modules/cookie/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_process();
    init_virtual_unenv_global_polyfill_performance();
    init_virtual_unenv_global_polyfill_console();
    init_virtual_unenv_global_polyfill_set_immediate();
    init_virtual_unenv_global_polyfill_clear_immediate();
    exports.parse = parse5;
    exports.serialize = serialize3;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse5(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode5;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    __name(parse5, "parse");
    function serialize3(name, val, options) {
      var opt = options || {};
      var enc2 = opt.encode || encode5;
      if (typeof enc2 !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc2(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    __name(serialize3, "serialize");
    function decode5(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    __name(decode5, "decode");
    function encode5(val) {
      return encodeURIComponent(val);
    }
    __name(encode5, "encode");
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    __name(isDate, "isDate");
    function tryDecode(str, decode6) {
      try {
        return decode6(str);
      } catch (e2) {
        return str;
      }
    }
    __name(tryDecode, "tryDecode");
  }
});

// .wrangler/tmp/bundle-gS6WEs/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// .wrangler/tmp/bundle-gS6WEs/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/hono.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/hono-base.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/compose.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/context.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/request.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/body.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var parseBody = /* @__PURE__ */ __name(async (request3, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request3 instanceof HonoRequest ? request3.raw.headers : request3.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request3, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request3, options) {
  const formData = await request3.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    form[key] = value;
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/url.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var splitPath = /* @__PURE__ */ __name((path2) => {
  const paths = path2.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path: path2 } = extractGroupsFromPath(routePath);
  const paths = splitPath(path2);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path2) => {
  const groups = [];
  path2 = path2.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path: path2 };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i3 = groups.length - 1; i3 >= 0; i3--) {
    const [mark] = groups[i3];
    for (let j3 = paths.length - 1; j3 >= 0; j3--) {
      if (paths[j3].includes(mark)) {
        paths[j3] = paths[j3].replace(mark, groups[i3][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
}, "getPattern");
var tryDecodeURI = /* @__PURE__ */ __name((str) => {
  try {
    return decodeURI(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decodeURI(match);
      } catch {
        return match;
      }
    });
  }
}, "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request3) => {
  const url = request3.url;
  const start = url.indexOf("/", 8);
  let i3 = start;
  for (; i3 < url.length; i3++) {
    const charCode = url.charCodeAt(i3);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i3);
      const path2 = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path2.includes("%25") ? path2.replace(/%25/g, "%2525") : path2);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i3);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request3) => {
  const result = getPath(request3);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((...paths) => {
  let p5 = "";
  let endsWithSlash = false;
  for (let path2 of paths) {
    if (p5[p5.length - 1] === "/") {
      p5 = p5.slice(0, -1);
      endsWithSlash = true;
    }
    if (path2[0] !== "/") {
      path2 = `/${path2}`;
    }
    if (path2 === "/" && endsWithSlash) {
      p5 = `${p5}/`;
    } else if (path2 !== "/") {
      p5 = `${p5}${path2}`;
    }
    if (path2 === "/" && p5 === "") {
      p5 = "/";
    }
  }
  return p5;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path2) => {
  if (!path2.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path2.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v4, i3, a4) => a4.indexOf(v4) === i3);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/request.js
var HonoRequest = /* @__PURE__ */ __name(class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request3, path2 = "/", matchResult = [[]]) {
    this.raw = request3;
    this.path = path2;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.getDecodedParam(key) : this.getAllDecodedParams();
  }
  getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.getParamValue(paramKey);
    return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : void 0;
  }
  getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? decodeURIComponent_(value) : value;
      }
    }
    return decoded;
  }
  getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name.toLowerCase()) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  cachedBody = (key) => {
    const { bodyCache, raw: raw3 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw3[key]();
  };
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
}, "HonoRequest");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/html.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c4) => c4({ phase, buffer, context: context2 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = /* @__PURE__ */ __name((headers, map2 = {}) => {
  Object.entries(map2).forEach(([key, value]) => headers.set(key, value));
  return headers;
}, "setHeaders");
var Context = /* @__PURE__ */ __name(class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status = 200;
  #executionCtx;
  #headers;
  #preparedHeaders;
  #res;
  #isFresh = true;
  #layout;
  #renderer;
  #notFoundHandler;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this.#isFresh = false;
    return this.#res ||= new Response("404 Not Found", { status: 404 });
  }
  set res(_res) {
    this.#isFresh = false;
    if (this.#res && _res) {
      try {
        for (const [k3, v4] of this.#res.headers.entries()) {
          if (k3 === "content-type") {
            continue;
          }
          if (k3 === "set-cookie") {
            const cookies = this.#res.headers.getSetCookie();
            _res.headers.delete("set-cookie");
            for (const cookie of cookies) {
              _res.headers.append("set-cookie", cookie);
            }
          } else {
            _res.headers.set(k3, v4);
          }
        }
      } catch (e2) {
        if (e2 instanceof TypeError && e2.message.includes("immutable")) {
          this.res = new Response(_res.body, {
            headers: _res.headers,
            status: _res.status
          });
          return;
        } else {
          throw e2;
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (value === void 0) {
      if (this.#headers) {
        this.#headers.delete(name);
      } else if (this.#preparedHeaders) {
        delete this.#preparedHeaders[name.toLocaleLowerCase()];
      }
      if (this.finalized) {
        this.res.headers.delete(name);
      }
      return;
    }
    if (options?.append) {
      if (!this.#headers) {
        this.#isFresh = false;
        this.#headers = new Headers(this.#preparedHeaders);
        this.#preparedHeaders = {};
      }
      this.#headers.append(name, value);
    } else {
      if (this.#headers) {
        this.#headers.set(name, value);
      } else {
        this.#preparedHeaders ??= {};
        this.#preparedHeaders[name.toLowerCase()] = value;
      }
    }
    if (this.finalized) {
      if (options?.append) {
        this.res.headers.append(name, value);
      } else {
        this.res.headers.set(name, value);
      }
    }
  };
  status = (status) => {
    this.#isFresh = false;
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : void 0;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  newResponse = (data, arg, headers) => {
    if (this.#isFresh && !headers && !arg && this.#status === 200) {
      return new Response(data, {
        headers: this.#preparedHeaders
      });
    }
    if (arg && typeof arg !== "number") {
      const header = new Headers(arg.headers);
      if (this.#headers) {
        this.#headers.forEach((v4, k3) => {
          if (k3 === "set-cookie") {
            header.append(k3, v4);
          } else {
            header.set(k3, v4);
          }
        });
      }
      const headers2 = setHeaders(header, this.#preparedHeaders);
      return new Response(data, {
        headers: headers2,
        status: arg.status ?? this.#status
      });
    }
    const status = typeof arg === "number" ? arg : this.#status;
    this.#preparedHeaders ??= {};
    this.#headers ??= new Headers();
    setHeaders(this.#headers, this.#preparedHeaders);
    if (this.#res) {
      this.#res.headers.forEach((v4, k3) => {
        if (k3 === "set-cookie") {
          this.#headers?.append(k3, v4);
        } else {
          this.#headers?.set(k3, v4);
        }
      });
      setHeaders(this.#headers, this.#preparedHeaders);
    }
    headers ??= {};
    for (const [k3, v4] of Object.entries(headers)) {
      if (typeof v4 === "string") {
        this.#headers.set(k3, v4);
      } else {
        this.#headers.delete(k3);
        for (const v22 of v4) {
          this.#headers.append(k3, v22);
        }
      }
    }
    return new Response(data, {
      status,
      headers: this.#headers
    });
  };
  body = (data, arg, headers) => {
    return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
  };
  text = (text2, arg, headers) => {
    if (!this.#preparedHeaders) {
      if (this.#isFresh && !headers && !arg) {
        return new Response(text2);
      }
      this.#preparedHeaders = {};
    }
    this.#preparedHeaders["content-type"] = TEXT_PLAIN;
    return typeof arg === "number" ? this.newResponse(text2, arg, headers) : this.newResponse(text2, arg);
  };
  json = (object, arg, headers) => {
    const body = JSON.stringify(object);
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "application/json; charset=UTF-8";
    return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
  };
  html = (html, arg, headers) => {
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "text/html; charset=UTF-8";
    if (typeof html === "object") {
      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html2) => {
        return typeof arg === "number" ? this.newResponse(html2, arg, headers) : this.newResponse(html2, arg);
      });
    }
    return typeof arg === "number" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);
  };
  redirect = (location, status) => {
    this.#headers ??= new Headers();
    this.#headers.set("Location", location);
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  };
}, "Context");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/compose.js
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context2, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i3) {
      if (i3 <= index) {
        throw new Error("next() called multiple times");
      }
      index = i3;
      let res;
      let isError = false;
      let handler;
      if (middleware[i3]) {
        handler = middleware[i3][0][0];
        if (context2 instanceof Context) {
          context2.req.routeIndex = i3;
        }
      } else {
        handler = i3 === middleware.length && next || void 0;
      }
      if (!handler) {
        if (context2 instanceof Context && context2.finalized === false && onNotFound) {
          res = await onNotFound(context2);
        }
      } else {
        try {
          res = await handler(context2, () => {
            return dispatch(i3 + 1);
          });
        } catch (err) {
          if (err instanceof Error && context2 instanceof Context && onError) {
            context2.error = err;
            res = await onError(err, context2);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (res && (context2.finalized === false || isError)) {
        context2.res = res;
      }
      return context2;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = /* @__PURE__ */ __name(class extends Error {
}, "UnsupportedPathError");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/hono-base.js
var COMPOSED_HANDLER = Symbol("composedHandler");
var notFoundHandler = /* @__PURE__ */ __name((c4) => {
  return c4.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c4) => {
  if ("getResponse" in err) {
    return err.getResponse();
  }
  console.error(err);
  return c4.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = /* @__PURE__ */ __name(class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.#path, handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path2, ...handlers) => {
      for (const p5 of [path2].flat()) {
        this.#path = p5;
        for (const m5 of [method].flat()) {
          handlers.map((handler) => {
            this.addRoute(m5.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path2, app2) {
    const subApp = this.basePath(path2);
    app2.routes.map((r3) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r3.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c4, next) => (await compose([], app2.errorHandler)(c4, () => r3.handler(c4, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r3.handler;
      }
      subApp.addRoute(r3.method, r3.path, handler);
    });
    return this;
  }
  basePath(path2) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path2);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.notFoundHandler = handler;
    return this;
  };
  mount(path2, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        replaceRequest = options.replaceRequest;
      }
    }
    const getOptions = optionHandler ? (c4) => {
      const options2 = optionHandler(c4);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c4) => {
      let executionContext = void 0;
      try {
        executionContext = c4.executionCtx;
      } catch {
      }
      return [c4.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path2);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request3) => {
        const url = new URL(request3.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request3);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c4, next) => {
      const res = await applicationHandler(replaceRequest(c4.req.raw), ...getOptions(c4));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.addRoute(METHOD_NAME_ALL, mergePath(path2, "*"), handler);
    return this;
  }
  addRoute(method, path2, handler) {
    method = method.toUpperCase();
    path2 = mergePath(this._basePath, path2);
    const r3 = { path: path2, method, handler };
    this.router.add(method, path2, [handler, r3]);
    this.routes.push(r3);
  }
  matchRoute(method, path2) {
    return this.router.match(method, path2);
  }
  handleError(err, c4) {
    if (err instanceof Error) {
      return this.errorHandler(err, c4);
    }
    throw err;
  }
  dispatch(request3, executionCtx, env4, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request3, executionCtx, env4, "GET")))();
    }
    const path2 = this.getPath(request3, { env: env4 });
    const matchResult = this.matchRoute(method, path2);
    const c4 = new Context(request3, {
      path: path2,
      matchResult,
      env: env4,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c4, async () => {
          c4.res = await this.notFoundHandler(c4);
        });
      } catch (err) {
        return this.handleError(err, c4);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c4.finalized ? c4.res : this.notFoundHandler(c4))
      ).catch((err) => this.handleError(err, c4)) : res ?? this.notFoundHandler(c4);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const context2 = await composed(c4);
        if (!context2.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context2.res;
      } catch (err) {
        return this.handleError(err, c4);
      }
    })();
  }
  fetch = (request3, ...rest) => {
    return this.dispatch(request3, rest[1], rest[0], request3.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      if (requestInit !== void 0) {
        input = new Request(input, requestInit);
      }
      return this.fetch(input, Env, executionCtx);
    }
    input = input.toString();
    const path2 = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
    const req = new Request(path2, requestInit);
    return this.fetch(req, Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));
    });
  };
}, "Hono");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/reg-exp-router/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/reg-exp-router/router.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/reg-exp-router/node.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a4, b3) {
  if (a4.length === 1) {
    return b3.length === 1 ? a4 < b3 ? -1 : 1 : -1;
  }
  if (b3.length === 1) {
    return 1;
  }
  if (a4 === ONLY_WILDCARD_REG_EXP_STR || a4 === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b3 === ONLY_WILDCARD_REG_EXP_STR || b3 === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a4 === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b3 === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a4.length === b3.length ? a4 < b3 ? -1 : 1 : b3.length - a4.length;
}
__name(compareKey, "compareKey");
var Node = /* @__PURE__ */ __name(class {
  index;
  varIndex;
  children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context2, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some(
          (k3) => k3 !== ONLY_WILDCARD_REG_EXP_STR && k3 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node();
        if (name !== "") {
          node.varIndex = context2.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some(
          (k3) => k3.length > 1 && k3 !== ONLY_WILDCARD_REG_EXP_STR && k3 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context2, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k3) => {
      const c4 = this.children[k3];
      return (typeof c4.varIndex === "number" ? `(${k3})@${c4.varIndex}` : regExpMetaChars.has(k3) ? `\\${k3}` : k3) + c4.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
}, "Node");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/reg-exp-router/trie.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var Trie = /* @__PURE__ */ __name(class {
  context = { varIndex: 0 };
  root = new Node();
  insert(path2, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i3 = 0; ; ) {
      let replaced = false;
      path2 = path2.replace(/\{[^}]+\}/g, (m5) => {
        const mark = `@\\${i3}`;
        groups[i3] = [mark, m5];
        i3++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path2.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i3 = groups.length - 1; i3 >= 0; i3--) {
      const [mark] = groups[i3];
      for (let j3 = tokens.length - 1; j3 >= 0; j3--) {
        if (tokens[j3].indexOf(mark) !== -1) {
          tokens[j3] = tokens[j3].replace(mark, groups[i3][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_5, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
}, "Trie");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path2) {
  return wildcardRegExpCache[path2] ??= new RegExp(
    path2 === "*" ? "" : `^${path2.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_5, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes2) {
  const trie = new Trie();
  const handlerData = [];
  if (routes2.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes2.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i3 = 0, j3 = -1, len = routesWithStaticPathFlag.length; i3 < len; i3++) {
    const [pathErrorCheckOnly, path2, handlers] = routesWithStaticPathFlag[i3];
    if (pathErrorCheckOnly) {
      staticMap[path2] = [handlers.map(([h2]) => [h2, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j3++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path2, j3, pathErrorCheckOnly);
    } catch (e2) {
      throw e2 === PATH_ERROR ? new UnsupportedPathError(path2) : e2;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j3] = handlers.map(([h2, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h2, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i3 = 0, len = handlerData.length; i3 < len; i3++) {
    for (let j3 = 0, len2 = handlerData[i3].length; j3 < len2; j3++) {
      const map2 = handlerData[i3][j3]?.[1];
      if (!map2) {
        continue;
      }
      const keys = Object.keys(map2);
      for (let k3 = 0, len3 = keys.length; k3 < len3; k3++) {
        map2[keys[k3]] = paramReplacementMap[map2[keys[k3]]];
      }
    }
  }
  const handlerMap = [];
  for (const i3 in indexReplacementMap) {
    handlerMap[i3] = handlerData[indexReplacementMap[i3]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path2) {
  if (!middleware) {
    return void 0;
  }
  for (const k3 of Object.keys(middleware).sort((a4, b3) => b3.length - a4.length)) {
    if (buildWildcardRegExp(k3).test(path2)) {
      return [...middleware[k3]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = /* @__PURE__ */ __name(class {
  name = "RegExpRouter";
  middleware;
  routes;
  constructor() {
    this.middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path2, handler) {
    const { middleware, routes: routes2 } = this;
    if (!middleware || !routes2) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes2].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p5) => {
          handlerMap[method][p5] = [...handlerMap[METHOD_NAME_ALL][p5]];
        });
      });
    }
    if (path2 === "/*") {
      path2 = "*";
    }
    const paramCount = (path2.match(/\/:/g) || []).length;
    if (/\*$/.test(path2)) {
      const re = buildWildcardRegExp(path2);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m5) => {
          middleware[m5][path2] ||= findMiddleware(middleware[m5], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || [];
        });
      } else {
        middleware[method][path2] ||= findMiddleware(middleware[method], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || [];
      }
      Object.keys(middleware).forEach((m5) => {
        if (method === METHOD_NAME_ALL || method === m5) {
          Object.keys(middleware[m5]).forEach((p5) => {
            re.test(p5) && middleware[m5][p5].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes2).forEach((m5) => {
        if (method === METHOD_NAME_ALL || method === m5) {
          Object.keys(routes2[m5]).forEach(
            (p5) => re.test(p5) && routes2[m5][p5].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path2) || [path2];
    for (let i3 = 0, len = paths.length; i3 < len; i3++) {
      const path22 = paths[i3];
      Object.keys(routes2).forEach((m5) => {
        if (method === METHOD_NAME_ALL || method === m5) {
          routes2[m5][path22] ||= [
            ...findMiddleware(middleware[m5], path22) || findMiddleware(middleware[METHOD_NAME_ALL], path22) || []
          ];
          routes2[m5][path22].push([handler, paramCount - len + i3 + 1]);
        }
      });
    }
  }
  match(method, path2) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path22) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path22];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path22.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path2);
  }
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    [...Object.keys(this.routes), ...Object.keys(this.middleware)].forEach((method) => {
      matchers[method] ||= this.buildMatcher(method);
    });
    this.middleware = this.routes = void 0;
    return matchers;
  }
  buildMatcher(method) {
    const routes2 = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r3) => {
      const ownRoute = r3[method] ? Object.keys(r3[method]).map((path2) => [path2, r3[method][path2]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes2.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes2.push(
          ...Object.keys(r3[METHOD_NAME_ALL]).map((path2) => [path2, r3[METHOD_NAME_ALL][path2]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes2);
    }
  }
}, "RegExpRouter");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/smart-router/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/smart-router/router.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var SmartRouter = /* @__PURE__ */ __name(class {
  name = "SmartRouter";
  routers = [];
  routes = [];
  constructor(init3) {
    Object.assign(this, init3);
  }
  add(method, path2, handler) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.routes.push([method, path2, handler]);
  }
  match(method, path2) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes: routes2 } = this;
    const len = routers.length;
    let i3 = 0;
    let res;
    for (; i3 < len; i3++) {
      const router = routers[i3];
      try {
        routes2.forEach((args) => {
          router.add(...args);
        });
        res = router.match(method, path2);
      } catch (e2) {
        if (e2 instanceof UnsupportedPathError) {
          continue;
        }
        throw e2;
      }
      this.match = router.match.bind(router);
      this.routers = [router];
      this.routes = void 0;
      break;
    }
    if (i3 === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
}, "SmartRouter");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/trie-router/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/trie-router/router.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/trie-router/node.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var Node2 = /* @__PURE__ */ __name(class {
  methods;
  children;
  patterns;
  order = 0;
  name;
  params = /* @__PURE__ */ Object.create(null);
  constructor(method, handler, children) {
    this.children = children || /* @__PURE__ */ Object.create(null);
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m5 = /* @__PURE__ */ Object.create(null);
      m5[method] = { handler, possibleKeys: [], score: 0, name: this.name };
      this.methods = [m5];
    }
    this.patterns = [];
  }
  insert(method, path2, handler) {
    this.name = `${method} ${path2}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path2);
    const possibleKeys = [];
    for (let i3 = 0, len = parts.length; i3 < len; i3++) {
      const p5 = parts[i3];
      if (Object.keys(curNode.children).includes(p5)) {
        curNode = curNode.children[p5];
        const pattern2 = getPattern(p5);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.children[p5] = new Node2();
      const pattern = getPattern(p5);
      if (pattern) {
        curNode.patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.children[p5];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m5 = /* @__PURE__ */ Object.create(null);
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v4, i3, a4) => a4.indexOf(v4) === i3),
      name: this.name,
      score: this.order
    };
    m5[method] = handlerSet;
    curNode.methods.push(m5);
    return curNode;
  }
  gHSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i3 = 0, len = node.methods.length; i3 < len; i3++) {
      const m5 = node.methods[i3];
      const handlerSet = m5[method] || m5[METHOD_NAME_ALL];
      const processedSet = /* @__PURE__ */ Object.create(null);
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSet.possibleKeys.forEach((key) => {
          const processed = processedSet[handlerSet.name];
          handlerSet.params[key] = params[key] && !processed ? params[key] : nodeParams[key] ?? params[key];
          processedSet[handlerSet.name] = true;
        });
        handlerSets.push(handlerSet);
      }
    }
    return handlerSets;
  }
  search(method, path2) {
    const handlerSets = [];
    this.params = /* @__PURE__ */ Object.create(null);
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path2);
    for (let i3 = 0, len = parts.length; i3 < len; i3++) {
      const part = parts[i3];
      const isLast = i3 === len - 1;
      const tempNodes = [];
      for (let j3 = 0, len2 = curNodes.length; j3 < len2; j3++) {
        const node = curNodes[j3];
        const nextNode = node.children[part];
        if (nextNode) {
          nextNode.params = node.params;
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(
                ...this.gHSets(nextNode.children["*"], method, node.params, /* @__PURE__ */ Object.create(null))
              );
            }
            handlerSets.push(...this.gHSets(nextNode, method, node.params, /* @__PURE__ */ Object.create(null)));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k3 = 0, len3 = node.patterns.length; k3 < len3; k3++) {
          const pattern = node.patterns[k3];
          const params = { ...node.params };
          if (pattern === "*") {
            const astNode = node.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method, node.params, /* @__PURE__ */ Object.create(null)));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.children[key];
          const restPathString = parts.slice(i3).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name] = restPathString;
            handlerSets.push(...this.gHSets(child, method, node.params, params));
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              params[name] = part;
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child, method, params, node.params));
                if (child.children["*"]) {
                  handlerSets.push(...this.gHSets(child.children["*"], method, params, node.params));
                }
              } else {
                child.params = params;
                tempNodes.push(child);
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const results = handlerSets.sort((a4, b3) => {
      return a4.score - b3.score;
    });
    return [results.map(({ handler, params }) => [handler, params])];
  }
}, "Node");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = /* @__PURE__ */ __name(class {
  name = "TrieRouter";
  node;
  constructor() {
    this.node = new Node2();
  }
  add(method, path2, handler) {
    const results = checkOptionalParameter(path2);
    if (results) {
      for (const p5 of results) {
        this.node.insert(method, p5, handler);
      }
      return;
    }
    this.node.insert(method, path2, handler);
  }
  match(method, path2) {
    return this.node.search(method, path2);
  }
}, "TrieRouter");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/hono.js
var Hono2 = /* @__PURE__ */ __name(class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
}, "Hono");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/logger/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/color.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function getColorEnabled() {
  const { process: process3, Deno: Deno2 } = globalThis;
  const isNoColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : typeof process3 !== "undefined" ? "NO_COLOR" in process3?.env : false;
  return !isNoColor;
}
__name(getColorEnabled, "getColorEnabled");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/logger/index.js
var humanize = /* @__PURE__ */ __name((times) => {
  const [delimiter2, separator] = [",", "."];
  const orderTimes = times.map((v4) => v4.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter2));
  return orderTimes.join(separator);
}, "humanize");
var time3 = /* @__PURE__ */ __name((start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1e3 ? delta + "ms" : Math.round(delta / 1e3) + "s"]);
}, "time");
var colorStatus = /* @__PURE__ */ __name((status) => {
  const colorEnabled = getColorEnabled();
  const out = {
    7: colorEnabled ? `\x1B[35m${status}\x1B[0m` : `${status}`,
    5: colorEnabled ? `\x1B[31m${status}\x1B[0m` : `${status}`,
    4: colorEnabled ? `\x1B[33m${status}\x1B[0m` : `${status}`,
    3: colorEnabled ? `\x1B[36m${status}\x1B[0m` : `${status}`,
    2: colorEnabled ? `\x1B[32m${status}\x1B[0m` : `${status}`,
    1: colorEnabled ? `\x1B[32m${status}\x1B[0m` : `${status}`,
    0: colorEnabled ? `\x1B[33m${status}\x1B[0m` : `${status}`
  };
  const calculateStatus = status / 100 | 0;
  return out[calculateStatus];
}, "colorStatus");
function log3(fn3, prefix, method, path2, status = 0, elapsed) {
  const out = prefix === "<--" ? `${prefix} ${method} ${path2}` : `${prefix} ${method} ${path2} ${colorStatus(status)} ${elapsed}`;
  fn3(out);
}
__name(log3, "log");
var logger = /* @__PURE__ */ __name((fn3 = console.log) => {
  return /* @__PURE__ */ __name(async function logger2(c4, next) {
    const { method } = c4.req;
    const path2 = getPath(c4.req.raw);
    log3(fn3, "<--", method, path2);
    const start = Date.now();
    await next();
    log3(fn3, "-->", method, path2, c4.res.status, time3(start));
  }, "logger2");
}, "logger");

// node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/config.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
(function() {
  require_main().config(
    Object.assign(
      {},
      require_env_options(),
      require_cli_options()(process.argv)
    )
  );
})();

// src/routes/product.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/zodSchema/productSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-zod@0.5.1_drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+ser_jnmio6bwm5hfuuz4iqe4ayique/node_modules/drizzle-zod/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/alias.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/column.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/entity.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type2) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type2) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type2, entityKind)) {
    throw new Error(
      `Class "${type2.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type2[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
__name(is, "is");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/column.js
var _a;
var Column = class {
  constructor(table3, config2) {
    this.table = table3;
    this.config = config2;
    this.name = config2.name;
    this.notNull = config2.notNull;
    this.default = config2.default;
    this.defaultFn = config2.defaultFn;
    this.onUpdateFn = config2.onUpdateFn;
    this.hasDefault = config2.hasDefault;
    this.primary = config2.primaryKey;
    this.isUnique = config2.isUnique;
    this.uniqueName = config2.uniqueName;
    this.uniqueType = config2.uniqueType;
    this.dataType = config2.dataType;
    this.columnType = config2.columnType;
    this.generated = config2.generated;
    this.generatedIdentity = config2.generatedIdentity;
  }
  name;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  generated = void 0;
  generatedIdentity = void 0;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  // ** @internal */
  shouldDisableInsert() {
    return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
  }
};
__name(Column, "Column");
_a = entityKind;
__publicField(Column, _a, "Column");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sql/sql.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/enum.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/column-builder.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a2;
var ColumnBuilder = class {
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType,
      generated: void 0
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn3) {
    this.config.defaultFn = fn3;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a dynamic update value to the column.
   * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
   * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $onUpdateFn(fn3) {
    this.config.onUpdateFn = fn3;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $onUpdateFn}.
   */
  $onUpdate = this.$onUpdateFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
};
__name(ColumnBuilder, "ColumnBuilder");
_a2 = entityKind;
__publicField(ColumnBuilder, _a2, "ColumnBuilder");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/foreign-keys.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/table.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/table.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var _a3;
var Table = class {
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [(_a3 = entityKind, TableName)];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema];
  /** @internal */
  [Columns];
  /** @internal */
  [ExtraConfigColumns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [IsDrizzleTable] = true;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
};
__name(Table, "Table");
__publicField(Table, _a3, "Table");
/** @internal */
__publicField(Table, "Symbol", {
  Name: TableName,
  Schema,
  OriginalName,
  Columns,
  ExtraConfigColumns,
  BaseName,
  IsAlias,
  ExtraConfigBuilder
});
function getTableName(table3) {
  return table3[TableName];
}
__name(getTableName, "getTableName");
function getTableUniqueName(table3) {
  return `${table3[Schema] ?? "public"}.${table3[TableName]}`;
}
__name(getTableUniqueName, "getTableUniqueName");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var _a4;
var PgTable = class extends Table {
  /**@internal */
  [(_a4 = entityKind, InlineForeignKeys)] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__name(PgTable, "PgTable");
__publicField(PgTable, _a4, "PgTable");
/** @internal */
__publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys
}));
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const builtColumnsForExtraConfig = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.buildExtraConfigColumn(rawTable);
      return [name2, column];
    })
  );
  const table3 = Object.assign(rawTable, builtColumns);
  table3[Table.Symbol.Columns] = builtColumns;
  table3[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table3[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table3;
}
__name(pgTableWithSchema, "pgTableWithSchema");
var pgTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, void 0);
}, "pgTable");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/foreign-keys.js
var _a5;
var ForeignKeyBuilder = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config2, actions2) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config2();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions2) {
      this._onUpdate = actions2.onUpdate;
      this._onDelete = actions2.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table3) {
    return new ForeignKey(table3, this);
  }
};
__name(ForeignKeyBuilder, "ForeignKeyBuilder");
_a5 = entityKind;
__publicField(ForeignKeyBuilder, _a5, "PgForeignKeyBuilder");
var _a6;
var ForeignKey = class {
  constructor(table3, builder) {
    this.table = table3;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
__name(ForeignKey, "ForeignKey");
_a6 = entityKind;
__publicField(ForeignKey, _a6, "PgForeignKey");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/tracing-utils.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function iife(fn3, ...args) {
  return fn3(...args);
}
__name(iife, "iife");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/unique-constraint.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function uniqueKeyName(table3, columns) {
  return `${table3[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName, "uniqueKeyName");
var _a7;
var UniqueConstraintBuilder = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table3) {
    return new UniqueConstraint(table3, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
__name(UniqueConstraintBuilder, "UniqueConstraintBuilder");
_a7 = entityKind;
__publicField(UniqueConstraintBuilder, _a7, "PgUniqueConstraintBuilder");
var _a8;
var UniqueOnConstraintBuilder = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
__name(UniqueOnConstraintBuilder, "UniqueOnConstraintBuilder");
_a8 = entityKind;
__publicField(UniqueOnConstraintBuilder, _a8, "PgUniqueOnConstraintBuilder");
var _a9;
var UniqueConstraint = class {
  constructor(table3, columns, nullsNotDistinct, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};
__name(UniqueConstraint, "UniqueConstraint");
_a9 = entityKind;
__publicField(UniqueConstraint, _a9, "PgUniqueConstraint");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/utils/array.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i3 = startFrom; i3 < arrayString.length; i3++) {
    const char = arrayString[i3];
    if (char === "\\") {
      i3++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i3).replace(/\\/g, ""), i3 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i3).replace(/\\/g, ""), i3];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
__name(parsePgArrayValue, "parsePgArrayValue");
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i3 = startFrom;
  let lastCharIsComma = false;
  while (i3 < arrayString.length) {
    const char = arrayString[i3];
    if (char === ",") {
      if (lastCharIsComma || i3 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i3++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i3 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i3 + 1, true);
      result.push(value2);
      i3 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i3 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i3 + 1);
      result.push(value2);
      i3 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i3, false);
    result.push(value);
    i3 = newStartFrom;
  }
  return [result, i3];
}
__name(parsePgNestedArray, "parsePgNestedArray");
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
__name(parsePgArray, "parsePgArray");
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
__name(makePgArray, "makePgArray");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/common.js
var _a10;
var PgColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions2 = {}) {
    this.foreignKeyConfigs.push({ ref, actions: actions2 });
    return this;
  }
  unique(name, config2) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config2?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table3) {
    return this.foreignKeyConfigs.map(({ ref, actions: actions2 }) => {
      return iife(
        (ref2, actions22) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions22.onUpdate) {
            builder.onUpdate(actions22.onUpdate);
          }
          if (actions22.onDelete) {
            builder.onDelete(actions22.onDelete);
          }
          return builder.build(table3);
        },
        ref,
        actions2
      );
    });
  }
  /** @internal */
  buildExtraConfigColumn(table3) {
    return new ExtraConfigColumn(table3, this.config);
  }
};
__name(PgColumnBuilder, "PgColumnBuilder");
_a10 = entityKind;
__publicField(PgColumnBuilder, _a10, "PgColumnBuilder");
var _a11;
var PgColumn = class extends Column {
  constructor(table3, config2) {
    if (!config2.uniqueName) {
      config2.uniqueName = uniqueKeyName(table3, [config2.name]);
    }
    super(table3, config2);
    this.table = table3;
  }
};
__name(PgColumn, "PgColumn");
_a11 = entityKind;
__publicField(PgColumn, _a11, "PgColumn");
var _a12;
var ExtraConfigColumn = class extends PgColumn {
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: void 0
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  /**
   * ### PostgreSQL documentation quote
   *
   * > An operator class with optional parameters can be specified for each column of an index.
   * The operator class identifies the operators to be used by the index for that column.
   * For example, a B-tree index on four-byte integers would use the int4_ops class;
   * this operator class includes comparison functions for four-byte integers.
   * In practice the default operator class for the column's data type is usually sufficient.
   * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
   * For example, we might want to sort a complex-number data type either by absolute value or by real part.
   * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
   * More information about operator classes check:
   *
   * ### Useful links
   * https://www.postgresql.org/docs/current/sql-createindex.html
   *
   * https://www.postgresql.org/docs/current/indexes-opclass.html
   *
   * https://www.postgresql.org/docs/current/xindex.html
   *
   * ### Additional types
   * If you have the `pg_vector` extension installed in your database, you can use the
   * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
   *
   * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
   *
   * @param opClass
   * @returns
   */
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
};
__name(ExtraConfigColumn, "ExtraConfigColumn");
_a12 = entityKind;
__publicField(ExtraConfigColumn, _a12, "ExtraConfigColumn");
var _a13;
var IndexedColumn = class {
  constructor(name, type2, indexConfig) {
    this.name = name;
    this.type = type2;
    this.indexConfig = indexConfig;
  }
  name;
  type;
  indexConfig;
};
__name(IndexedColumn, "IndexedColumn");
_a13 = entityKind;
__publicField(IndexedColumn, _a13, "IndexedColumn");
var _a14;
var PgArrayBuilder = class extends PgColumnBuilder {
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table3) {
    const baseColumn = this.config.baseBuilder.build(table3);
    return new PgArray(
      table3,
      this.config,
      baseColumn
    );
  }
};
__name(PgArrayBuilder, "PgArrayBuilder");
_a14 = entityKind;
__publicField(PgArrayBuilder, _a14, "PgArrayBuilder");
var _a15;
var _PgArray = class extends PgColumn {
  constructor(table3, config2, baseColumn, range) {
    super(table3, config2);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config2.size;
  }
  size;
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v4) => this.baseColumn.mapFromDriverValue(v4));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a4 = value.map(
      (v4) => v4 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v4, true) : this.baseColumn.mapToDriverValue(v4)
    );
    if (isNestedArray)
      return a4;
    return makePgArray(a4);
  }
};
var PgArray = _PgArray;
__name(PgArray, "PgArray");
_a15 = entityKind;
__publicField(PgArray, _a15, "PgArray");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/enum.js
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
__name(isPgEnum, "isPgEnum");
var _a16;
var PgEnumColumnBuilder = class extends PgColumnBuilder {
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table3) {
    return new PgEnumColumn(
      table3,
      this.config
    );
  }
};
__name(PgEnumColumnBuilder, "PgEnumColumnBuilder");
_a16 = entityKind;
__publicField(PgEnumColumnBuilder, _a16, "PgEnumColumnBuilder");
var _a17;
var PgEnumColumn = class extends PgColumn {
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table3, config2) {
    super(table3, config2);
    this.enum = config2.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
__name(PgEnumColumn, "PgEnumColumn");
_a17 = entityKind;
__publicField(PgEnumColumn, _a17, "PgEnumColumn");
function pgEnum(enumName, values) {
  return pgEnumWithSchema(enumName, values, void 0);
}
__name(pgEnum, "pgEnum");
function pgEnumWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign(
    (name) => new PgEnumColumnBuilder(name, enumInstance),
    {
      enumName,
      enumValues: values,
      schema,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}
__name(pgEnumWithSchema, "pgEnumWithSchema");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/subquery.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a18;
var Subquery = class {
  constructor(sql3, selection, alias3, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql: sql3,
      selectedFields: selection,
      alias: alias3,
      isWith
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
__name(Subquery, "Subquery");
_a18 = entityKind;
__publicField(Subquery, _a18, "Subquery");
var _a19;
var WithSubquery = class extends Subquery {
};
__name(WithSubquery, "WithSubquery");
_a19 = entityKind;
__publicField(WithSubquery, _a19, "WithSubquery");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/tracing.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/version.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var version3 = "0.33.0";

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn3) {
    if (!otel) {
      return fn3();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version3);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span) => {
          try {
            return fn3(span);
          } catch (e2) {
            span.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e2 instanceof Error ? e2.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e2;
          } finally {
            span.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/view-common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sql/sql.js
var _a20;
var FakePrimitiveParam = class {
};
__name(FakePrimitiveParam, "FakePrimitiveParam");
_a20 = entityKind;
__publicField(FakePrimitiveParam, _a20, "FakePrimitiveParam");
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
__name(isSQLWrapper, "isSQLWrapper");
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
__name(mergeQueries, "mergeQueries");
var _a21;
var StringChunk = class {
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
__name(StringChunk, "StringChunk");
_a21 = entityKind;
__publicField(StringChunk, _a21, "StringChunk");
var _a22;
var _SQL = class {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config2) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config2);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config2 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config2;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i3, p5] of chunk.entries()) {
          result.push(p5);
          if (i3 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config2);
      }
      if (is(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config2,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(chunk.name), params: [] };
        }
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config2);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config2), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config2);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config2);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config2);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config2), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias3) {
    if (alias3 === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias3);
  }
  mapWith(decoder3) {
    this.decoder = typeof decoder3 === "function" ? { mapFromDriverValue: decoder3 } : decoder3;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  /**
   * This method is used to conditionally include a part of the query.
   *
   * @param condition - Condition to check
   * @returns itself if the condition is `true`, otherwise `undefined`
   */
  if(condition) {
    return condition ? this : void 0;
  }
};
var SQL = _SQL;
__name(SQL, "SQL");
_a22 = entityKind;
__publicField(SQL, _a22, "SQL");
var _a23;
var Name = class {
  constructor(value) {
    this.value = value;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
__name(Name, "Name");
_a23 = entityKind;
__publicField(Name, _a23, "Name");
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
__name(isDriverValueEncoder, "isDriverValueEncoder");
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var _a24;
var Param = class {
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder3 = noopEncoder) {
    this.value = value;
    this.encoder = encoder3;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
__name(Param, "Param");
_a24 = entityKind;
__publicField(Param, _a24, "Param");
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
__name(sql, "sql");
((sql22) => {
  function empty() {
    return new SQL([]);
  }
  __name(empty, "empty");
  sql22.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  __name(fromList, "fromList");
  sql22.fromList = fromList;
  function raw3(str) {
    return new SQL([new StringChunk(str)]);
  }
  __name(raw3, "raw");
  sql22.raw = raw3;
  function join(chunks, separator) {
    const result = [];
    for (const [i3, chunk] of chunks.entries()) {
      if (i3 > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  __name(join, "join");
  sql22.join = join;
  function identifier(value) {
    return new Name(value);
  }
  __name(identifier, "identifier");
  sql22.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  __name(placeholder2, "placeholder2");
  sql22.placeholder = placeholder2;
  function param2(value, encoder3) {
    return new Param(value, encoder3);
  }
  __name(param2, "param2");
  sql22.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    constructor(sql22, fieldAlias) {
      this.sql = sql22;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  __name(Aliased, "Aliased");
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var _a25;
var Placeholder = class {
  constructor(name2) {
    this.name = name2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
__name(Placeholder, "Placeholder");
_a25 = entityKind;
__publicField(Placeholder, _a25, "Placeholder");
function fillPlaceholders(params, values) {
  return params.map((p5) => {
    if (is(p5, Placeholder)) {
      if (!(p5.name in values)) {
        throw new Error(`No value for placeholder "${p5.name}" was provided`);
      }
      return values[p5.name];
    }
    if (is(p5, Param) && is(p5.value, Placeholder)) {
      if (!(p5.value.name in values)) {
        throw new Error(`No value for placeholder "${p5.value.name}" was provided`);
      }
      return p5.encoder.mapToDriverValue(values[p5.value.name]);
    }
    return p5;
  });
}
__name(fillPlaceholders, "fillPlaceholders");
var _a26;
var View = class {
  /** @internal */
  [(_a26 = entityKind, ViewBaseConfig)];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
__name(View, "View");
__publicField(View, _a26, "View");
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/alias.js
var _a27;
var ColumnAliasProxyHandler = class {
  constructor(table3) {
    this.table = table3;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
__name(ColumnAliasProxyHandler, "ColumnAliasProxyHandler");
_a27 = entityKind;
__publicField(ColumnAliasProxyHandler, _a27, "ColumnAliasProxyHandler");
var _a28;
var TableAliasProxyHandler = class {
  constructor(alias3, replaceOriginalName) {
    this.alias = alias3;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(
          columns[key],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
__name(TableAliasProxyHandler, "TableAliasProxyHandler");
_a28 = entityKind;
__publicField(TableAliasProxyHandler, _a28, "TableAliasProxyHandler");
var _a29;
var RelationTableAliasProxyHandler = class {
  constructor(alias3) {
    this.alias = alias3;
  }
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
__name(RelationTableAliasProxyHandler, "RelationTableAliasProxyHandler");
_a29 = entityKind;
__publicField(RelationTableAliasProxyHandler, _a29, "RelationTableAliasProxyHandler");
function aliasedTable(table3, tableAlias) {
  return new Proxy(table3, new TableAliasProxyHandler(tableAlias, false));
}
__name(aliasedTable, "aliasedTable");
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
__name(aliasedTableColumn, "aliasedTableColumn");
function mapColumnsInAliasedSQLToAlias(query, alias3) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias3), query.fieldAlias);
}
__name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
function mapColumnsInSQLToAlias(query, alias3) {
  return sql.join(query.queryChunks.map((c4) => {
    if (is(c4, Column)) {
      return aliasedTableColumn(c4, alias3);
    }
    if (is(c4, SQL)) {
      return mapColumnsInSQLToAlias(c4, alias3);
    }
    if (is(c4, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c4, alias3);
    }
    return c4;
  }));
}
__name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/errors.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a30;
var DrizzleError = class extends Error {
  constructor({ message: message2, cause }) {
    super(message2);
    this.name = "DrizzleError";
    this.cause = cause;
  }
};
__name(DrizzleError, "DrizzleError");
_a30 = entityKind;
__publicField(DrizzleError, _a30, "DrizzleError");
var _a31;
var TransactionRollbackError = class extends DrizzleError {
  constructor() {
    super({ message: "Rollback" });
  }
};
__name(TransactionRollbackError, "TransactionRollbackError");
_a31 = entityKind;
__publicField(TransactionRollbackError, _a31, "TransactionRollbackError");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sql/expressions/conditions.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
__name(bindIfParam, "bindIfParam");
var eq = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
}, "eq");
var ne = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
}, "ne");
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c4) => c4 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
__name(and, "and");
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c4) => c4 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
__name(or, "or");
function not(condition) {
  return sql`not ${condition}`;
}
__name(not, "not");
var gt = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
}, "gt");
var gte = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
}, "gte");
var lt = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
}, "lt");
var lte = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
}, "lte");
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
__name(inArray, "inArray");
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
__name(notInArray, "notInArray");
function isNull(value) {
  return sql`${value} is null`;
}
__name(isNull, "isNull");
function isNotNull(value) {
  return sql`${value} is not null`;
}
__name(isNotNull, "isNotNull");
function exists2(subquery) {
  return sql`exists ${subquery}`;
}
__name(exists2, "exists");
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
__name(notExists, "notExists");
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
__name(between, "between");
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
__name(notBetween, "notBetween");
function like(column, value) {
  return sql`${column} like ${value}`;
}
__name(like, "like");
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
__name(notLike, "notLike");
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
__name(ilike, "ilike");
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
__name(notIlike, "notIlike");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sql/expressions/select.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function asc(column) {
  return sql`${column} asc`;
}
__name(asc, "asc");
function desc(column) {
  return sql`${column} desc`;
}
__name(desc, "desc");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/logger.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a32;
var ConsoleLogWriter = class {
  write(message2) {
    console.log(message2);
  }
};
__name(ConsoleLogWriter, "ConsoleLogWriter");
_a32 = entityKind;
__publicField(ConsoleLogWriter, _a32, "ConsoleLogWriter");
var _a33;
var DefaultLogger = class {
  writer;
  constructor(config2) {
    this.writer = config2?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p5) => {
      try {
        return JSON.stringify(p5);
      } catch {
        return String(p5);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
__name(DefaultLogger, "DefaultLogger");
_a33 = entityKind;
__publicField(DefaultLogger, _a33, "DefaultLogger");
var _a34;
var NoopLogger = class {
  logQuery() {
  }
};
__name(NoopLogger, "NoopLogger");
_a34 = entityKind;
__publicField(NoopLogger, _a34, "NoopLogger");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/query-promise.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a35;
var QueryPromise = class {
  [(_a35 = entityKind, Symbol.toStringTag)] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};
__name(QueryPromise, "QueryPromise");
__publicField(QueryPromise, _a35, "QueryPromise");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/relations.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/primary-keys.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a36;
var PrimaryKeyBuilder = class {
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table3) {
    return new PrimaryKey(table3, this.columns, this.name);
  }
};
__name(PrimaryKeyBuilder, "PrimaryKeyBuilder");
_a36 = entityKind;
__publicField(PrimaryKeyBuilder, _a36, "PgPrimaryKeyBuilder");
var _a37;
var PrimaryKey = class {
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name;
  }
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
__name(PrimaryKey, "PrimaryKey");
_a37 = entityKind;
__publicField(PrimaryKey, _a37, "PgPrimaryKey");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/relations.js
var _a38;
var Relation = class {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  referencedTableName;
  fieldName;
};
__name(Relation, "Relation");
_a38 = entityKind;
__publicField(Relation, _a38, "Relation");
var _a39;
var Relations = class {
  constructor(table3, config2) {
    this.table = table3;
    this.config = config2;
  }
};
__name(Relations, "Relations");
_a39 = entityKind;
__publicField(Relations, _a39, "Relations");
var _a40;
var _One = class extends Relation {
  constructor(sourceTable, referencedTable, config2, isNullable) {
    super(sourceTable, referencedTable, config2?.relationName);
    this.config = config2;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var One = _One;
__name(One, "One");
_a40 = entityKind;
__publicField(One, _a40, "One");
var _a41;
var _Many = class extends Relation {
  constructor(sourceTable, referencedTable, config2) {
    super(sourceTable, referencedTable, config2?.relationName);
    this.config = config2;
  }
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = _Many;
__name(Many, "Many");
_a41 = entityKind;
__publicField(Many, _a41, "Many");
function getOperators() {
  return {
    and,
    between,
    eq,
    exists: exists2,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
__name(getOperators, "getOperators");
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
__name(getOrderByOperators, "getOrderByOperators");
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
__name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
function relations(table3, relations2) {
  return new Relations(
    table3,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key)
      ])
    )
  );
}
__name(relations, "relations");
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table3, config2) {
    return new One(
      sourceTable,
      table3,
      config2,
      config2?.fields.reduce((res, f4) => res && f4.notNull, true) ?? false
    );
  }, "one");
}
__name(createOne, "createOne");
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config2) {
    return new Many(sourceTable, referencedTable, config2);
  }, "many");
}
__name(createMany, "createMany");
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
__name(normalizeRelation, "normalizeRelation");
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
__name(createTableRelationsHelpers, "createTableRelationsHelpers");
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder3;
      if (is(field, Column)) {
        decoder3 = field;
      } else if (is(field, SQL)) {
        decoder3 = field.decoder;
      } else {
        decoder3 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder3.mapFromDriverValue(value);
    }
  }
  return result;
}
__name(mapRelationalRow, "mapRelationalRow");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sql/functions/aggregate.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function count3(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}
__name(count3, "count");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/utils.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path: path2, field }, columnIndex) => {
      let decoder3;
      if (is(field, Column)) {
        decoder3 = field;
      } else if (is(field, SQL)) {
        decoder3 = field.decoder;
      } else {
        decoder3 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path2.entries()) {
        if (pathChunkIndex < path2.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder3.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path2.length === 2) {
            const objectName = path2[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
__name(mapResultRow, "mapResultRow");
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
__name(orderSelectedFields, "orderSelectedFields");
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
__name(haveSameKeys, "haveSameKeys");
function mapUpdateSet(table3, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table3[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
__name(mapUpdateSet, "mapUpdateSet");
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
__name(applyMixins, "applyMixins");
function getTableColumns(table3) {
  return table3[Table.Symbol.Columns];
}
__name(getTableColumns, "getTableColumns");
function getTableLikeName(table3) {
  return is(table3, Subquery) ? table3._.alias : is(table3, View) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : table3[Table.Symbol.IsAlias] ? table3[Table.Symbol.Name] : table3[Table.Symbol.BaseName];
}
__name(getTableLikeName, "getTableLikeName");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/columns/common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/foreign-keys.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/table.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var InlineForeignKeys2 = Symbol.for("drizzle:MySqlInlineForeignKeys");
var _a42;
var MySqlTable = class extends Table {
  /** @internal */
  [(_a42 = entityKind, Table.Symbol.Columns)];
  /** @internal */
  [InlineForeignKeys2] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__name(MySqlTable, "MySqlTable");
__publicField(MySqlTable, _a42, "MySqlTable");
/** @internal */
__publicField(MySqlTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys: InlineForeignKeys2
}));

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/foreign-keys.js
var _a43;
var ForeignKeyBuilder2 = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config2, actions2) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config2();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions2) {
      this._onUpdate = actions2.onUpdate;
      this._onDelete = actions2.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table3) {
    return new ForeignKey2(table3, this);
  }
};
__name(ForeignKeyBuilder2, "ForeignKeyBuilder");
_a43 = entityKind;
__publicField(ForeignKeyBuilder2, _a43, "MySqlForeignKeyBuilder");
var _a44;
var ForeignKey2 = class {
  constructor(table3, builder) {
    this.table = table3;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[MySqlTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[MySqlTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
__name(ForeignKey2, "ForeignKey");
_a44 = entityKind;
__publicField(ForeignKey2, _a44, "MySqlForeignKey");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/unique-constraint.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function uniqueKeyName2(table3, columns) {
  return `${table3[MySqlTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName2, "uniqueKeyName");
var _a45;
var UniqueConstraintBuilder2 = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  build(table3) {
    return new UniqueConstraint2(table3, this.columns, this.name);
  }
};
__name(UniqueConstraintBuilder2, "UniqueConstraintBuilder");
_a45 = entityKind;
__publicField(UniqueConstraintBuilder2, _a45, "MySqlUniqueConstraintBuilder");
var _a46;
var UniqueOnConstraintBuilder2 = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder2(columns, this.name);
  }
};
__name(UniqueOnConstraintBuilder2, "UniqueOnConstraintBuilder");
_a46 = entityKind;
__publicField(UniqueOnConstraintBuilder2, _a46, "MySqlUniqueOnConstraintBuilder");
var _a47;
var UniqueConstraint2 = class {
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
  }
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};
__name(UniqueConstraint2, "UniqueConstraint");
_a47 = entityKind;
__publicField(UniqueConstraint2, _a47, "MySqlUniqueConstraint");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/columns/common.js
var _a48;
var MySqlColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  references(ref, actions2 = {}) {
    this.foreignKeyConfigs.push({ ref, actions: actions2 });
    return this;
  }
  unique(name) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    return this;
  }
  generatedAlwaysAs(as, config2) {
    this.config.generated = {
      as,
      type: "always",
      mode: config2?.mode ?? "virtual"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table3) {
    return this.foreignKeyConfigs.map(({ ref, actions: actions2 }) => {
      return ((ref2, actions22) => {
        const builder = new ForeignKeyBuilder2(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions22.onUpdate) {
          builder.onUpdate(actions22.onUpdate);
        }
        if (actions22.onDelete) {
          builder.onDelete(actions22.onDelete);
        }
        return builder.build(table3);
      })(ref, actions2);
    });
  }
};
__name(MySqlColumnBuilder, "MySqlColumnBuilder");
_a48 = entityKind;
__publicField(MySqlColumnBuilder, _a48, "MySqlColumnBuilder");
var _a49;
var MySqlColumn = class extends Column {
  constructor(table3, config2) {
    if (!config2.uniqueName) {
      config2.uniqueName = uniqueKeyName2(table3, [config2.name]);
    }
    super(table3, config2);
    this.table = table3;
  }
};
__name(MySqlColumn, "MySqlColumn");
_a49 = entityKind;
__publicField(MySqlColumn, _a49, "MySqlColumn");
var _a50;
var MySqlColumnBuilderWithAutoIncrement = class extends MySqlColumnBuilder {
  constructor(name, dataType, columnType) {
    super(name, dataType, columnType);
    this.config.autoIncrement = false;
  }
  autoincrement() {
    this.config.autoIncrement = true;
    this.config.hasDefault = true;
    return this;
  }
};
__name(MySqlColumnBuilderWithAutoIncrement, "MySqlColumnBuilderWithAutoIncrement");
_a50 = entityKind;
__publicField(MySqlColumnBuilderWithAutoIncrement, _a50, "MySqlColumnBuilderWithAutoIncrement");
var _a51;
var MySqlColumnWithAutoIncrement = class extends MySqlColumn {
  autoIncrement = this.config.autoIncrement;
};
__name(MySqlColumnWithAutoIncrement, "MySqlColumnWithAutoIncrement");
_a51 = entityKind;
__publicField(MySqlColumnWithAutoIncrement, _a51, "MySqlColumnWithAutoIncrement");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/columns/char.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a52;
var MySqlCharBuilder = class extends MySqlColumnBuilder {
  constructor(name, config2) {
    super(name, "string", "MySqlChar");
    this.config.length = config2.length;
    this.config.enum = config2.enum;
  }
  /** @internal */
  build(table3) {
    return new MySqlChar(
      table3,
      this.config
    );
  }
};
__name(MySqlCharBuilder, "MySqlCharBuilder");
_a52 = entityKind;
__publicField(MySqlCharBuilder, _a52, "MySqlCharBuilder");
var _a53;
var MySqlChar = class extends MySqlColumn {
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === void 0 ? `char` : `char(${this.length})`;
  }
};
__name(MySqlChar, "MySqlChar");
_a53 = entityKind;
__publicField(MySqlChar, _a53, "MySqlChar");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/columns/varbinary.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a54;
var MySqlVarBinaryBuilder = class extends MySqlColumnBuilder {
  /** @internal */
  constructor(name, config2) {
    super(name, "string", "MySqlVarBinary");
    this.config.length = config2?.length;
  }
  /** @internal */
  build(table3) {
    return new MySqlVarBinary(
      table3,
      this.config
    );
  }
};
__name(MySqlVarBinaryBuilder, "MySqlVarBinaryBuilder");
_a54 = entityKind;
__publicField(MySqlVarBinaryBuilder, _a54, "MySqlVarBinaryBuilder");
var _a55;
var MySqlVarBinary = class extends MySqlColumn {
  length = this.config.length;
  getSQLType() {
    return this.length === void 0 ? `varbinary` : `varbinary(${this.length})`;
  }
};
__name(MySqlVarBinary, "MySqlVarBinary");
_a55 = entityKind;
__publicField(MySqlVarBinary, _a55, "MySqlVarBinary");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/mysql-core/columns/varchar.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a56;
var MySqlVarCharBuilder = class extends MySqlColumnBuilder {
  /** @internal */
  constructor(name, config2) {
    super(name, "string", "MySqlVarChar");
    this.config.length = config2.length;
    this.config.enum = config2.enum;
  }
  /** @internal */
  build(table3) {
    return new MySqlVarChar(
      table3,
      this.config
    );
  }
};
__name(MySqlVarCharBuilder, "MySqlVarCharBuilder");
_a56 = entityKind;
__publicField(MySqlVarCharBuilder, _a56, "MySqlVarCharBuilder");
var _a57;
var MySqlVarChar = class extends MySqlColumn {
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
  }
};
__name(MySqlVarChar, "MySqlVarChar");
_a57 = entityKind;
__publicField(MySqlVarChar, _a57, "MySqlVarChar");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/selection-proxy.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a58;
var _SelectionProxyHandler = class {
  config;
  constructor(config2) {
    this.config = { ...config2 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(
          subquery._.selectedFields,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value,
          new ColumnAliasProxyHandler(
            new Proxy(
              value.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};
var SelectionProxyHandler = _SelectionProxyHandler;
__name(SelectionProxyHandler, "SelectionProxyHandler");
_a58 = entityKind;
__publicField(SelectionProxyHandler, _a58, "SelectionProxyHandler");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/query-builders/query-builder.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a59;
var TypedQueryBuilder = class {
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};
__name(TypedQueryBuilder, "TypedQueryBuilder");
_a59 = entityKind;
__publicField(TypedQueryBuilder, _a59, "TypedQueryBuilder");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/alias.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function alias(table3, alias22) {
  return new Proxy(table3, new TableAliasProxyHandler(alias22, false));
}
__name(alias, "alias");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/int.common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a60;
var PgIntColumnBaseBuilder = class extends PgColumnBuilder {
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
};
__name(PgIntColumnBaseBuilder, "PgIntColumnBaseBuilder");
_a60 = entityKind;
__publicField(PgIntColumnBaseBuilder, _a60, "PgIntColumnBaseBuilder");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/boolean.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a61;
var PgBooleanBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  /** @internal */
  build(table3) {
    return new PgBoolean(table3, this.config);
  }
};
__name(PgBooleanBuilder, "PgBooleanBuilder");
_a61 = entityKind;
__publicField(PgBooleanBuilder, _a61, "PgBooleanBuilder");
var _a62;
var PgBoolean = class extends PgColumn {
  getSQLType() {
    return "boolean";
  }
};
__name(PgBoolean, "PgBoolean");
_a62 = entityKind;
__publicField(PgBoolean, _a62, "PgBoolean");
function boolean(name) {
  return new PgBooleanBuilder(name);
}
__name(boolean, "boolean");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/char.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a63;
var PgCharBuilder = class extends PgColumnBuilder {
  constructor(name, config2) {
    super(name, "string", "PgChar");
    this.config.length = config2.length;
    this.config.enumValues = config2.enum;
  }
  /** @internal */
  build(table3) {
    return new PgChar(table3, this.config);
  }
};
__name(PgCharBuilder, "PgCharBuilder");
_a63 = entityKind;
__publicField(PgCharBuilder, _a63, "PgCharBuilder");
var _a64;
var PgChar = class extends PgColumn {
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `char` : `char(${this.length})`;
  }
};
__name(PgChar, "PgChar");
_a64 = entityKind;
__publicField(PgChar, _a64, "PgChar");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/date.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/date.common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a65;
var PgDateColumnBaseBuilder = class extends PgColumnBuilder {
  defaultNow() {
    return this.default(sql`now()`);
  }
};
__name(PgDateColumnBaseBuilder, "PgDateColumnBaseBuilder");
_a65 = entityKind;
__publicField(PgDateColumnBaseBuilder, _a65, "PgDateColumnBaseBuilder");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/date.js
var _a66;
var PgDateBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "date", "PgDate");
  }
  /** @internal */
  build(table3) {
    return new PgDate(table3, this.config);
  }
};
__name(PgDateBuilder, "PgDateBuilder");
_a66 = entityKind;
__publicField(PgDateBuilder, _a66, "PgDateBuilder");
var _a67;
var PgDate = class extends PgColumn {
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
};
__name(PgDate, "PgDate");
_a67 = entityKind;
__publicField(PgDate, _a67, "PgDate");
var _a68;
var PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  /** @internal */
  build(table3) {
    return new PgDateString(
      table3,
      this.config
    );
  }
};
__name(PgDateStringBuilder, "PgDateStringBuilder");
_a68 = entityKind;
__publicField(PgDateStringBuilder, _a68, "PgDateStringBuilder");
var _a69;
var PgDateString = class extends PgColumn {
  getSQLType() {
    return "date";
  }
};
__name(PgDateString, "PgDateString");
_a69 = entityKind;
__publicField(PgDateString, _a69, "PgDateString");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/integer.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a70;
var PgIntegerBuilder = class extends PgIntColumnBaseBuilder {
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  /** @internal */
  build(table3) {
    return new PgInteger(table3, this.config);
  }
};
__name(PgIntegerBuilder, "PgIntegerBuilder");
_a70 = entityKind;
__publicField(PgIntegerBuilder, _a70, "PgIntegerBuilder");
var _a71;
var PgInteger = class extends PgColumn {
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
};
__name(PgInteger, "PgInteger");
_a71 = entityKind;
__publicField(PgInteger, _a71, "PgInteger");
function integer(name) {
  return new PgIntegerBuilder(name);
}
__name(integer, "integer");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/json.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a72;
var PgJsonBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJson");
  }
  /** @internal */
  build(table3) {
    return new PgJson(table3, this.config);
  }
};
__name(PgJsonBuilder, "PgJsonBuilder");
_a72 = entityKind;
__publicField(PgJsonBuilder, _a72, "PgJsonBuilder");
var _a73;
var PgJson = class extends PgColumn {
  constructor(table3, config2) {
    super(table3, config2);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
__name(PgJson, "PgJson");
_a73 = entityKind;
__publicField(PgJson, _a73, "PgJson");
function json(name) {
  return new PgJsonBuilder(name);
}
__name(json, "json");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/jsonb.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a74;
var PgJsonbBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  /** @internal */
  build(table3) {
    return new PgJsonb(table3, this.config);
  }
};
__name(PgJsonbBuilder, "PgJsonbBuilder");
_a74 = entityKind;
__publicField(PgJsonbBuilder, _a74, "PgJsonbBuilder");
var _a75;
var PgJsonb = class extends PgColumn {
  constructor(table3, config2) {
    super(table3, config2);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
__name(PgJsonb, "PgJsonb");
_a75 = entityKind;
__publicField(PgJsonb, _a75, "PgJsonb");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/numeric.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a76;
var PgNumericBuilder = class extends PgColumnBuilder {
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table3) {
    return new PgNumeric(table3, this.config);
  }
};
__name(PgNumericBuilder, "PgNumericBuilder");
_a76 = entityKind;
__publicField(PgNumericBuilder, _a76, "PgNumericBuilder");
var _a77;
var PgNumeric = class extends PgColumn {
  precision;
  scale;
  constructor(table3, config2) {
    super(table3, config2);
    this.precision = config2.precision;
    this.scale = config2.scale;
  }
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
__name(PgNumeric, "PgNumeric");
_a77 = entityKind;
__publicField(PgNumeric, _a77, "PgNumeric");
function numeric(name, config2) {
  return new PgNumericBuilder(name, config2?.precision, config2?.scale);
}
__name(numeric, "numeric");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/text.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a78;
var PgTextBuilder = class extends PgColumnBuilder {
  constructor(name, config2) {
    super(name, "string", "PgText");
    this.config.enumValues = config2.enum;
  }
  /** @internal */
  build(table3) {
    return new PgText(table3, this.config);
  }
};
__name(PgTextBuilder, "PgTextBuilder");
_a78 = entityKind;
__publicField(PgTextBuilder, _a78, "PgTextBuilder");
var _a79;
var PgText = class extends PgColumn {
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
};
__name(PgText, "PgText");
_a79 = entityKind;
__publicField(PgText, _a79, "PgText");
function text(name, config2 = {}) {
  return new PgTextBuilder(name, config2);
}
__name(text, "text");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/time.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a80;
var PgTimeBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table3) {
    return new PgTime(table3, this.config);
  }
};
__name(PgTimeBuilder, "PgTimeBuilder");
_a80 = entityKind;
__publicField(PgTimeBuilder, _a80, "PgTimeBuilder");
var _a81;
var PgTime = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table3, config2) {
    super(table3, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
__name(PgTime, "PgTime");
_a81 = entityKind;
__publicField(PgTime, _a81, "PgTime");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/timestamp.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a82;
var PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table3) {
    return new PgTimestamp(table3, this.config);
  }
};
__name(PgTimestampBuilder, "PgTimestampBuilder");
_a82 = entityKind;
__publicField(PgTimestampBuilder, _a82, "PgTimestampBuilder");
var _a83;
var PgTimestamp = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table3, config2) {
    super(table3, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
};
__name(PgTimestamp, "PgTimestamp");
_a83 = entityKind;
__publicField(PgTimestamp, _a83, "PgTimestamp");
var _a84;
var PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table3) {
    return new PgTimestampString(
      table3,
      this.config
    );
  }
};
__name(PgTimestampStringBuilder, "PgTimestampStringBuilder");
_a84 = entityKind;
__publicField(PgTimestampStringBuilder, _a84, "PgTimestampStringBuilder");
var _a85;
var PgTimestampString = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table3, config2) {
    super(table3, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
__name(PgTimestampString, "PgTimestampString");
_a85 = entityKind;
__publicField(PgTimestampString, _a85, "PgTimestampString");
function timestamp(name, config2 = {}) {
  if (config2.mode === "string") {
    return new PgTimestampStringBuilder(name, config2.withTimezone ?? false, config2.precision);
  }
  return new PgTimestampBuilder(name, config2.withTimezone ?? false, config2.precision);
}
__name(timestamp, "timestamp");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/uuid.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a86;
var PgUUIDBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  /**
   * Adds `default gen_random_uuid()` to the column definition.
   */
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  /** @internal */
  build(table3) {
    return new PgUUID(table3, this.config);
  }
};
__name(PgUUIDBuilder, "PgUUIDBuilder");
_a86 = entityKind;
__publicField(PgUUIDBuilder, _a86, "PgUUIDBuilder");
var _a87;
var PgUUID = class extends PgColumn {
  getSQLType() {
    return "uuid";
  }
};
__name(PgUUID, "PgUUID");
_a87 = entityKind;
__publicField(PgUUID, _a87, "PgUUID");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/columns/varchar.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a88;
var PgVarcharBuilder = class extends PgColumnBuilder {
  constructor(name, config2) {
    super(name, "string", "PgVarchar");
    this.config.length = config2.length;
    this.config.enumValues = config2.enum;
  }
  /** @internal */
  build(table3) {
    return new PgVarchar(table3, this.config);
  }
};
__name(PgVarcharBuilder, "PgVarcharBuilder");
_a88 = entityKind;
__publicField(PgVarcharBuilder, _a88, "PgVarcharBuilder");
var _a89;
var PgVarchar = class extends PgColumn {
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
  }
};
__name(PgVarchar, "PgVarchar");
_a89 = entityKind;
__publicField(PgVarchar, _a89, "PgVarchar");
function varchar(name, config2 = {}) {
  return new PgVarcharBuilder(name, config2);
}
__name(varchar, "varchar");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/db.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/delete.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a90;
var PgDeleteBase = class extends QueryPromise {
  constructor(table3, session2, dialect, withList) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { table: table3, withList };
  }
  config;
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will delete only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   *
   * ```ts
   * // Delete all cars with green color
   * await db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Delete all BMW cars with a green color
   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Delete all cars with the green or blue color
   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
__name(PgDeleteBase, "PgDeleteBase");
_a90 = entityKind;
__publicField(PgDeleteBase, _a90, "PgDelete");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/insert.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a91;
var PgInsertBuilder = class {
  constructor(table3, session2, dialect, withList) {
    this.table = table3;
    this.session = session2;
    this.dialect = dialect;
    this.withList = withList;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
};
__name(PgInsertBuilder, "PgInsertBuilder");
_a91 = entityKind;
__publicField(PgInsertBuilder, _a91, "PgInsertBuilder");
var _a92;
var PgInsertBase = class extends QueryPromise {
  constructor(table3, values, session2, dialect, withList) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { table: table3, values, withList };
  }
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   *
   * Calling this method simply avoids inserting a row as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   *
   * @param config The `target` and `where` clauses.
   *
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   *
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config2 = {}) {
    if (config2.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config2.target.name);
      const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   *
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
   *
   * @param config The `target`, `set` and `where` clauses.
   *
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'Porsche' }
   *   });
   *
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config2) {
    if (config2.where && (config2.targetWhere || config2.setWhere)) {
      throw new Error(
        'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
      );
    }
    const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
    const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : void 0;
    const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : void 0;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config2.target.name);
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
__name(PgInsertBase, "PgInsertBase");
_a92 = entityKind;
__publicField(PgInsertBase, _a92, "PgInsert");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/dialect.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/view-base.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a93;
var PgViewBase = class extends View {
};
__name(PgViewBase, "PgViewBase");
_a93 = entityKind;
__publicField(PgViewBase, _a93, "PgViewBase");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/dialect.js
var _a94;
var PgDialect = class {
  async migrate(migrations, session2, config2) {
    const migrationsTable = typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config2 === "string" ? "drizzle" : config2.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session2.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session2.execute(migrationTableCreate);
    const dbMigrations = await session2.all(
      sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`
    );
    const lastDbMigration = dbMigrations[0];
    await session2.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(
            sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return void 0;
    const withSqlChunks = [sql`with `];
    for (const [i3, w3] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w3._.alias)} as (${w3._.sql})`);
      if (i3 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table: table3, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}delete from ${table3}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table3, set) {
    const tableColumns = table3[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter(
      (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
    );
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i3) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(col.name)} = ${value}`;
      if (i3 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table3, set, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table3, set);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}update ${table3} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i3) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(
            new SQL(
              query.queryChunks.map((c4) => {
                if (is(c4, PgColumn)) {
                  return sql.identifier(c4.name);
                }
                return c4;
              })
            )
          );
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i3 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table3,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f4 of fieldsList) {
      if (is(f4.field, Column) && getTableName(f4.field.table) !== (is(table3, Subquery) ? table3._.alias : is(table3, PgViewBase) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : getTableName(table3)) && !((table22) => joins?.some(
        ({ alias: alias3 }) => alias3 === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
      ))(f4.field.table)) {
        const tableName = getTableName(f4.field.table);
        throw new Error(
          `Your "${f4.path.join("->")}" field references a column "${tableName}"."${f4.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table3, Table) && table3[Table.Symbol.OriginalName] !== table3[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table3[Table.Symbol.OriginalName])}`;
        if (table3[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table3[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table3[Table.Symbol.Name])}`;
      }
      return table3;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql` `);
        }
        const table22 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
        if (is(table22, PgTable)) {
          const tableName = table22[PgTable.Symbol.Name];
          const tableSchema = table22[PgTable.Symbol.Schema];
          const origTableName = table22[PgTable.Symbol.OriginalName];
          const alias3 = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias3 && sql` ${sql.identifier(alias3)}`} on ${joinMeta.on}`
          );
        } else if (is(table22, View)) {
          const viewName = table22[ViewBaseConfig].name;
          const viewSchema = table22[ViewBaseConfig].schema;
          const origViewName = table22[ViewBaseConfig].originalName;
          const alias3 = viewName === origViewName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias3 && sql` ${sql.identifier(alias3)}`} on ${joinMeta.on}`
          );
        } else {
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`
          );
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(
          sql` of ${sql.join(
            Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
            sql`, `
          )}`
        );
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type: type2, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i3 = 0; i3 < singleOrderBy.queryChunks.length; i3++) {
            const chunk = singleOrderBy.queryChunks[i3];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i3] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type2} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table3, values, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns = table3[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_5, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else if (!col.default && col.onUpdateFn !== void 0) {
            const onUpdateFnResult = col.onUpdateFn();
            const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
            valueList.push(newValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`${withSql}insert into ${table3} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : void 0;
    const withNoDataSql = withNoData ? sql` with no data` : void 0;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder3) {
    if (is(encoder3, PgJsonb) || is(encoder3, PgJson)) {
      return "json";
    } else if (is(encoder3, PgNumeric)) {
      return "decimal";
    } else if (is(encoder3, PgTime)) {
      return "time";
    } else if (is(encoder3, PgTimestamp) || is(encoder3, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder3, PgDate) || is(encoder3, PgDateString)) {
      return "date";
    } else if (is(encoder3, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22, invokeSource) {
    return sql22.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  // buildRelationalQueryWithPK({
  // 	fullSchema,
  // 	schema,
  // 	tableNamesMap,
  // 	table,
  // 	tableConfig,
  // 	queryConfig: config,
  // 	tableAlias,
  // 	isRoot = false,
  // 	joinOn,
  // }: {
  // 	fullSchema: Record<string, unknown>;
  // 	schema: TablesRelationalConfig;
  // 	tableNamesMap: Record<string, string>;
  // 	table: PgTable;
  // 	tableConfig: TableRelationalConfig;
  // 	queryConfig: true | DBQueryConfig<'many', true>;
  // 	tableAlias: string;
  // 	isRoot?: boolean;
  // 	joinOn?: SQL;
  // }): BuildRelationalQueryResult<PgTable, PgColumn> {
  // 	// For { "<relation>": true }, return a table with selection of all columns
  // 	if (config === true) {
  // 		const selectionEntries = Object.entries(tableConfig.columns);
  // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
  // 			[key, value],
  // 		) => ({
  // 			dbKey: value.name,
  // 			tsKey: key,
  // 			field: value as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection,
  // 		};
  // 	}
  // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// let selectionForBuild = selection;
  // 	const aliasedColumns = Object.fromEntries(
  // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
  // 	);
  // 	const aliasedRelations = Object.fromEntries(
  // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
  // 	);
  // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
  // 	let where, hasUserDefinedWhere;
  // 	if (config.where) {
  // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
  // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
  // 		hasUserDefinedWhere = !!where;
  // 	}
  // 	where = and(joinOn, where);
  // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
  // 	let joins: Join[] = [];
  // 	let selectedColumns: string[] = [];
  // 	// Figure out which columns to select
  // 	if (config.columns) {
  // 		let isIncludeMode = false;
  // 		for (const [field, value] of Object.entries(config.columns)) {
  // 			if (value === undefined) {
  // 				continue;
  // 			}
  // 			if (field in tableConfig.columns) {
  // 				if (!isIncludeMode && value === true) {
  // 					isIncludeMode = true;
  // 				}
  // 				selectedColumns.push(field);
  // 			}
  // 		}
  // 		if (selectedColumns.length > 0) {
  // 			selectedColumns = isIncludeMode
  // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
  // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
  // 		}
  // 	} else {
  // 		// Select all columns if selection is not specified
  // 		selectedColumns = Object.keys(tableConfig.columns);
  // 	}
  // 	// for (const field of selectedColumns) {
  // 	// 	const column = tableConfig.columns[field]! as PgColumn;
  // 	// 	fieldsSelection.push({ tsKey: field, value: column });
  // 	// }
  // 	let initiallySelectedRelations: {
  // 		tsKey: string;
  // 		queryConfig: true | DBQueryConfig<'many', false>;
  // 		relation: Relation;
  // 	}[] = [];
  // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// Figure out which relations to select
  // 	if (config.with) {
  // 		initiallySelectedRelations = Object.entries(config.with)
  // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
  // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
  // 	}
  // 	const manyRelations = initiallySelectedRelations.filter((r) =>
  // 		is(r.relation, Many)
  // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
  // 	);
  // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
  // 	const isInnermostQuery = manyRelations.length < 2;
  // 	const selectedExtras: {
  // 		tsKey: string;
  // 		value: SQL.Aliased;
  // 	}[] = [];
  // 	// Figure out which extras to select
  // 	if (isInnermostQuery && config.extras) {
  // 		const extras = typeof config.extras === 'function'
  // 			? config.extras(aliasedFields, { sql })
  // 			: config.extras;
  // 		for (const [tsKey, value] of Object.entries(extras)) {
  // 			selectedExtras.push({
  // 				tsKey,
  // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
  // 			});
  // 		}
  // 	}
  // 	// Transform `fieldsSelection` into `selection`
  // 	// `fieldsSelection` shouldn't be used after this point
  // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
  // 	// 	selection.push({
  // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
  // 	// 		tsKey,
  // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
  // 	// 		relationTableTsKey: undefined,
  // 	// 		isJson: false,
  // 	// 		isExtra,
  // 	// 		selection: [],
  // 	// 	});
  // 	// }
  // 	let orderByOrig = typeof config.orderBy === 'function'
  // 		? config.orderBy(aliasedFields, orderByOperators)
  // 		: config.orderBy ?? [];
  // 	if (!Array.isArray(orderByOrig)) {
  // 		orderByOrig = [orderByOrig];
  // 	}
  // 	const orderBy = orderByOrig.map((orderByValue) => {
  // 		if (is(orderByValue, Column)) {
  // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
  // 		}
  // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
  // 	});
  // 	const limit = isInnermostQuery ? config.limit : undefined;
  // 	const offset = isInnermostQuery ? config.offset : undefined;
  // 	// For non-root queries without additional config except columns, return a table with selection
  // 	if (
  // 		!isRoot
  // 		&& initiallySelectedRelations.length === 0
  // 		&& selectedExtras.length === 0
  // 		&& !where
  // 		&& orderBy.length === 0
  // 		&& limit === undefined
  // 		&& offset === undefined
  // 	) {
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection: selectedColumns.map((key) => ({
  // 				dbKey: tableConfig.columns[key]!.name,
  // 				tsKey: key,
  // 				field: tableConfig.columns[key] as PgColumn,
  // 				relationTableTsKey: undefined,
  // 				isJson: false,
  // 				selection: [],
  // 			})),
  // 		};
  // 	}
  // 	const selectedRelationsWithoutPK:
  // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of initiallySelectedRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length > 0) {
  // 			continue;
  // 		}
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithoutPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 			nestedQueryRelation: relation,
  // 		});
  // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
  // 		joins.push({
  // 			on: sql`true`,
  // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: true,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
  // 		is(r.relation, One)
  // 	);
  // 	// Process all One relations with PKs, because they can all be joined on the same level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of oneRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length === 0) {
  // 			continue;
  // 		}
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
  // 			sql.join(
  // 				builtRelation.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelation.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: is(builtRelation.sql, SQL)
  // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
  // 				: aliasedTable(builtRelation.sql, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: is(builtRelation.sql, SQL),
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	let distinct: PgSelectConfig['distinct'];
  // 	let tableFrom: PgTable | Subquery = table;
  // 	// Process first Many relation - each one requires a nested subquery
  // 	const manyRelation = manyRelations[0];
  // 	if (manyRelation) {
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			relation,
  // 		} = manyRelation;
  // 		distinct = {
  // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
  // 		};
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const builtRelationSelectionField = sql`case when ${
  // 			sql.identifier(relationTableAlias)
  // 		} is null then '[]' else json_agg(json_build_array(${
  // 			sql.join(
  // 				builtRelationJoin.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: isLateralJoin
  // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
  // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: isLateralJoin,
  // 		});
  // 		// Build the "from" subquery with the remaining Many relations
  // 		const builtTableFrom = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table,
  // 			tableConfig,
  // 			queryConfig: {
  // 				...config,
  // 				where: undefined,
  // 				orderBy: undefined,
  // 				limit: undefined,
  // 				offset: undefined,
  // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
  // 					(result, { tsKey, queryConfig: configValue }) => {
  // 						result[tsKey] = configValue;
  // 						return result;
  // 					},
  // 					{},
  // 				),
  // 			},
  // 			tableAlias,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field: builtRelationSelectionField,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelationJoin.selection,
  // 		});
  // 		// selection = builtTableFrom.selection.map((item) =>
  // 		// 	is(item.field, SQL.Aliased)
  // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 		// 		: item
  // 		// );
  // 		// selectionForBuild = [{
  // 		// 	dbKey: '*',
  // 		// 	tsKey: '*',
  // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
  // 		// 	selection: [],
  // 		// 	isJson: false,
  // 		// 	relationTableTsKey: undefined,
  // 		// }];
  // 		// const newSelectionItem: (typeof selection)[number] = {
  // 		// 	dbKey: selectedRelationTsKey,
  // 		// 	tsKey: selectedRelationTsKey,
  // 		// 	field,
  // 		// 	relationTableTsKey: relationTableTsName,
  // 		// 	isJson: true,
  // 		// 	selection: builtRelationJoin.selection,
  // 		// };
  // 		// selection.push(newSelectionItem);
  // 		// selectionForBuild.push(newSelectionItem);
  // 		tableFrom = is(builtTableFrom.sql, PgTable)
  // 			? builtTableFrom.sql
  // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
  // 	}
  // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
  // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
  // 	}
  // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
  // 	function prepareSelectedColumns() {
  // 		return selectedColumns.map((key) => ({
  // 			dbKey: tableConfig.columns[key]!.name,
  // 			tsKey: key,
  // 			field: tableConfig.columns[key] as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	function prepareSelectedExtras() {
  // 		return selectedExtras.map((item) => ({
  // 			dbKey: item.value.fieldAlias,
  // 			tsKey: item.tsKey,
  // 			field: item.value,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	if (isRoot) {
  // 		selection = [
  // 			...prepareSelectedColumns(),
  // 			...prepareSelectedExtras(),
  // 		];
  // 	}
  // 	if (hasUserDefinedWhere || orderBy.length > 0) {
  // 		tableFrom = new Subquery(
  // 			this.buildSelectQuery({
  // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 				fields: {},
  // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 					path: [],
  // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 				})),
  // 				joins,
  // 				distinct,
  // 			}),
  // 			{},
  // 			tableAlias,
  // 		);
  // 		selectionForBuild = selection.map((item) =>
  // 			is(item.field, SQL.Aliased)
  // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 				: item
  // 		);
  // 		joins = [];
  // 		distinct = undefined;
  // 	}
  // 	const result = this.buildSelectQuery({
  // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 		fields: {},
  // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 			path: [],
  // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 		})),
  // 		where,
  // 		limit,
  // 		offset,
  // 		joins,
  // 		orderBy,
  // 		distinct,
  // 	});
  // 	return {
  // 		tableTsKey: tableConfig.tsName,
  // 		sql: result,
  // 		selection,
  // 	};
  // }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table: table3,
    tableConfig,
    queryConfig: config2,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config2 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
      );
      if (config2.where) {
        const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config2.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config2.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c4) => config2.columns?.[c4] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config2.with) {
        selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig2]) => ({ tsKey, queryConfig: queryConfig2, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config2.extras) {
        extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config2.limit;
      offset = config2.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i3) => eq(
              aliasedTableColumn(normalizedRelation.references[i3], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(
        selection.map(
          ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table3, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = [];
      } else {
        result = aliasedTable(table3, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table3, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
__name(PgDialect, "PgDialect");
_a94 = entityKind;
__publicField(PgDialect, _a94, "PgDialect");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/select.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a95;
var PgSelectBuilder = class {
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config2) {
    this.fields = config2.fields;
    this.session = config2.session;
    this.dialect = config2.dialect;
    if (config2.withList) {
      this.withList = config2.withList;
    }
    this.distinct = config2.distinct;
  }
  /**
   * Specify the table, subquery, or other target that you're
   * building a select query against.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
   */
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(source._.selectedFields).map((key) => [key, source[key]])
      );
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
__name(PgSelectBuilder, "PgSelectBuilder");
_a95 = entityKind;
__publicField(PgSelectBuilder, _a95, "PgSelectBuilder");
var _a96;
var PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table: table3, fields, isPartialSelect, session: session2, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table3,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session2;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table3);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table3, on3) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table3);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table3, SQL)) {
          const selection = is(table3, Subquery) ? table3._.selectedFields : is(table3, View) ? table3[ViewBaseConfig].selectedFields : table3[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on3 === "function") {
        on3 = on3(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on: on3, table: table3, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left");
  /**
   * Executes a `right join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right");
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner");
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full");
  createSetOperator(type2, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type: type2, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   *
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   *
   * @example
   *
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/pg-core'
   *
   * await union(
   *   db.select({ name: users.name }).from(users),
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   *
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   *
   * @example
   *
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/pg-core'
   *
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   *
   * @example
   *
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/pg-core'
   *
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `intersect all` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets including all duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
   *
   * @example
   *
   * ```ts
   * // Select all products and quantities that are ordered by both regular and VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered
   * })
   * .from(regularCustomerOrders)
   * .intersectAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { intersectAll } from 'drizzle-orm/pg-core'
   *
   * await intersectAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  intersectAll = this.createSetOperator("intersect", true);
  /**
   * Adds `except` set operator to the query.
   *
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   *
   * @example
   *
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/pg-core'
   *
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /**
   * Adds `except all` set operator to the query.
   *
   * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
   *
   * @example
   *
   * ```ts
   * // Select all products that are ordered by regular customers but not by VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered,
   * })
   * .from(regularCustomerOrders)
   * .exceptAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered,
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { exceptAll } from 'drizzle-orm/pg-core'
   *
   * await exceptAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  exceptAll = this.createSetOperator("except", true);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   *
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   *
   * @param having the `having` clause.
   *
   * @example
   *
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   *
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param limit the `limit` clause.
   *
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   *
   * Calling this method will skip a number of rows when returning results from this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param offset the `offset` clause.
   *
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /**
   * Adds a `for` clause to the query.
   *
   * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
   *
   * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
   *
   * @param strength the lock strength.
   * @param config the lock configuration.
   */
  for(strength, config2 = {}) {
    this.config.lockingClause = { strength, config: config2 };
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias3) {
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias3),
      new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
};
__name(PgSelectQueryBuilderBase, "PgSelectQueryBuilderBase");
_a96 = entityKind;
__publicField(PgSelectQueryBuilderBase, _a96, "PgSelectQueryBuilder");
var _a97;
var PgSelectBase = class extends PgSelectQueryBuilderBase {
  /** @internal */
  _prepare(name) {
    const { session: session2, config: config2, dialect, joinsNotNullableMap } = this;
    if (!session2) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config2.fields);
      const query = session2.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  /**
   * Create a prepared statement for this query. This allows
   * the database to remember this query for the given session
   * and call it by name, rather than specifying the full query.
   *
   * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
   */
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
__name(PgSelectBase, "PgSelectBase");
_a97 = entityKind;
__publicField(PgSelectBase, _a97, "PgSelect");
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type2, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type: type2,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
__name(createSetOperator, "createSetOperator");
var getPgSetOperators = /* @__PURE__ */ __name(() => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
}), "getPgSetOperators");
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var _a98;
var QueryBuilder = class {
  dialect;
  $with(alias3) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true),
          new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    function selectDistinctOn(on3, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: { on: on3 }
      });
    }
    __name(selectDistinctOn, "selectDistinctOn");
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on3, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on: on3 }
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect();
    }
    return this.dialect;
  }
};
__name(QueryBuilder, "QueryBuilder");
_a98 = entityKind;
__publicField(QueryBuilder, _a98, "PgQueryBuilder");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a99;
var PgRefreshMaterializedView = class extends QueryPromise {
  constructor(view, session2, dialect) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { view };
  }
  config;
  concurrently() {
    if (this.config.withNoData !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
__name(PgRefreshMaterializedView, "PgRefreshMaterializedView");
_a99 = entityKind;
__publicField(PgRefreshMaterializedView, _a99, "PgRefreshMaterializedView");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/update.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a100;
var PgUpdateBuilder = class {
  constructor(table3, session2, dialect, withList) {
    this.table = table3;
    this.session = session2;
    this.dialect = dialect;
    this.withList = withList;
  }
  set(values) {
    return new PgUpdateBase(
      this.table,
      mapUpdateSet(this.table, values),
      this.session,
      this.dialect,
      this.withList
    );
  }
};
__name(PgUpdateBuilder, "PgUpdateBuilder");
_a100 = entityKind;
__publicField(PgUpdateBuilder, _a100, "PgUpdateBuilder");
var _a101;
var PgUpdateBase = class extends QueryPromise {
  constructor(table3, set, session2, dialect, withList) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { set, table: table3, withList };
  }
  config;
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * await db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * await db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
};
__name(PgUpdateBase, "PgUpdateBase");
_a101 = entityKind;
__publicField(PgUpdateBase, _a101, "PgUpdate");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/query.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a102;
var RelationalQueryBuilder = class {
  constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session2) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table3;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session2;
  }
  findMany(config2) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config2 ? config2 : {},
      "many"
    );
  }
  findFirst(config2) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config2 ? { ...config2, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
__name(RelationalQueryBuilder, "RelationalQueryBuilder");
_a102 = entityKind;
__publicField(RelationalQueryBuilder, _a102, "PgRelationalQueryBuilder");
var _a103;
var PgRelationalQuery = class extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session2, config2, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table3;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session2;
    this.config = config2;
    this.mode = mode;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(
        builtQuery,
        void 0,
        name,
        true,
        (rawRows, mapColumnValue) => {
          const rows = rawRows.map(
            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
          );
          if (this.mode === "first") {
            return rows[0];
          }
          return rows;
        }
      );
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  /** @internal */
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
};
__name(PgRelationalQuery, "PgRelationalQuery");
_a103 = entityKind;
__publicField(PgRelationalQuery, _a103, "PgRelationalQuery");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/query-builders/raw.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a104;
var PgRaw = class extends QueryPromise {
  constructor(execute, sql3, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql3;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  /** @internal */
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  /** @internal */
  isResponseInArrayMode() {
    return false;
  }
};
__name(PgRaw, "PgRaw");
_a104 = entityKind;
__publicField(PgRaw, _a104, "PgRaw");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/db.js
var _a105;
var PgDatabase = class {
  constructor(dialect, session2, schema) {
    this.dialect = dialect;
    this.session = session2;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session: session2
    } : {
      schema: void 0,
      fullSchema: {},
      tableNamesMap: {},
      session: session2
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session2
        );
      }
    }
  }
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with(alias3) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true),
          new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    function selectDistinctOn(on3, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on: on3 }
      });
    }
    __name(selectDistinctOn, "selectDistinctOn");
    function update(table3) {
      return new PgUpdateBuilder(table3, self2.session, self2.dialect, queries);
    }
    __name(update, "update");
    function insert(table3) {
      return new PgInsertBuilder(table3, self2.session, self2.dialect, queries);
    }
    __name(insert, "insert");
    function delete_(table3) {
      return new PgDeleteBase(table3, self2.session, self2.dialect, queries);
    }
    __name(delete_, "delete_");
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on3, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on: on3 }
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table3) {
    return new PgUpdateBuilder(table3, this.session, this.dialect);
  }
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(table3) {
    return new PgInsertBuilder(table3, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(table3) {
    return new PgDeleteBase(table3, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query) {
    const sql3 = query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sql3);
    const prepared = this.session.prepareQuery(
      builtQuery,
      void 0,
      void 0,
      false
    );
    return new PgRaw(
      () => prepared.execute(),
      sql3,
      builtQuery,
      (result) => prepared.mapResult(result, true)
    );
  }
  transaction(transaction, config2) {
    return this.session.transaction(transaction, config2);
  }
};
__name(PgDatabase, "PgDatabase");
_a105 = entityKind;
__publicField(PgDatabase, _a105, "PgDatabase");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/pg-core/session.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a106;
var PgPreparedQuery = class {
  constructor(query) {
    this.query = query;
  }
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  /** @internal */
  joinsNotNullableMap;
};
__name(PgPreparedQuery, "PgPreparedQuery");
_a106 = entityKind;
__publicField(PgPreparedQuery, _a106, "PgPreparedQuery");
var _a107;
var PgSession = class {
  constructor(dialect) {
    this.dialect = dialect;
  }
  execute(query) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0,
          false
        );
      });
      return prepared.execute();
    });
  }
  all(query) {
    return this.prepareQuery(
      this.dialect.sqlToQuery(query),
      void 0,
      void 0,
      false
    ).all();
  }
};
__name(PgSession, "PgSession");
_a107 = entityKind;
__publicField(PgSession, _a107, "PgSession");
var _a108;
var PgTransaction = class extends PgDatabase {
  constructor(dialect, session2, schema, nestedIndex = 0) {
    super(dialect, session2, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
  /** @internal */
  getTransactionConfigSQL(config2) {
    const chunks = [];
    if (config2.isolationLevel) {
      chunks.push(`isolation level ${config2.isolationLevel}`);
    }
    if (config2.accessMode) {
      chunks.push(config2.accessMode);
    }
    if (typeof config2.deferrable === "boolean") {
      chunks.push(config2.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config2) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config2)}`);
  }
};
__name(PgTransaction, "PgTransaction");
_a108 = entityKind;
__publicField(PgTransaction, _a108, "PgTransaction");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/columns/common.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/foreign-keys.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/table.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var InlineForeignKeys3 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
var _a109;
var SQLiteTable = class extends Table {
  /** @internal */
  [(_a109 = entityKind, Table.Symbol.Columns)];
  /** @internal */
  [InlineForeignKeys3] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__name(SQLiteTable, "SQLiteTable");
__publicField(SQLiteTable, _a109, "SQLiteTable");
/** @internal */
__publicField(SQLiteTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys: InlineForeignKeys3
}));

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/foreign-keys.js
var _a110;
var ForeignKeyBuilder3 = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config2, actions2) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config2();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions2) {
      this._onUpdate = actions2.onUpdate;
      this._onDelete = actions2.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table3) {
    return new ForeignKey3(table3, this);
  }
};
__name(ForeignKeyBuilder3, "ForeignKeyBuilder");
_a110 = entityKind;
__publicField(ForeignKeyBuilder3, _a110, "SQLiteForeignKeyBuilder");
var _a111;
var ForeignKey3 = class {
  constructor(table3, builder) {
    this.table = table3;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[SQLiteTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[SQLiteTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
__name(ForeignKey3, "ForeignKey");
_a111 = entityKind;
__publicField(ForeignKey3, _a111, "SQLiteForeignKey");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/unique-constraint.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function uniqueKeyName3(table3, columns) {
  return `${table3[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName3, "uniqueKeyName");
var _a112;
var UniqueConstraintBuilder3 = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  build(table3) {
    return new UniqueConstraint3(table3, this.columns, this.name);
  }
};
__name(UniqueConstraintBuilder3, "UniqueConstraintBuilder");
_a112 = entityKind;
__publicField(UniqueConstraintBuilder3, _a112, "SQLiteUniqueConstraintBuilder");
var _a113;
var UniqueOnConstraintBuilder3 = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder3(columns, this.name);
  }
};
__name(UniqueOnConstraintBuilder3, "UniqueOnConstraintBuilder");
_a113 = entityKind;
__publicField(UniqueOnConstraintBuilder3, _a113, "SQLiteUniqueOnConstraintBuilder");
var _a114;
var UniqueConstraint3 = class {
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name ?? uniqueKeyName3(this.table, this.columns.map((column) => column.name));
  }
  columns;
  name;
  getName() {
    return this.name;
  }
};
__name(UniqueConstraint3, "UniqueConstraint");
_a114 = entityKind;
__publicField(UniqueConstraint3, _a114, "SQLiteUniqueConstraint");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/columns/common.js
var _a115;
var SQLiteColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  references(ref, actions2 = {}) {
    this.foreignKeyConfigs.push({ ref, actions: actions2 });
    return this;
  }
  unique(name) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    return this;
  }
  generatedAlwaysAs(as, config2) {
    this.config.generated = {
      as,
      type: "always",
      mode: config2?.mode ?? "virtual"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table3) {
    return this.foreignKeyConfigs.map(({ ref, actions: actions2 }) => {
      return ((ref2, actions22) => {
        const builder = new ForeignKeyBuilder3(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions22.onUpdate) {
          builder.onUpdate(actions22.onUpdate);
        }
        if (actions22.onDelete) {
          builder.onDelete(actions22.onDelete);
        }
        return builder.build(table3);
      })(ref, actions2);
    });
  }
};
__name(SQLiteColumnBuilder, "SQLiteColumnBuilder");
_a115 = entityKind;
__publicField(SQLiteColumnBuilder, _a115, "SQLiteColumnBuilder");
var _a116;
var SQLiteColumn = class extends Column {
  constructor(table3, config2) {
    if (!config2.uniqueName) {
      config2.uniqueName = uniqueKeyName3(table3, [config2.name]);
    }
    super(table3, config2);
    this.table = table3;
  }
};
__name(SQLiteColumn, "SQLiteColumn");
_a116 = entityKind;
__publicField(SQLiteColumn, _a116, "SQLiteColumn");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/sqlite-core/columns/text.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _a117;
var SQLiteTextBuilder = class extends SQLiteColumnBuilder {
  constructor(name, config2) {
    super(name, "string", "SQLiteText");
    this.config.enumValues = config2.enum;
    this.config.length = config2.length;
  }
  /** @internal */
  build(table3) {
    return new SQLiteText(table3, this.config);
  }
};
__name(SQLiteTextBuilder, "SQLiteTextBuilder");
_a117 = entityKind;
__publicField(SQLiteTextBuilder, _a117, "SQLiteTextBuilder");
var _a118;
var SQLiteText = class extends SQLiteColumn {
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table3, config2) {
    super(table3, config2);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
};
__name(SQLiteText, "SQLiteText");
_a118 = entityKind;
__publicField(SQLiteText, _a118, "SQLiteText");
var _a119;
var SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
  constructor(name) {
    super(name, "json", "SQLiteTextJson");
  }
  /** @internal */
  build(table3) {
    return new SQLiteTextJson(
      table3,
      this.config
    );
  }
};
__name(SQLiteTextJsonBuilder, "SQLiteTextJsonBuilder");
_a119 = entityKind;
__publicField(SQLiteTextJsonBuilder, _a119, "SQLiteTextJsonBuilder");
var _a120;
var SQLiteTextJson = class extends SQLiteColumn {
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value);
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
};
__name(SQLiteTextJson, "SQLiteTextJson");
_a120 = entityKind;
__publicField(SQLiteTextJson, _a120, "SQLiteTextJson");

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_5, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error4) => {
      for (const issue of error4.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(ZodError, "ZodError");
ZodError.create = (issues) => {
  const error4 = new ZodError(issues);
  return error4;
};
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
}, "errorMap");
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m5) => !!m5).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(ParseStatus, "ParseStatus");
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x3) => x3.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x3) => x3.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x3) => x3.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x3) => typeof Promise !== "undefined" && x3 instanceof Promise, "isAsync");
function __classPrivateFieldGet(receiver, state2, kind, f4) {
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state2.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state2, value, kind, f4) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state2.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(ParseInputLazyPath, "ParseInputLazyPath");
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error4 = new ZodError(ctx.common.issues);
        this._error = error4;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a126, _b;
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a126 = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a126 !== void 0 ? _a126 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a126;
    const ctx = {
      common: {
        issues: [],
        async: (_a126 = params === null || params === void 0 ? void 0 : params.async) !== null && _a126 !== void 0 ? _a126 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message2) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
__name(ZodType, "ZodType");
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a126) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a126, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a126 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a126 !== void 0 ? _a126 : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(ZodString, "ZodString");
ZodString.create = (params) => {
  var _a126;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a126 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a126 !== void 0 ? _a126 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
__name(ZodNumber, "ZodNumber");
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(ZodBigInt, "ZodBigInt");
ZodBigInt.create = (params) => {
  var _a126;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a126 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a126 !== void 0 ? _a126 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodBoolean, "ZodBoolean");
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
__name(ZodDate, "ZodDate");
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodSymbol, "ZodSymbol");
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodUndefined, "ZodUndefined");
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodNull, "ZodNull");
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(ZodAny, "ZodAny");
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(ZodUnknown, "ZodUnknown");
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
__name(ZodNever, "ZodNever");
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodVoid, "ZodVoid");
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(ZodArray, "ZodArray");
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a126, _b, _c, _d;
          const defaultError = (_c = (_b = (_a126 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a126, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
__name(ZodObject, "ZodObject");
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(ZodUnion, "ZodUnion");
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return util.objectValues(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else if (type2 instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodBranded) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodReadonly) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodCatch) {
    return getDiscriminator(type2._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
__name(ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
function mergeValues(a4, b3) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b3);
  if (a4 === b3) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a4, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a4.length; index++) {
      const itemA = a4[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b3) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
__name(ZodIntersection, "ZodIntersection");
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
__name(ZodTuple, "ZodTuple");
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
__name(ZodRecord, "ZodRecord");
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
__name(ZodMap, "ZodMap");
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(ZodSet, "ZodSet");
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error4) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error4
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error4) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error4
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn3 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error4 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error4.addIssue(makeArgsIssue(args, e2));
          throw error4;
        });
        const result = await Reflect.apply(fn3, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error4.addIssue(makeReturnsIssue(result, e2));
          throw error4;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn3, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
__name(ZodFunction, "ZodFunction");
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
__name(ZodLazy, "ZodLazy");
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(ZodLiteral, "ZodLiteral");
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
__name(ZodEnum, "ZodEnum");
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(ZodNativeEnum, "ZodNativeEnum");
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
__name(ZodPromise, "ZodPromise");
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
__name(ZodEffects, "ZodEffects");
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(ZodOptional, "ZodOptional");
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(ZodNullable, "ZodNullable");
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
__name(ZodDefault, "ZodDefault");
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
__name(ZodCatch, "ZodCatch");
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
__name(ZodNaN, "ZodNaN");
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
__name(ZodBranded, "ZodBranded");
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a4, b3) {
    return new ZodPipeline({
      in: a4,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
__name(ZodPipeline, "ZodPipeline");
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(ZodReadonly, "ZodReadonly");
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check2, params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a126, _b;
      if (!check2(data)) {
        const p5 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a126 = p5.fatal) !== null && _a126 !== void 0 ? _a126 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p5 === "string" ? { message: p5 } : p5;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/.pnpm/drizzle-zod@0.5.1_drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+ser_jnmio6bwm5hfuuz4iqe4ayique/node_modules/drizzle-zod/index.mjs
var m = z.union([z.string(), z.number(), z.boolean(), z.null()]);
var f = z.lazy(() => z.union([m, z.array(f), z.record(f)]));
function c(t2, n3) {
  const r3 = getTableColumns(t2), o4 = Object.entries(r3);
  let i3 = Object.fromEntries(o4.map(([e2, t3]) => [e2, p(t3)]));
  n3 && (i3 = Object.assign(i3, Object.fromEntries(Object.entries(n3).map(([e2, t3]) => [e2, "function" == typeof t3 ? t3(i3) : t3]))));
  for (const [e2, t3] of o4)
    t3.notNull ? t3.hasDefault && (i3[e2] = i3[e2].optional()) : i3[e2] = i3[e2].nullable().optional();
  return z.object(i3);
}
__name(c, "c");
function p(e2) {
  let m5;
  if (function(e3) {
    return "enumValues" in e3 && Array.isArray(e3.enumValues) && e3.enumValues.length > 0;
  }(e2) && (m5 = e2.enumValues.length ? z.enum(e2.enumValues) : z.string()), !m5) {
    if (is(e2, PgUUID))
      m5 = z.string().uuid();
    else if ("custom" === e2.dataType)
      m5 = z.any();
    else if ("json" === e2.dataType)
      m5 = f;
    else if ("array" === e2.dataType)
      m5 = z.array(p(e2.baseColumn));
    else if ("number" === e2.dataType)
      m5 = z.number();
    else if ("bigint" === e2.dataType)
      m5 = z.bigint();
    else if ("boolean" === e2.dataType)
      m5 = z.boolean();
    else if ("date" === e2.dataType)
      m5 = z.date();
    else if ("string" === e2.dataType) {
      let i3 = z.string();
      (is(e2, PgChar) || is(e2, PgVarchar) || is(e2, MySqlVarChar) || is(e2, MySqlVarBinary) || is(e2, MySqlChar) || is(e2, SQLiteText)) && "number" == typeof e2.length && (i3 = i3.max(e2.length)), m5 = i3;
    }
  }
  return m5 || (m5 = z.any()), m5;
}
__name(p, "p");

// src/db/schema/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/db/schema/bannerSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/lib/utils/dbUtils.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/index.browser.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/url-alphabet/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/index.browser.js
var nanoid = /* @__PURE__ */ __name((size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
}, "nanoid");

// src/lib/utils/dbUtils.ts
var nId = /* @__PURE__ */ __name((length = 11) => nanoid(length), "nId");

// src/db/schema/commonSchemaFields.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var commonCreatedField = {
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").notNull().$onUpdate(() => /* @__PURE__ */ new Date()).defaultNow()
};
var commonProductFields = {
  primaryImage: text("primary_image").notNull(),
  stock: integer("stock").default(0).notNull(),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  discountedPrice: numeric("discounted_price", { precision: 10, scale: 2 }),
  sortDescription: varchar("sort_description", { length: 300 }).notNull()
};

// src/db/schema/userSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var userRole = pgEnum("UserRole", ["ADMIN", "USER", "SELLER"]);
var users = pgTable("user", {
  id: text("id").primaryKey().$defaultFn(nId),
  role: userRole("role").notNull().default("USER"),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: varchar("phone", { length: 20 }),
  image: text("image"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().$onUpdate(() => /* @__PURE__ */ new Date()).defaultNow()
});

// src/db/schema/bannerSchema.ts
var banners = pgTable("banners", {
  id: text("id").primaryKey().$defaultFn(nId),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  // Title of the banner
  imageUrl: varchar("image_url", { length: 500 }).notNull(),
  // URL of the banner image
  link: varchar("link", { length: 500 }).notNull(),
  // URL where the banner redirects
  bannerType: varchar("banner_type", { length: 50 }).notNull(),
  // Type of banner (e.g., 'promo', 'category', 'featured')
  isActive: boolean("is_active").default(true),
  // Active status of the banner
  priority: integer("priority").default(0),
  // Priority for display ordering
  startDate: timestamp("start_date"),
  endDate: timestamp("end_date"),
  ...commonCreatedField
});

// src/db/schema/wishListSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/db/schema/productSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var categories = pgTable("categories", {
  id: text("id").primaryKey().$defaultFn(nId),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  image: text("image"),
  parentCategoryId: text("parent_category_id"),
  // For sub-categories
  ...commonCreatedField
});
var products = pgTable("products", {
  id: text("id").primaryKey().$defaultFn(nId),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  sku: varchar("sku", { length: 50 }).unique().notNull(),
  // Stock Keeping Unit
  rating: numeric("rating", { precision: 10, scale: 2 }),
  categoryId: text("category_id").references(() => categories.id, {
    onDelete: "set null"
  }),
  categoryName: varchar("category_name", { length: 255 }),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  isAvailable: boolean("is_available").default(true),
  currentVariantType: varchar("variant_type", { length: 50 }),
  variantValue: varchar("variant_value", { length: 50 }),
  brand: varchar("brand", { length: 100 }),
  parentId: text("parent_id").references(() => products.id, {
    onDelete: "set null"
  }),
  // Self-referencing Foreign Key
  primaryImage: text("primary_image").notNull(),
  stock: integer("stock").default(0).notNull(),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  discountedPrice: numeric("discounted_price", { precision: 10, scale: 2 }),
  sortDescription: varchar("sort_description", { length: 300 }).notNull(),
  ...commonCreatedField,
  meta: json("meta")
  // JSON for additional product-specific attributes
});
var imageType = pgEnum("ImageType", [
  "BANNER",
  "PRIMARY",
  "SUB_IMAGES"
]);
var productImages = pgTable("product_images", {
  id: text("id").primaryKey().$defaultFn(nId),
  productId: text("product_id").references(() => products.id, {
    onDelete: "set null"
  }),
  imageUrl: varchar("image_url", { length: 500 }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  role: imageType("image_type").notNull().default("SUB_IMAGES")
});
var reviews = pgTable("reviews", {
  id: text("id").primaryKey().$defaultFn(nId),
  productId: text("product_id").references(() => products.id).notNull(),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  rating: numeric("rating", { precision: 2, scale: 1 }).notNull(),
  reviewText: text("review_text"),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var inventoryLogs = pgTable("inventory_logs", {
  id: text("id").primaryKey().$defaultFn(nId),
  productId: text("product_id").references(() => products.id).notNull(),
  userId: text("user_id").references(() => users.id).notNull(),
  // User who made the inventory change
  changeType: varchar("change_type", { length: 50 }).notNull(),
  quantity: integer("quantity").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var productRelations = relations(products, ({ one }) => ({
  category: one(categories, {
    fields: [products.categoryId],
    references: [categories.id]
  }),
  user: one(users, {
    fields: [products.userId],
    references: [users.id]
  })
}));
var reviewRelations = relations(reviews, ({ one }) => ({
  product: one(products, {
    fields: [reviews.productId],
    references: [products.id]
  }),
  user: one(users, {
    fields: [reviews.userId],
    references: [users.id]
  })
}));
var inventoryLogRelations = relations(inventoryLogs, ({ one }) => ({
  product: one(products, {
    fields: [inventoryLogs.productId],
    references: [products.id]
  }),
  user: one(users, {
    fields: [inventoryLogs.userId],
    references: [users.id]
  })
}));

// src/db/schema/wishListSchema.ts
var UserWishList = pgTable("wish_list", {
  id: text("id").primaryKey().$defaultFn(nId),
  productId: text("product_id").references(() => products.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});

// src/db/schema/cartSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var UserCart = pgTable("user_cart", {
  id: text("id").primaryKey().$defaultFn(nId),
  productId: text("product_id").references(() => products.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade", onUpdate: "cascade" }).notNull(),
  qty: integer("qty").default(0).notNull(),
  ...commonCreatedField
});

// src/zodSchema/productSchema.ts
var insertProductSchema = c(products);

// src/services/uploadService.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/config/cloudinaryConfig.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var import_cloudinary = __toESM(require_cloudinary2());
import_cloudinary.v2.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});
var cloudinaryConfig_default = import_cloudinary.v2;

// src/services/uploadService.ts
import stream from "stream";
var UploadService = class {
  static uploadToCloudinary(fileBuffer, fileName) {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinaryConfig_default.uploader.upload_stream(
        {
          resource_type: "auto",
          public_id: fileName,
          folder: process.env.CLOUDINARY_UPLOAD_PRESET
        },
        (error4, result) => {
          if (error4) {
            reject(error4);
          } else {
            resolve(result);
          }
        }
      );
      const passThrough = new stream.PassThrough();
      passThrough.end(fileBuffer);
      passThrough.pipe(uploadStream);
    });
  }
  static async uploadFiles(filesArray) {
    try {
      const uploadPromises = filesArray.map(async (file) => {
        const fileBuffer = Buffer.from(await file.arrayBuffer());
        return UploadService.uploadToCloudinary(
          fileBuffer,
          `${(file.name || "")?.substring(0, 4)}${nId(5)}_${Date.now() / 1e3}`
        );
      });
      const uploadResponses = await Promise.all(uploadPromises);
      const savedFiles = uploadResponses.map((uploadResponse) => ({
        secure_url: uploadResponse?.secure_url,
        public_id: uploadResponse?.public_id
      }));
      return savedFiles;
    } catch (error4) {
      return {
        error: error4.message
      };
    }
  }
  static async deleteFile(publicId) {
    try {
      const ids = Array.isArray(publicId) ? publicId : [publicId];
      const res = await cloudinaryConfig_default.api.delete_resources(ids);
      return true;
    } catch (error4) {
      return false;
    }
  }
};
__name(UploadService, "UploadService");
var uploadService_default = UploadService;

// src/controllers/products/get-product.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/db/db.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/neon-http/driver.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@neondatabase+serverless@0.10.1/node_modules/@neondatabase/serverless/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var no = Object.create;
var Te = Object.defineProperty;
var io = Object.getOwnPropertyDescriptor;
var so = Object.getOwnPropertyNames;
var oo = Object.getPrototypeOf;
var ao = Object.prototype.hasOwnProperty;
var uo = /* @__PURE__ */ __name((r3, e2, t2) => e2 in r3 ? Te(r3, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e2] = t2, "uo");
var a = /* @__PURE__ */ __name((r3, e2) => Te(r3, "name", { value: e2, configurable: true }), "a");
var z2 = /* @__PURE__ */ __name((r3, e2) => () => (r3 && (e2 = r3(r3 = 0)), e2), "z");
var I = /* @__PURE__ */ __name((r3, e2) => () => (e2 || r3((e2 = { exports: {} }).exports, e2), e2.exports), "I");
var ie = /* @__PURE__ */ __name((r3, e2) => {
  for (var t2 in e2)
    Te(r3, t2, { get: e2[t2], enumerable: true });
}, "ie");
var Cn = /* @__PURE__ */ __name((r3, e2, t2, n3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let i3 of so(e2))
      !ao.call(r3, i3) && i3 !== t2 && Te(r3, i3, { get: () => e2[i3], enumerable: !(n3 = io(e2, i3)) || n3.enumerable });
  return r3;
}, "Cn");
var Ie = /* @__PURE__ */ __name((r3, e2, t2) => (t2 = r3 != null ? no(oo(r3)) : {}, Cn(e2 || !r3 || !r3.__esModule ? Te(t2, "default", {
  value: r3,
  enumerable: true
}) : t2, r3)), "Ie");
var N = /* @__PURE__ */ __name((r3) => Cn(Te({}, "__esModule", { value: true }), r3), "N");
var _ = /* @__PURE__ */ __name((r3, e2, t2) => uo(r3, typeof e2 != "symbol" ? e2 + "" : e2, t2), "_");
var Pn = I((it) => {
  "use strict";
  p2();
  it.byteLength = ho;
  it.toByteArray = fo;
  it.fromByteArray = mo;
  var se = [], te = [], co = typeof Uint8Array < "u" ? Uint8Array : Array, Lt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (ve = 0, Tn = Lt.length; ve < Tn; ++ve)
    se[ve] = Lt[ve], te[Lt.charCodeAt(ve)] = ve;
  var ve, Tn;
  te[45] = 62;
  te[95] = 63;
  function In(r3) {
    var e2 = r3.length;
    if (e2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t2 = r3.indexOf("=");
    t2 === -1 && (t2 = e2);
    var n3 = t2 === e2 ? 0 : 4 - t2 % 4;
    return [t2, n3];
  }
  __name(In, "In");
  a(
    In,
    "getLens"
  );
  function ho(r3) {
    var e2 = In(r3), t2 = e2[0], n3 = e2[1];
    return (t2 + n3) * 3 / 4 - n3;
  }
  __name(ho, "ho");
  a(ho, "byteLength");
  function lo(r3, e2, t2) {
    return (e2 + t2) * 3 / 4 - t2;
  }
  __name(lo, "lo");
  a(lo, "_byteLength");
  function fo(r3) {
    var e2, t2 = In(r3), n3 = t2[0], i3 = t2[1], s3 = new co(lo(r3, n3, i3)), o4 = 0, u3 = i3 > 0 ? n3 - 4 : n3, c4;
    for (c4 = 0; c4 < u3; c4 += 4)
      e2 = te[r3.charCodeAt(c4)] << 18 | te[r3.charCodeAt(c4 + 1)] << 12 | te[r3.charCodeAt(c4 + 2)] << 6 | te[r3.charCodeAt(c4 + 3)], s3[o4++] = e2 >> 16 & 255, s3[o4++] = e2 >> 8 & 255, s3[o4++] = e2 & 255;
    return i3 === 2 && (e2 = te[r3.charCodeAt(c4)] << 2 | te[r3.charCodeAt(c4 + 1)] >> 4, s3[o4++] = e2 & 255), i3 === 1 && (e2 = te[r3.charCodeAt(
      c4
    )] << 10 | te[r3.charCodeAt(c4 + 1)] << 4 | te[r3.charCodeAt(c4 + 2)] >> 2, s3[o4++] = e2 >> 8 & 255, s3[o4++] = e2 & 255), s3;
  }
  __name(fo, "fo");
  a(fo, "toByteArray");
  function po(r3) {
    return se[r3 >> 18 & 63] + se[r3 >> 12 & 63] + se[r3 >> 6 & 63] + se[r3 & 63];
  }
  __name(po, "po");
  a(po, "tripletToBase64");
  function yo(r3, e2, t2) {
    for (var n3, i3 = [], s3 = e2; s3 < t2; s3 += 3)
      n3 = (r3[s3] << 16 & 16711680) + (r3[s3 + 1] << 8 & 65280) + (r3[s3 + 2] & 255), i3.push(po(n3));
    return i3.join(
      ""
    );
  }
  __name(yo, "yo");
  a(yo, "encodeChunk");
  function mo(r3) {
    for (var e2, t2 = r3.length, n3 = t2 % 3, i3 = [], s3 = 16383, o4 = 0, u3 = t2 - n3; o4 < u3; o4 += s3)
      i3.push(yo(r3, o4, o4 + s3 > u3 ? u3 : o4 + s3));
    return n3 === 1 ? (e2 = r3[t2 - 1], i3.push(se[e2 >> 2] + se[e2 << 4 & 63] + "==")) : n3 === 2 && (e2 = (r3[t2 - 2] << 8) + r3[t2 - 1], i3.push(se[e2 >> 10] + se[e2 >> 4 & 63] + se[e2 << 2 & 63] + "=")), i3.join("");
  }
  __name(mo, "mo");
  a(mo, "fromByteArray");
});
var Bn = I((Rt) => {
  p2();
  Rt.read = function(r3, e2, t2, n3, i3) {
    var s3, o4, u3 = i3 * 8 - n3 - 1, c4 = (1 << u3) - 1, h2 = c4 >> 1, l3 = -7, d3 = t2 ? i3 - 1 : 0, b3 = t2 ? -1 : 1, C3 = r3[e2 + d3];
    for (d3 += b3, s3 = C3 & (1 << -l3) - 1, C3 >>= -l3, l3 += u3; l3 > 0; s3 = s3 * 256 + r3[e2 + d3], d3 += b3, l3 -= 8)
      ;
    for (o4 = s3 & (1 << -l3) - 1, s3 >>= -l3, l3 += n3; l3 > 0; o4 = o4 * 256 + r3[e2 + d3], d3 += b3, l3 -= 8)
      ;
    if (s3 === 0)
      s3 = 1 - h2;
    else {
      if (s3 === c4)
        return o4 ? NaN : (C3 ? -1 : 1) * (1 / 0);
      o4 = o4 + Math.pow(2, n3), s3 = s3 - h2;
    }
    return (C3 ? -1 : 1) * o4 * Math.pow(2, s3 - n3);
  };
  Rt.write = function(r3, e2, t2, n3, i3, s3) {
    var o4, u3, c4, h2 = s3 * 8 - i3 - 1, l3 = (1 << h2) - 1, d3 = l3 >> 1, b3 = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, C3 = n3 ? 0 : s3 - 1, B = n3 ? 1 : -1, j3 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
    for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (u3 = isNaN(e2) ? 1 : 0, o4 = l3) : (o4 = Math.floor(Math.log(e2) / Math.LN2), e2 * (c4 = Math.pow(2, -o4)) < 1 && (o4--, c4 *= 2), o4 + d3 >= 1 ? e2 += b3 / c4 : e2 += b3 * Math.pow(2, 1 - d3), e2 * c4 >= 2 && (o4++, c4 /= 2), o4 + d3 >= l3 ? (u3 = 0, o4 = l3) : o4 + d3 >= 1 ? (u3 = (e2 * c4 - 1) * Math.pow(
      2,
      i3
    ), o4 = o4 + d3) : (u3 = e2 * Math.pow(2, d3 - 1) * Math.pow(2, i3), o4 = 0)); i3 >= 8; r3[t2 + C3] = u3 & 255, C3 += B, u3 /= 256, i3 -= 8)
      ;
    for (o4 = o4 << i3 | u3, h2 += i3; h2 > 0; r3[t2 + C3] = o4 & 255, C3 += B, o4 /= 256, h2 -= 8)
      ;
    r3[t2 + C3 - B] |= j3 * 128;
  };
});
var Vn = I((Re) => {
  "use strict";
  p2();
  var Ft = Pn(), Be = Bn(), Ln = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Re.Buffer = f4;
  Re.SlowBuffer = xo;
  Re.INSPECT_MAX_BYTES = 50;
  var st = 2147483647;
  Re.kMaxLength = st;
  f4.TYPED_ARRAY_SUPPORT = go();
  !f4.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function go() {
    try {
      let r3 = new Uint8Array(1), e2 = { foo: a(function() {
        return 42;
      }, "foo") };
      return Object.setPrototypeOf(e2, Uint8Array.prototype), Object.setPrototypeOf(
        r3,
        e2
      ), r3.foo() === 42;
    } catch {
      return false;
    }
  }
  __name(go, "go");
  a(go, "typedArraySupport");
  Object.defineProperty(
    f4.prototype,
    "parent",
    { enumerable: true, get: a(function() {
      if (f4.isBuffer(this))
        return this.buffer;
    }, "get") }
  );
  Object.defineProperty(f4.prototype, "offset", { enumerable: true, get: a(
    function() {
      if (f4.isBuffer(this))
        return this.byteOffset;
    },
    "get"
  ) });
  function he(r3) {
    if (r3 > st)
      throw new RangeError('The value "' + r3 + '" is invalid for option "size"');
    let e2 = new Uint8Array(
      r3
    );
    return Object.setPrototypeOf(e2, f4.prototype), e2;
  }
  __name(he, "he");
  a(he, "createBuffer");
  function f4(r3, e2, t2) {
    if (typeof r3 == "number") {
      if (typeof e2 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Ot(r3);
    }
    return Dn(
      r3,
      e2,
      t2
    );
  }
  __name(f4, "f");
  a(f4, "Buffer");
  f4.poolSize = 8192;
  function Dn(r3, e2, t2) {
    if (typeof r3 == "string")
      return bo(
        r3,
        e2
      );
    if (ArrayBuffer.isView(r3))
      return So(r3);
    if (r3 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r3);
    if (oe(r3, ArrayBuffer) || r3 && oe(r3.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (oe(r3, SharedArrayBuffer) || r3 && oe(r3.buffer, SharedArrayBuffer)))
      return Dt(r3, e2, t2);
    if (typeof r3 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n3 = r3.valueOf && r3.valueOf();
    if (n3 != null && n3 !== r3)
      return f4.from(n3, e2, t2);
    let i3 = Eo(r3);
    if (i3)
      return i3;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r3[Symbol.toPrimitive] == "function")
      return f4.from(r3[Symbol.toPrimitive]("string"), e2, t2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r3);
  }
  __name(Dn, "Dn");
  a(Dn, "from");
  f4.from = function(r3, e2, t2) {
    return Dn(r3, e2, t2);
  };
  Object.setPrototypeOf(f4.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(
    f4,
    Uint8Array
  );
  function kn(r3) {
    if (typeof r3 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (r3 < 0)
      throw new RangeError('The value "' + r3 + '" is invalid for option "size"');
  }
  __name(kn, "kn");
  a(kn, "assertSize");
  function wo(r3, e2, t2) {
    return kn(r3), r3 <= 0 ? he(r3) : e2 !== void 0 ? typeof t2 == "string" ? he(r3).fill(e2, t2) : he(r3).fill(e2) : he(r3);
  }
  __name(wo, "wo");
  a(
    wo,
    "alloc"
  );
  f4.alloc = function(r3, e2, t2) {
    return wo(r3, e2, t2);
  };
  function Ot(r3) {
    return kn(r3), he(
      r3 < 0 ? 0 : Ut(r3) | 0
    );
  }
  __name(Ot, "Ot");
  a(Ot, "allocUnsafe");
  f4.allocUnsafe = function(r3) {
    return Ot(r3);
  };
  f4.allocUnsafeSlow = function(r3) {
    return Ot(r3);
  };
  function bo(r3, e2) {
    if ((typeof e2 != "string" || e2 === "") && (e2 = "utf8"), !f4.isEncoding(e2))
      throw new TypeError("Unknown encoding: " + e2);
    let t2 = On(r3, e2) | 0, n3 = he(t2), i3 = n3.write(r3, e2);
    return i3 !== t2 && (n3 = n3.slice(0, i3)), n3;
  }
  __name(bo, "bo");
  a(bo, "fromString");
  function Mt(r3) {
    let e2 = r3.length < 0 ? 0 : Ut(r3.length) | 0, t2 = he(e2);
    for (let n3 = 0; n3 < e2; n3 += 1)
      t2[n3] = r3[n3] & 255;
    return t2;
  }
  __name(Mt, "Mt");
  a(Mt, "fromArrayLike");
  function So(r3) {
    if (oe(r3, Uint8Array)) {
      let e2 = new Uint8Array(r3);
      return Dt(e2.buffer, e2.byteOffset, e2.byteLength);
    }
    return Mt(r3);
  }
  __name(So, "So");
  a(So, "fromArrayView");
  function Dt(r3, e2, t2) {
    if (e2 < 0 || r3.byteLength < e2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (r3.byteLength < e2 + (t2 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n3;
    return e2 === void 0 && t2 === void 0 ? n3 = new Uint8Array(
      r3
    ) : t2 === void 0 ? n3 = new Uint8Array(r3, e2) : n3 = new Uint8Array(r3, e2, t2), Object.setPrototypeOf(
      n3,
      f4.prototype
    ), n3;
  }
  __name(Dt, "Dt");
  a(Dt, "fromArrayBuffer");
  function Eo(r3) {
    if (f4.isBuffer(r3)) {
      let e2 = Ut(
        r3.length
      ) | 0, t2 = he(e2);
      return t2.length === 0 || r3.copy(t2, 0, 0, e2), t2;
    }
    if (r3.length !== void 0)
      return typeof r3.length != "number" || qt(r3.length) ? he(0) : Mt(r3);
    if (r3.type === "Buffer" && Array.isArray(r3.data))
      return Mt(r3.data);
  }
  __name(Eo, "Eo");
  a(Eo, "fromObject");
  function Ut(r3) {
    if (r3 >= st)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + st.toString(16) + " bytes");
    return r3 | 0;
  }
  __name(Ut, "Ut");
  a(Ut, "checked");
  function xo(r3) {
    return +r3 != r3 && (r3 = 0), f4.alloc(+r3);
  }
  __name(xo, "xo");
  a(xo, "SlowBuffer");
  f4.isBuffer = a(function(e2) {
    return e2 != null && e2._isBuffer === true && e2 !== f4.prototype;
  }, "isBuffer");
  f4.compare = a(function(e2, t2) {
    if (oe(e2, Uint8Array) && (e2 = f4.from(e2, e2.offset, e2.byteLength)), oe(t2, Uint8Array) && (t2 = f4.from(t2, t2.offset, t2.byteLength)), !f4.isBuffer(e2) || !f4.isBuffer(t2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e2 === t2)
      return 0;
    let n3 = e2.length, i3 = t2.length;
    for (let s3 = 0, o4 = Math.min(n3, i3); s3 < o4; ++s3)
      if (e2[s3] !== t2[s3]) {
        n3 = e2[s3], i3 = t2[s3];
        break;
      }
    return n3 < i3 ? -1 : i3 < n3 ? 1 : 0;
  }, "compare");
  f4.isEncoding = a(function(e2) {
    switch (String(e2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  f4.concat = a(function(e2, t2) {
    if (!Array.isArray(e2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e2.length === 0)
      return f4.alloc(0);
    let n3;
    if (t2 === void 0)
      for (t2 = 0, n3 = 0; n3 < e2.length; ++n3)
        t2 += e2[n3].length;
    let i3 = f4.allocUnsafe(t2), s3 = 0;
    for (n3 = 0; n3 < e2.length; ++n3) {
      let o4 = e2[n3];
      if (oe(o4, Uint8Array))
        s3 + o4.length > i3.length ? (f4.isBuffer(
          o4
        ) || (o4 = f4.from(o4)), o4.copy(i3, s3)) : Uint8Array.prototype.set.call(i3, o4, s3);
      else if (f4.isBuffer(
        o4
      ))
        o4.copy(i3, s3);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      s3 += o4.length;
    }
    return i3;
  }, "concat");
  function On(r3, e2) {
    if (f4.isBuffer(r3))
      return r3.length;
    if (ArrayBuffer.isView(r3) || oe(r3, ArrayBuffer))
      return r3.byteLength;
    if (typeof r3 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r3);
    let t2 = r3.length, n3 = arguments.length > 2 && arguments[2] === true;
    if (!n3 && t2 === 0)
      return 0;
    let i3 = false;
    for (; ; )
      switch (e2) {
        case "ascii":
        case "latin1":
        case "binary":
          return t2;
        case "utf8":
        case "utf-8":
          return kt(r3).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t2 * 2;
        case "hex":
          return t2 >>> 1;
        case "base64":
          return $n(r3).length;
        default:
          if (i3)
            return n3 ? -1 : kt(r3).length;
          e2 = ("" + e2).toLowerCase(), i3 = true;
      }
  }
  __name(On, "On");
  a(On, "byteLength");
  f4.byteLength = On;
  function vo(r3, e2, t2) {
    let n3 = false;
    if ((e2 === void 0 || e2 < 0) && (e2 = 0), e2 > this.length || ((t2 === void 0 || t2 > this.length) && (t2 = this.length), t2 <= 0) || (t2 >>>= 0, e2 >>>= 0, t2 <= e2))
      return "";
    for (r3 || (r3 = "utf8"); ; )
      switch (r3) {
        case "hex":
          return Fo(
            this,
            e2,
            t2
          );
        case "utf8":
        case "utf-8":
          return Nn(this, e2, t2);
        case "ascii":
          return Lo(
            this,
            e2,
            t2
          );
        case "latin1":
        case "binary":
          return Ro(this, e2, t2);
        case "base64":
          return Po(
            this,
            e2,
            t2
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Mo(this, e2, t2);
        default:
          if (n3)
            throw new TypeError("Unknown encoding: " + r3);
          r3 = (r3 + "").toLowerCase(), n3 = true;
      }
  }
  __name(vo, "vo");
  a(
    vo,
    "slowToString"
  );
  f4.prototype._isBuffer = true;
  function _e(r3, e2, t2) {
    let n3 = r3[e2];
    r3[e2] = r3[t2], r3[t2] = n3;
  }
  __name(_e, "_e");
  a(_e, "swap");
  f4.prototype.swap16 = a(function() {
    let e2 = this.length;
    if (e2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t2 = 0; t2 < e2; t2 += 2)
      _e(this, t2, t2 + 1);
    return this;
  }, "swap16");
  f4.prototype.swap32 = a(function() {
    let e2 = this.length;
    if (e2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t2 = 0; t2 < e2; t2 += 4)
      _e(this, t2, t2 + 3), _e(this, t2 + 1, t2 + 2);
    return this;
  }, "swap32");
  f4.prototype.swap64 = a(function() {
    let e2 = this.length;
    if (e2 % 8 !== 0)
      throw new RangeError(
        "Buffer size must be a multiple of 64-bits"
      );
    for (let t2 = 0; t2 < e2; t2 += 8)
      _e(this, t2, t2 + 7), _e(this, t2 + 1, t2 + 6), _e(this, t2 + 2, t2 + 5), _e(this, t2 + 3, t2 + 4);
    return this;
  }, "swap64");
  f4.prototype.toString = a(function() {
    let e2 = this.length;
    return e2 === 0 ? "" : arguments.length === 0 ? Nn(
      this,
      0,
      e2
    ) : vo.apply(this, arguments);
  }, "toString");
  f4.prototype.toLocaleString = f4.prototype.toString;
  f4.prototype.equals = a(function(e2) {
    if (!f4.isBuffer(e2))
      throw new TypeError(
        "Argument must be a Buffer"
      );
    return this === e2 ? true : f4.compare(this, e2) === 0;
  }, "equals");
  f4.prototype.inspect = a(function() {
    let e2 = "", t2 = Re.INSPECT_MAX_BYTES;
    return e2 = this.toString(
      "hex",
      0,
      t2
    ).replace(/(.{2})/g, "$1 ").trim(), this.length > t2 && (e2 += " ... "), "<Buffer " + e2 + ">";
  }, "inspect");
  Ln && (f4.prototype[Ln] = f4.prototype.inspect);
  f4.prototype.compare = a(function(e2, t2, n3, i3, s3) {
    if (oe(e2, Uint8Array) && (e2 = f4.from(e2, e2.offset, e2.byteLength)), !f4.isBuffer(e2))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
    if (t2 === void 0 && (t2 = 0), n3 === void 0 && (n3 = e2 ? e2.length : 0), i3 === void 0 && (i3 = 0), s3 === void 0 && (s3 = this.length), t2 < 0 || n3 > e2.length || i3 < 0 || s3 > this.length)
      throw new RangeError("out of range index");
    if (i3 >= s3 && t2 >= n3)
      return 0;
    if (i3 >= s3)
      return -1;
    if (t2 >= n3)
      return 1;
    if (t2 >>>= 0, n3 >>>= 0, i3 >>>= 0, s3 >>>= 0, this === e2)
      return 0;
    let o4 = s3 - i3, u3 = n3 - t2, c4 = Math.min(o4, u3), h2 = this.slice(i3, s3), l3 = e2.slice(t2, n3);
    for (let d3 = 0; d3 < c4; ++d3)
      if (h2[d3] !== l3[d3]) {
        o4 = h2[d3], u3 = l3[d3];
        break;
      }
    return o4 < u3 ? -1 : u3 < o4 ? 1 : 0;
  }, "compare");
  function Un(r3, e2, t2, n3, i3) {
    if (r3.length === 0)
      return -1;
    if (typeof t2 == "string" ? (n3 = t2, t2 = 0) : t2 > 2147483647 ? t2 = 2147483647 : t2 < -2147483648 && (t2 = -2147483648), t2 = +t2, qt(t2) && (t2 = i3 ? 0 : r3.length - 1), t2 < 0 && (t2 = r3.length + t2), t2 >= r3.length) {
      if (i3)
        return -1;
      t2 = r3.length - 1;
    } else if (t2 < 0)
      if (i3)
        t2 = 0;
      else
        return -1;
    if (typeof e2 == "string" && (e2 = f4.from(e2, n3)), f4.isBuffer(e2))
      return e2.length === 0 ? -1 : Rn(r3, e2, t2, n3, i3);
    if (typeof e2 == "number")
      return e2 = e2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? i3 ? Uint8Array.prototype.indexOf.call(r3, e2, t2) : Uint8Array.prototype.lastIndexOf.call(r3, e2, t2) : Rn(
        r3,
        [e2],
        t2,
        n3,
        i3
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  __name(Un, "Un");
  a(Un, "bidirectionalIndexOf");
  function Rn(r3, e2, t2, n3, i3) {
    let s3 = 1, o4 = r3.length, u3 = e2.length;
    if (n3 !== void 0 && (n3 = String(n3).toLowerCase(), n3 === "ucs2" || n3 === "ucs-2" || n3 === "utf16le" || n3 === "utf-16le")) {
      if (r3.length < 2 || e2.length < 2)
        return -1;
      s3 = 2, o4 /= 2, u3 /= 2, t2 /= 2;
    }
    function c4(l3, d3) {
      return s3 === 1 ? l3[d3] : l3.readUInt16BE(d3 * s3);
    }
    __name(c4, "c");
    a(c4, "read");
    let h2;
    if (i3) {
      let l3 = -1;
      for (h2 = t2; h2 < o4; h2++)
        if (c4(r3, h2) === c4(e2, l3 === -1 ? 0 : h2 - l3)) {
          if (l3 === -1 && (l3 = h2), h2 - l3 + 1 === u3)
            return l3 * s3;
        } else
          l3 !== -1 && (h2 -= h2 - l3), l3 = -1;
    } else
      for (t2 + u3 > o4 && (t2 = o4 - u3), h2 = t2; h2 >= 0; h2--) {
        let l3 = true;
        for (let d3 = 0; d3 < u3; d3++)
          if (c4(r3, h2 + d3) !== c4(e2, d3)) {
            l3 = false;
            break;
          }
        if (l3)
          return h2;
      }
    return -1;
  }
  __name(Rn, "Rn");
  a(Rn, "arrayIndexOf");
  f4.prototype.includes = a(function(e2, t2, n3) {
    return this.indexOf(e2, t2, n3) !== -1;
  }, "includes");
  f4.prototype.indexOf = a(function(e2, t2, n3) {
    return Un(this, e2, t2, n3, true);
  }, "indexOf");
  f4.prototype.lastIndexOf = a(function(e2, t2, n3) {
    return Un(this, e2, t2, n3, false);
  }, "lastIndexOf");
  function _o(r3, e2, t2, n3) {
    t2 = Number(t2) || 0;
    let i3 = r3.length - t2;
    n3 ? (n3 = Number(n3), n3 > i3 && (n3 = i3)) : n3 = i3;
    let s3 = e2.length;
    n3 > s3 / 2 && (n3 = s3 / 2);
    let o4;
    for (o4 = 0; o4 < n3; ++o4) {
      let u3 = parseInt(e2.substr(o4 * 2, 2), 16);
      if (qt(u3))
        return o4;
      r3[t2 + o4] = u3;
    }
    return o4;
  }
  __name(_o, "_o");
  a(_o, "hexWrite");
  function Ao(r3, e2, t2, n3) {
    return ot(kt(
      e2,
      r3.length - t2
    ), r3, t2, n3);
  }
  __name(Ao, "Ao");
  a(Ao, "utf8Write");
  function Co(r3, e2, t2, n3) {
    return ot(Uo(e2), r3, t2, n3);
  }
  __name(Co, "Co");
  a(Co, "asciiWrite");
  function To(r3, e2, t2, n3) {
    return ot($n(e2), r3, t2, n3);
  }
  __name(To, "To");
  a(To, "base64Write");
  function Io(r3, e2, t2, n3) {
    return ot(No(e2, r3.length - t2), r3, t2, n3);
  }
  __name(Io, "Io");
  a(Io, "ucs2Write");
  f4.prototype.write = a(function(e2, t2, n3, i3) {
    if (t2 === void 0)
      i3 = "utf8", n3 = this.length, t2 = 0;
    else if (n3 === void 0 && typeof t2 == "string")
      i3 = t2, n3 = this.length, t2 = 0;
    else if (isFinite(t2))
      t2 = t2 >>> 0, isFinite(n3) ? (n3 = n3 >>> 0, i3 === void 0 && (i3 = "utf8")) : (i3 = n3, n3 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s3 = this.length - t2;
    if ((n3 === void 0 || n3 > s3) && (n3 = s3), e2.length > 0 && (n3 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError(
        "Attempt to write outside buffer bounds"
      );
    i3 || (i3 = "utf8");
    let o4 = false;
    for (; ; )
      switch (i3) {
        case "hex":
          return _o(this, e2, t2, n3);
        case "utf8":
        case "utf-8":
          return Ao(this, e2, t2, n3);
        case "ascii":
        case "latin1":
        case "binary":
          return Co(this, e2, t2, n3);
        case "base64":
          return To(
            this,
            e2,
            t2,
            n3
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Io(this, e2, t2, n3);
        default:
          if (o4)
            throw new TypeError("Unknown encoding: " + i3);
          i3 = ("" + i3).toLowerCase(), o4 = true;
      }
  }, "write");
  f4.prototype.toJSON = a(function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  }, "toJSON");
  function Po(r3, e2, t2) {
    return e2 === 0 && t2 === r3.length ? Ft.fromByteArray(r3) : Ft.fromByteArray(r3.slice(e2, t2));
  }
  __name(Po, "Po");
  a(Po, "base64Slice");
  function Nn(r3, e2, t2) {
    t2 = Math.min(r3.length, t2);
    let n3 = [], i3 = e2;
    for (; i3 < t2; ) {
      let s3 = r3[i3], o4 = null, u3 = s3 > 239 ? 4 : s3 > 223 ? 3 : s3 > 191 ? 2 : 1;
      if (i3 + u3 <= t2) {
        let c4, h2, l3, d3;
        switch (u3) {
          case 1:
            s3 < 128 && (o4 = s3);
            break;
          case 2:
            c4 = r3[i3 + 1], (c4 & 192) === 128 && (d3 = (s3 & 31) << 6 | c4 & 63, d3 > 127 && (o4 = d3));
            break;
          case 3:
            c4 = r3[i3 + 1], h2 = r3[i3 + 2], (c4 & 192) === 128 && (h2 & 192) === 128 && (d3 = (s3 & 15) << 12 | (c4 & 63) << 6 | h2 & 63, d3 > 2047 && (d3 < 55296 || d3 > 57343) && (o4 = d3));
            break;
          case 4:
            c4 = r3[i3 + 1], h2 = r3[i3 + 2], l3 = r3[i3 + 3], (c4 & 192) === 128 && (h2 & 192) === 128 && (l3 & 192) === 128 && (d3 = (s3 & 15) << 18 | (c4 & 63) << 12 | (h2 & 63) << 6 | l3 & 63, d3 > 65535 && d3 < 1114112 && (o4 = d3));
        }
      }
      o4 === null ? (o4 = 65533, u3 = 1) : o4 > 65535 && (o4 -= 65536, n3.push(o4 >>> 10 & 1023 | 55296), o4 = 56320 | o4 & 1023), n3.push(o4), i3 += u3;
    }
    return Bo(n3);
  }
  __name(Nn, "Nn");
  a(Nn, "utf8Slice");
  var Fn = 4096;
  function Bo(r3) {
    let e2 = r3.length;
    if (e2 <= Fn)
      return String.fromCharCode.apply(String, r3);
    let t2 = "", n3 = 0;
    for (; n3 < e2; )
      t2 += String.fromCharCode.apply(String, r3.slice(n3, n3 += Fn));
    return t2;
  }
  __name(Bo, "Bo");
  a(Bo, "decodeCodePointsArray");
  function Lo(r3, e2, t2) {
    let n3 = "";
    t2 = Math.min(r3.length, t2);
    for (let i3 = e2; i3 < t2; ++i3)
      n3 += String.fromCharCode(r3[i3] & 127);
    return n3;
  }
  __name(Lo, "Lo");
  a(Lo, "asciiSlice");
  function Ro(r3, e2, t2) {
    let n3 = "";
    t2 = Math.min(r3.length, t2);
    for (let i3 = e2; i3 < t2; ++i3)
      n3 += String.fromCharCode(r3[i3]);
    return n3;
  }
  __name(Ro, "Ro");
  a(Ro, "latin1Slice");
  function Fo(r3, e2, t2) {
    let n3 = r3.length;
    (!e2 || e2 < 0) && (e2 = 0), (!t2 || t2 < 0 || t2 > n3) && (t2 = n3);
    let i3 = "";
    for (let s3 = e2; s3 < t2; ++s3)
      i3 += qo[r3[s3]];
    return i3;
  }
  __name(Fo, "Fo");
  a(Fo, "hexSlice");
  function Mo(r3, e2, t2) {
    let n3 = r3.slice(e2, t2), i3 = "";
    for (let s3 = 0; s3 < n3.length - 1; s3 += 2)
      i3 += String.fromCharCode(n3[s3] + n3[s3 + 1] * 256);
    return i3;
  }
  __name(Mo, "Mo");
  a(Mo, "utf16leSlice");
  f4.prototype.slice = a(function(e2, t2) {
    let n3 = this.length;
    e2 = ~~e2, t2 = t2 === void 0 ? n3 : ~~t2, e2 < 0 ? (e2 += n3, e2 < 0 && (e2 = 0)) : e2 > n3 && (e2 = n3), t2 < 0 ? (t2 += n3, t2 < 0 && (t2 = 0)) : t2 > n3 && (t2 = n3), t2 < e2 && (t2 = e2);
    let i3 = this.subarray(
      e2,
      t2
    );
    return Object.setPrototypeOf(i3, f4.prototype), i3;
  }, "slice");
  function q(r3, e2, t2) {
    if (r3 % 1 !== 0 || r3 < 0)
      throw new RangeError("offset is not uint");
    if (r3 + e2 > t2)
      throw new RangeError(
        "Trying to access beyond buffer length"
      );
  }
  __name(q, "q");
  a(q, "checkOffset");
  f4.prototype.readUintLE = f4.prototype.readUIntLE = a(function(e2, t2, n3) {
    e2 = e2 >>> 0, t2 = t2 >>> 0, n3 || q(e2, t2, this.length);
    let i3 = this[e2], s3 = 1, o4 = 0;
    for (; ++o4 < t2 && (s3 *= 256); )
      i3 += this[e2 + o4] * s3;
    return i3;
  }, "readUIntLE");
  f4.prototype.readUintBE = f4.prototype.readUIntBE = a(function(e2, t2, n3) {
    e2 = e2 >>> 0, t2 = t2 >>> 0, n3 || q(e2, t2, this.length);
    let i3 = this[e2 + --t2], s3 = 1;
    for (; t2 > 0 && (s3 *= 256); )
      i3 += this[e2 + --t2] * s3;
    return i3;
  }, "readUIntBE");
  f4.prototype.readUint8 = f4.prototype.readUInt8 = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 1, this.length), this[e2];
  }, "readUInt8");
  f4.prototype.readUint16LE = f4.prototype.readUInt16LE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
  }, "readUInt16LE");
  f4.prototype.readUint16BE = f4.prototype.readUInt16BE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
  }, "readUInt16BE");
  f4.prototype.readUint32LE = f4.prototype.readUInt32LE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + this[e2 + 3] * 16777216;
  }, "readUInt32LE");
  f4.prototype.readUint32BE = f4.prototype.readUInt32BE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), this[e2] * 16777216 + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
  }, "readUInt32BE");
  f4.prototype.readBigUInt64LE = ge(a(function(e2) {
    e2 = e2 >>> 0, Le(e2, "offset");
    let t2 = this[e2], n3 = this[e2 + 7];
    (t2 === void 0 || n3 === void 0) && We(e2, this.length - 8);
    let i3 = t2 + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 24, s3 = this[++e2] + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + n3 * 2 ** 24;
    return BigInt(i3) + (BigInt(s3) << BigInt(32));
  }, "readBigUInt64LE"));
  f4.prototype.readBigUInt64BE = ge(a(function(e2) {
    e2 = e2 >>> 0, Le(e2, "offset");
    let t2 = this[e2], n3 = this[e2 + 7];
    (t2 === void 0 || n3 === void 0) && We(e2, this.length - 8);
    let i3 = t2 * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + this[++e2], s3 = this[++e2] * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + n3;
    return (BigInt(
      i3
    ) << BigInt(32)) + BigInt(s3);
  }, "readBigUInt64BE"));
  f4.prototype.readIntLE = a(function(e2, t2, n3) {
    e2 = e2 >>> 0, t2 = t2 >>> 0, n3 || q(e2, t2, this.length);
    let i3 = this[e2], s3 = 1, o4 = 0;
    for (; ++o4 < t2 && (s3 *= 256); )
      i3 += this[e2 + o4] * s3;
    return s3 *= 128, i3 >= s3 && (i3 -= Math.pow(2, 8 * t2)), i3;
  }, "readIntLE");
  f4.prototype.readIntBE = a(function(e2, t2, n3) {
    e2 = e2 >>> 0, t2 = t2 >>> 0, n3 || q(e2, t2, this.length);
    let i3 = t2, s3 = 1, o4 = this[e2 + --i3];
    for (; i3 > 0 && (s3 *= 256); )
      o4 += this[e2 + --i3] * s3;
    return s3 *= 128, o4 >= s3 && (o4 -= Math.pow(2, 8 * t2)), o4;
  }, "readIntBE");
  f4.prototype.readInt8 = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 1, this.length), this[e2] & 128 ? (255 - this[e2] + 1) * -1 : this[e2];
  }, "readInt8");
  f4.prototype.readInt16LE = a(function(e2, t2) {
    e2 = e2 >>> 0, t2 || q(e2, 2, this.length);
    let n3 = this[e2] | this[e2 + 1] << 8;
    return n3 & 32768 ? n3 | 4294901760 : n3;
  }, "readInt16LE");
  f4.prototype.readInt16BE = a(
    function(e2, t2) {
      e2 = e2 >>> 0, t2 || q(e2, 2, this.length);
      let n3 = this[e2 + 1] | this[e2] << 8;
      return n3 & 32768 ? n3 | 4294901760 : n3;
    },
    "readInt16BE"
  );
  f4.prototype.readInt32LE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
  }, "readInt32LE");
  f4.prototype.readInt32BE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
  }, "readInt32BE");
  f4.prototype.readBigInt64LE = ge(a(function(e2) {
    e2 = e2 >>> 0, Le(e2, "offset");
    let t2 = this[e2], n3 = this[e2 + 7];
    (t2 === void 0 || n3 === void 0) && We(
      e2,
      this.length - 8
    );
    let i3 = this[e2 + 4] + this[e2 + 5] * 2 ** 8 + this[e2 + 6] * 2 ** 16 + (n3 << 24);
    return (BigInt(
      i3
    ) << BigInt(32)) + BigInt(t2 + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 24);
  }, "readBigInt64LE"));
  f4.prototype.readBigInt64BE = ge(a(function(e2) {
    e2 = e2 >>> 0, Le(e2, "offset");
    let t2 = this[e2], n3 = this[e2 + 7];
    (t2 === void 0 || n3 === void 0) && We(e2, this.length - 8);
    let i3 = (t2 << 24) + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + this[++e2];
    return (BigInt(i3) << BigInt(32)) + BigInt(
      this[++e2] * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + n3
    );
  }, "readBigInt64BE"));
  f4.prototype.readFloatLE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), Be.read(
      this,
      e2,
      true,
      23,
      4
    );
  }, "readFloatLE");
  f4.prototype.readFloatBE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 4, this.length), Be.read(this, e2, false, 23, 4);
  }, "readFloatBE");
  f4.prototype.readDoubleLE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 8, this.length), Be.read(this, e2, true, 52, 8);
  }, "readDoubleLE");
  f4.prototype.readDoubleBE = a(function(e2, t2) {
    return e2 = e2 >>> 0, t2 || q(e2, 8, this.length), Be.read(this, e2, false, 52, 8);
  }, "readDoubleBE");
  function Y(r3, e2, t2, n3, i3, s3) {
    if (!f4.isBuffer(
      r3
    ))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e2 > i3 || e2 < s3)
      throw new RangeError('"value" argument is out of bounds');
    if (t2 + n3 > r3.length)
      throw new RangeError(
        "Index out of range"
      );
  }
  __name(Y, "Y");
  a(Y, "checkInt");
  f4.prototype.writeUintLE = f4.prototype.writeUIntLE = a(function(e2, t2, n3, i3) {
    if (e2 = +e2, t2 = t2 >>> 0, n3 = n3 >>> 0, !i3) {
      let u3 = Math.pow(2, 8 * n3) - 1;
      Y(
        this,
        e2,
        t2,
        n3,
        u3,
        0
      );
    }
    let s3 = 1, o4 = 0;
    for (this[t2] = e2 & 255; ++o4 < n3 && (s3 *= 256); )
      this[t2 + o4] = e2 / s3 & 255;
    return t2 + n3;
  }, "writeUIntLE");
  f4.prototype.writeUintBE = f4.prototype.writeUIntBE = a(function(e2, t2, n3, i3) {
    if (e2 = +e2, t2 = t2 >>> 0, n3 = n3 >>> 0, !i3) {
      let u3 = Math.pow(2, 8 * n3) - 1;
      Y(this, e2, t2, n3, u3, 0);
    }
    let s3 = n3 - 1, o4 = 1;
    for (this[t2 + s3] = e2 & 255; --s3 >= 0 && (o4 *= 256); )
      this[t2 + s3] = e2 / o4 & 255;
    return t2 + n3;
  }, "writeUIntBE");
  f4.prototype.writeUint8 = f4.prototype.writeUInt8 = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 1, 255, 0), this[t2] = e2 & 255, t2 + 1;
  }, "writeUInt8");
  f4.prototype.writeUint16LE = f4.prototype.writeUInt16LE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(
      this,
      e2,
      t2,
      2,
      65535,
      0
    ), this[t2] = e2 & 255, this[t2 + 1] = e2 >>> 8, t2 + 2;
  }, "writeUInt16LE");
  f4.prototype.writeUint16BE = f4.prototype.writeUInt16BE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(
      this,
      e2,
      t2,
      2,
      65535,
      0
    ), this[t2] = e2 >>> 8, this[t2 + 1] = e2 & 255, t2 + 2;
  }, "writeUInt16BE");
  f4.prototype.writeUint32LE = f4.prototype.writeUInt32LE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(
      this,
      e2,
      t2,
      4,
      4294967295,
      0
    ), this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = e2 & 255, t2 + 4;
  }, "writeUInt32LE");
  f4.prototype.writeUint32BE = f4.prototype.writeUInt32BE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 4, 4294967295, 0), this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = e2 & 255, t2 + 4;
  }, "writeUInt32BE");
  function qn(r3, e2, t2, n3, i3) {
    Gn(
      e2,
      n3,
      i3,
      r3,
      t2,
      7
    );
    let s3 = Number(e2 & BigInt(4294967295));
    r3[t2++] = s3, s3 = s3 >> 8, r3[t2++] = s3, s3 = s3 >> 8, r3[t2++] = s3, s3 = s3 >> 8, r3[t2++] = s3;
    let o4 = Number(e2 >> BigInt(32) & BigInt(4294967295));
    return r3[t2++] = o4, o4 = o4 >> 8, r3[t2++] = o4, o4 = o4 >> 8, r3[t2++] = o4, o4 = o4 >> 8, r3[t2++] = o4, t2;
  }
  __name(qn, "qn");
  a(qn, "wrtBigUInt64LE");
  function Qn(r3, e2, t2, n3, i3) {
    Gn(e2, n3, i3, r3, t2, 7);
    let s3 = Number(e2 & BigInt(4294967295));
    r3[t2 + 7] = s3, s3 = s3 >> 8, r3[t2 + 6] = s3, s3 = s3 >> 8, r3[t2 + 5] = s3, s3 = s3 >> 8, r3[t2 + 4] = s3;
    let o4 = Number(e2 >> BigInt(32) & BigInt(4294967295));
    return r3[t2 + 3] = o4, o4 = o4 >> 8, r3[t2 + 2] = o4, o4 = o4 >> 8, r3[t2 + 1] = o4, o4 = o4 >> 8, r3[t2] = o4, t2 + 8;
  }
  __name(Qn, "Qn");
  a(Qn, "wrtBigUInt64BE");
  f4.prototype.writeBigUInt64LE = ge(a(function(e2, t2 = 0) {
    return qn(this, e2, t2, BigInt(0), BigInt(
      "0xffffffffffffffff"
    ));
  }, "writeBigUInt64LE"));
  f4.prototype.writeBigUInt64BE = ge(a(function(e2, t2 = 0) {
    return Qn(this, e2, t2, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64BE"));
  f4.prototype.writeIntLE = a(function(e2, t2, n3, i3) {
    if (e2 = +e2, t2 = t2 >>> 0, !i3) {
      let c4 = Math.pow(
        2,
        8 * n3 - 1
      );
      Y(this, e2, t2, n3, c4 - 1, -c4);
    }
    let s3 = 0, o4 = 1, u3 = 0;
    for (this[t2] = e2 & 255; ++s3 < n3 && (o4 *= 256); )
      e2 < 0 && u3 === 0 && this[t2 + s3 - 1] !== 0 && (u3 = 1), this[t2 + s3] = (e2 / o4 >> 0) - u3 & 255;
    return t2 + n3;
  }, "writeIntLE");
  f4.prototype.writeIntBE = a(function(e2, t2, n3, i3) {
    if (e2 = +e2, t2 = t2 >>> 0, !i3) {
      let c4 = Math.pow(
        2,
        8 * n3 - 1
      );
      Y(this, e2, t2, n3, c4 - 1, -c4);
    }
    let s3 = n3 - 1, o4 = 1, u3 = 0;
    for (this[t2 + s3] = e2 & 255; --s3 >= 0 && (o4 *= 256); )
      e2 < 0 && u3 === 0 && this[t2 + s3 + 1] !== 0 && (u3 = 1), this[t2 + s3] = (e2 / o4 >> 0) - u3 & 255;
    return t2 + n3;
  }, "writeIntBE");
  f4.prototype.writeInt8 = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(
      this,
      e2,
      t2,
      1,
      127,
      -128
    ), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = e2 & 255, t2 + 1;
  }, "writeInt8");
  f4.prototype.writeInt16LE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 2, 32767, -32768), this[t2] = e2 & 255, this[t2 + 1] = e2 >>> 8, t2 + 2;
  }, "writeInt16LE");
  f4.prototype.writeInt16BE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 2, 32767, -32768), this[t2] = e2 >>> 8, this[t2 + 1] = e2 & 255, t2 + 2;
  }, "writeInt16BE");
  f4.prototype.writeInt32LE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 4, 2147483647, -2147483648), this[t2] = e2 & 255, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24, t2 + 4;
  }, "writeInt32LE");
  f4.prototype.writeInt32BE = a(function(e2, t2, n3) {
    return e2 = +e2, t2 = t2 >>> 0, n3 || Y(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = e2 & 255, t2 + 4;
  }, "writeInt32BE");
  f4.prototype.writeBigInt64LE = ge(a(function(e2, t2 = 0) {
    return qn(this, e2, t2, -BigInt(
      "0x8000000000000000"
    ), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  f4.prototype.writeBigInt64BE = ge(a(function(e2, t2 = 0) {
    return Qn(this, e2, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64BE"));
  function jn(r3, e2, t2, n3, i3, s3) {
    if (t2 + n3 > r3.length)
      throw new RangeError("Index out of range");
    if (t2 < 0)
      throw new RangeError(
        "Index out of range"
      );
  }
  __name(jn, "jn");
  a(jn, "checkIEEE754");
  function Wn(r3, e2, t2, n3, i3) {
    return e2 = +e2, t2 = t2 >>> 0, i3 || jn(r3, e2, t2, 4, 34028234663852886e22, -34028234663852886e22), Be.write(
      r3,
      e2,
      t2,
      n3,
      23,
      4
    ), t2 + 4;
  }
  __name(Wn, "Wn");
  a(Wn, "writeFloat");
  f4.prototype.writeFloatLE = a(function(e2, t2, n3) {
    return Wn(
      this,
      e2,
      t2,
      true,
      n3
    );
  }, "writeFloatLE");
  f4.prototype.writeFloatBE = a(function(e2, t2, n3) {
    return Wn(
      this,
      e2,
      t2,
      false,
      n3
    );
  }, "writeFloatBE");
  function Hn(r3, e2, t2, n3, i3) {
    return e2 = +e2, t2 = t2 >>> 0, i3 || jn(
      r3,
      e2,
      t2,
      8,
      17976931348623157e292,
      -17976931348623157e292
    ), Be.write(r3, e2, t2, n3, 52, 8), t2 + 8;
  }
  __name(Hn, "Hn");
  a(Hn, "writeDouble");
  f4.prototype.writeDoubleLE = a(function(e2, t2, n3) {
    return Hn(
      this,
      e2,
      t2,
      true,
      n3
    );
  }, "writeDoubleLE");
  f4.prototype.writeDoubleBE = a(function(e2, t2, n3) {
    return Hn(
      this,
      e2,
      t2,
      false,
      n3
    );
  }, "writeDoubleBE");
  f4.prototype.copy = a(function(e2, t2, n3, i3) {
    if (!f4.isBuffer(
      e2
    ))
      throw new TypeError("argument should be a Buffer");
    if (n3 || (n3 = 0), !i3 && i3 !== 0 && (i3 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), i3 > 0 && i3 < n3 && (i3 = n3), i3 === n3 || e2.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n3 < 0 || n3 >= this.length)
      throw new RangeError("Index out of range");
    if (i3 < 0)
      throw new RangeError(
        "sourceEnd out of bounds"
      );
    i3 > this.length && (i3 = this.length), e2.length - t2 < i3 - n3 && (i3 = e2.length - t2 + n3);
    let s3 = i3 - n3;
    return this === e2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t2, n3, i3) : Uint8Array.prototype.set.call(e2, this.subarray(n3, i3), t2), s3;
  }, "copy");
  f4.prototype.fill = a(function(e2, t2, n3, i3) {
    if (typeof e2 == "string") {
      if (typeof t2 == "string" ? (i3 = t2, t2 = 0, n3 = this.length) : typeof n3 == "string" && (i3 = n3, n3 = this.length), i3 !== void 0 && typeof i3 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i3 == "string" && !f4.isEncoding(i3))
        throw new TypeError("Unknown encoding: " + i3);
      if (e2.length === 1) {
        let o4 = e2.charCodeAt(0);
        (i3 === "utf8" && o4 < 128 || i3 === "latin1") && (e2 = o4);
      }
    } else
      typeof e2 == "number" ? e2 = e2 & 255 : typeof e2 == "boolean" && (e2 = Number(e2));
    if (t2 < 0 || this.length < t2 || this.length < n3)
      throw new RangeError("Out of range index");
    if (n3 <= t2)
      return this;
    t2 = t2 >>> 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e2 || (e2 = 0);
    let s3;
    if (typeof e2 == "number")
      for (s3 = t2; s3 < n3; ++s3)
        this[s3] = e2;
    else {
      let o4 = f4.isBuffer(e2) ? e2 : f4.from(e2, i3), u3 = o4.length;
      if (u3 === 0)
        throw new TypeError(
          'The value "' + e2 + '" is invalid for argument "value"'
        );
      for (s3 = 0; s3 < n3 - t2; ++s3)
        this[s3 + t2] = o4[s3 % u3];
    }
    return this;
  }, "fill");
  var Pe = {};
  function Nt(r3, e2, t2) {
    var n3;
    Pe[r3] = (n3 = /* @__PURE__ */ __name(class extends t2 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: e2.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${r3}]`, this.stack, delete this.name;
      }
      get code() {
        return r3;
      }
      set code(s3) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: s3,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${r3}]: ${this.message}`;
      }
    }, "n"), a(n3, "NodeError"), n3);
  }
  __name(Nt, "Nt");
  a(Nt, "E");
  Nt("ERR_BUFFER_OUT_OF_BOUNDS", function(r3) {
    return r3 ? `${r3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Nt("ERR_INVALID_ARG_TYPE", function(r3, e2) {
    return `The "${r3}" argument must be of type number. Received type ${typeof e2}`;
  }, TypeError);
  Nt("ERR_OUT_OF_RANGE", function(r3, e2, t2) {
    let n3 = `The value of "${r3}" is out of range.`, i3 = t2;
    return Number.isInteger(t2) && Math.abs(t2) > 2 ** 32 ? i3 = Mn(String(t2)) : typeof t2 == "bigint" && (i3 = String(t2), (t2 > BigInt(2) ** BigInt(32) || t2 < -(BigInt(2) ** BigInt(32))) && (i3 = Mn(i3)), i3 += "n"), n3 += ` It must be ${e2}. Received ${i3}`, n3;
  }, RangeError);
  function Mn(r3) {
    let e2 = "", t2 = r3.length, n3 = r3[0] === "-" ? 1 : 0;
    for (; t2 >= n3 + 4; t2 -= 3)
      e2 = `_${r3.slice(t2 - 3, t2)}${e2}`;
    return `${r3.slice(
      0,
      t2
    )}${e2}`;
  }
  __name(Mn, "Mn");
  a(Mn, "addNumericalSeparator");
  function Do(r3, e2, t2) {
    Le(e2, "offset"), (r3[e2] === void 0 || r3[e2 + t2] === void 0) && We(e2, r3.length - (t2 + 1));
  }
  __name(Do, "Do");
  a(Do, "checkBounds");
  function Gn(r3, e2, t2, n3, i3, s3) {
    if (r3 > t2 || r3 < e2) {
      let o4 = typeof e2 == "bigint" ? "n" : "", u3;
      throw s3 > 3 ? e2 === 0 || e2 === BigInt(0) ? u3 = `>= 0${o4} and < 2${o4} ** ${(s3 + 1) * 8}${o4}` : u3 = `>= -(2${o4} ** ${(s3 + 1) * 8 - 1}${o4}) and < 2 ** ${(s3 + 1) * 8 - 1}${o4}` : u3 = `>= ${e2}${o4} and <= ${t2}${o4}`, new Pe.ERR_OUT_OF_RANGE(
        "value",
        u3,
        r3
      );
    }
    Do(n3, i3, s3);
  }
  __name(Gn, "Gn");
  a(Gn, "checkIntBI");
  function Le(r3, e2) {
    if (typeof r3 != "number")
      throw new Pe.ERR_INVALID_ARG_TYPE(e2, "number", r3);
  }
  __name(Le, "Le");
  a(Le, "validateNumber");
  function We(r3, e2, t2) {
    throw Math.floor(r3) !== r3 ? (Le(r3, t2), new Pe.ERR_OUT_OF_RANGE(
      t2 || "offset",
      "an integer",
      r3
    )) : e2 < 0 ? new Pe.ERR_BUFFER_OUT_OF_BOUNDS() : new Pe.ERR_OUT_OF_RANGE(t2 || "offset", `>= ${t2 ? 1 : 0} and <= ${e2}`, r3);
  }
  __name(We, "We");
  a(We, "boundsError");
  var ko = /[^+/0-9A-Za-z-_]/g;
  function Oo(r3) {
    if (r3 = r3.split("=")[0], r3 = r3.trim().replace(ko, ""), r3.length < 2)
      return "";
    for (; r3.length % 4 !== 0; )
      r3 = r3 + "=";
    return r3;
  }
  __name(Oo, "Oo");
  a(Oo, "base64clean");
  function kt(r3, e2) {
    e2 = e2 || 1 / 0;
    let t2, n3 = r3.length, i3 = null, s3 = [];
    for (let o4 = 0; o4 < n3; ++o4) {
      if (t2 = r3.charCodeAt(o4), t2 > 55295 && t2 < 57344) {
        if (!i3) {
          if (t2 > 56319) {
            (e2 -= 3) > -1 && s3.push(239, 191, 189);
            continue;
          } else if (o4 + 1 === n3) {
            (e2 -= 3) > -1 && s3.push(239, 191, 189);
            continue;
          }
          i3 = t2;
          continue;
        }
        if (t2 < 56320) {
          (e2 -= 3) > -1 && s3.push(
            239,
            191,
            189
          ), i3 = t2;
          continue;
        }
        t2 = (i3 - 55296 << 10 | t2 - 56320) + 65536;
      } else
        i3 && (e2 -= 3) > -1 && s3.push(
          239,
          191,
          189
        );
      if (i3 = null, t2 < 128) {
        if ((e2 -= 1) < 0)
          break;
        s3.push(t2);
      } else if (t2 < 2048) {
        if ((e2 -= 2) < 0)
          break;
        s3.push(t2 >> 6 | 192, t2 & 63 | 128);
      } else if (t2 < 65536) {
        if ((e2 -= 3) < 0)
          break;
        s3.push(t2 >> 12 | 224, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else if (t2 < 1114112) {
        if ((e2 -= 4) < 0)
          break;
        s3.push(t2 >> 18 | 240, t2 >> 12 & 63 | 128, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return s3;
  }
  __name(kt, "kt");
  a(
    kt,
    "utf8ToBytes"
  );
  function Uo(r3) {
    let e2 = [];
    for (let t2 = 0; t2 < r3.length; ++t2)
      e2.push(r3.charCodeAt(
        t2
      ) & 255);
    return e2;
  }
  __name(Uo, "Uo");
  a(Uo, "asciiToBytes");
  function No(r3, e2) {
    let t2, n3, i3, s3 = [];
    for (let o4 = 0; o4 < r3.length && !((e2 -= 2) < 0); ++o4)
      t2 = r3.charCodeAt(o4), n3 = t2 >> 8, i3 = t2 % 256, s3.push(i3), s3.push(n3);
    return s3;
  }
  __name(No, "No");
  a(No, "utf16leToBytes");
  function $n(r3) {
    return Ft.toByteArray(Oo(r3));
  }
  __name($n, "$n");
  a($n, "base64ToBytes");
  function ot(r3, e2, t2, n3) {
    let i3;
    for (i3 = 0; i3 < n3 && !(i3 + t2 >= e2.length || i3 >= r3.length); ++i3)
      e2[i3 + t2] = r3[i3];
    return i3;
  }
  __name(ot, "ot");
  a(ot, "blitBuffer");
  function oe(r3, e2) {
    return r3 instanceof e2 || r3 != null && r3.constructor != null && r3.constructor.name != null && r3.constructor.name === e2.name;
  }
  __name(oe, "oe");
  a(oe, "isInstance");
  function qt(r3) {
    return r3 !== r3;
  }
  __name(qt, "qt");
  a(qt, "numberIsNaN");
  var qo = function() {
    let r3 = "0123456789abcdef", e2 = new Array(256);
    for (let t2 = 0; t2 < 16; ++t2) {
      let n3 = t2 * 16;
      for (let i3 = 0; i3 < 16; ++i3)
        e2[n3 + i3] = r3[t2] + r3[i3];
    }
    return e2;
  }();
  function ge(r3) {
    return typeof BigInt > "u" ? Qo : r3;
  }
  __name(ge, "ge");
  a(ge, "defineBigIntMethod");
  function Qo() {
    throw new Error("BigInt not supported");
  }
  __name(Qo, "Qo");
  a(Qo, "BufferBigIntNotDefined");
});
var S;
var E;
var x;
var g;
var y;
var m2;
var p2 = z2(() => {
  "use strict";
  S = globalThis, E = globalThis.setImmediate ?? ((r3) => setTimeout(
    r3,
    0
  )), x = globalThis.clearImmediate ?? ((r3) => clearTimeout(r3)), g = globalThis.crypto ?? {};
  g.subtle ?? (g.subtle = {});
  y = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : Vn().Buffer, m2 = globalThis.process ?? {};
  m2.env ?? (m2.env = {});
  try {
    m2.nextTick(() => {
    });
  } catch {
    let e2 = Promise.resolve();
    m2.nextTick = e2.then.bind(e2);
  }
});
var we = I((th, Qt) => {
  "use strict";
  p2();
  var Fe = typeof Reflect == "object" ? Reflect : null, Kn = Fe && typeof Fe.apply == "function" ? Fe.apply : a(function(e2, t2, n3) {
    return Function.prototype.apply.call(e2, t2, n3);
  }, "ReflectApply"), at;
  Fe && typeof Fe.ownKeys == "function" ? at = Fe.ownKeys : Object.getOwnPropertySymbols ? at = a(function(e2) {
    return Object.getOwnPropertyNames(
      e2
    ).concat(Object.getOwnPropertySymbols(e2));
  }, "ReflectOwnKeys") : at = a(function(e2) {
    return Object.getOwnPropertyNames(e2);
  }, "ReflectOwnKeys");
  function jo(r3) {
    console && console.warn && console.warn(r3);
  }
  __name(jo, "jo");
  a(jo, "ProcessEmitWarning");
  var Yn = Number.isNaN || a(function(e2) {
    return e2 !== e2;
  }, "NumberIsNaN");
  function L2() {
    L2.init.call(this);
  }
  __name(L2, "L");
  a(L2, "EventEmitter");
  Qt.exports = L2;
  Qt.exports.once = $o;
  L2.EventEmitter = L2;
  L2.prototype._events = void 0;
  L2.prototype._eventsCount = 0;
  L2.prototype._maxListeners = void 0;
  var zn = 10;
  function ut(r3) {
    if (typeof r3 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r3);
  }
  __name(ut, "ut");
  a(ut, "checkListener");
  Object.defineProperty(L2, "defaultMaxListeners", { enumerable: true, get: a(function() {
    return zn;
  }, "get"), set: a(function(r3) {
    if (typeof r3 != "number" || r3 < 0 || Yn(r3))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r3 + ".");
    zn = r3;
  }, "set") });
  L2.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  L2.prototype.setMaxListeners = a(
    function(e2) {
      if (typeof e2 != "number" || e2 < 0 || Yn(e2))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
      return this._maxListeners = e2, this;
    },
    "setMaxListeners"
  );
  function Zn(r3) {
    return r3._maxListeners === void 0 ? L2.defaultMaxListeners : r3._maxListeners;
  }
  __name(Zn, "Zn");
  a(Zn, "_getMaxListeners");
  L2.prototype.getMaxListeners = a(function() {
    return Zn(this);
  }, "getMaxListeners");
  L2.prototype.emit = a(function(e2) {
    for (var t2 = [], n3 = 1; n3 < arguments.length; n3++)
      t2.push(arguments[n3]);
    var i3 = e2 === "error", s3 = this._events;
    if (s3 !== void 0)
      i3 = i3 && s3.error === void 0;
    else if (!i3)
      return false;
    if (i3) {
      var o4;
      if (t2.length > 0 && (o4 = t2[0]), o4 instanceof Error)
        throw o4;
      var u3 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
      throw u3.context = o4, u3;
    }
    var c4 = s3[e2];
    if (c4 === void 0)
      return false;
    if (typeof c4 == "function")
      Kn(c4, this, t2);
    else
      for (var h2 = c4.length, l3 = ri(c4, h2), n3 = 0; n3 < h2; ++n3)
        Kn(
          l3[n3],
          this,
          t2
        );
    return true;
  }, "emit");
  function Jn(r3, e2, t2, n3) {
    var i3, s3, o4;
    if (ut(t2), s3 = r3._events, s3 === void 0 ? (s3 = r3._events = /* @__PURE__ */ Object.create(null), r3._eventsCount = 0) : (s3.newListener !== void 0 && (r3.emit(
      "newListener",
      e2,
      t2.listener ? t2.listener : t2
    ), s3 = r3._events), o4 = s3[e2]), o4 === void 0)
      o4 = s3[e2] = t2, ++r3._eventsCount;
    else if (typeof o4 == "function" ? o4 = s3[e2] = n3 ? [t2, o4] : [o4, t2] : n3 ? o4.unshift(
      t2
    ) : o4.push(t2), i3 = Zn(r3), i3 > 0 && o4.length > i3 && !o4.warned) {
      o4.warned = true;
      var u3 = new Error("Possible EventEmitter memory leak detected. " + o4.length + " " + String(e2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u3.name = "MaxListenersExceededWarning", u3.emitter = r3, u3.type = e2, u3.count = o4.length, jo(u3);
    }
    return r3;
  }
  __name(Jn, "Jn");
  a(Jn, "_addListener");
  L2.prototype.addListener = a(function(e2, t2) {
    return Jn(this, e2, t2, false);
  }, "addListener");
  L2.prototype.on = L2.prototype.addListener;
  L2.prototype.prependListener = a(function(e2, t2) {
    return Jn(this, e2, t2, true);
  }, "prependListener");
  function Wo() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  __name(Wo, "Wo");
  a(
    Wo,
    "onceWrapper"
  );
  function Xn(r3, e2, t2) {
    var n3 = {
      fired: false,
      wrapFn: void 0,
      target: r3,
      type: e2,
      listener: t2
    }, i3 = Wo.bind(n3);
    return i3.listener = t2, n3.wrapFn = i3, i3;
  }
  __name(Xn, "Xn");
  a(Xn, "_onceWrap");
  L2.prototype.once = a(function(e2, t2) {
    return ut(t2), this.on(e2, Xn(this, e2, t2)), this;
  }, "once");
  L2.prototype.prependOnceListener = a(function(e2, t2) {
    return ut(t2), this.prependListener(e2, Xn(
      this,
      e2,
      t2
    )), this;
  }, "prependOnceListener");
  L2.prototype.removeListener = a(
    function(e2, t2) {
      var n3, i3, s3, o4, u3;
      if (ut(t2), i3 = this._events, i3 === void 0)
        return this;
      if (n3 = i3[e2], n3 === void 0)
        return this;
      if (n3 === t2 || n3.listener === t2)
        --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[e2], i3.removeListener && this.emit("removeListener", e2, n3.listener || t2));
      else if (typeof n3 != "function") {
        for (s3 = -1, o4 = n3.length - 1; o4 >= 0; o4--)
          if (n3[o4] === t2 || n3[o4].listener === t2) {
            u3 = n3[o4].listener, s3 = o4;
            break;
          }
        if (s3 < 0)
          return this;
        s3 === 0 ? n3.shift() : Ho(n3, s3), n3.length === 1 && (i3[e2] = n3[0]), i3.removeListener !== void 0 && this.emit("removeListener", e2, u3 || t2);
      }
      return this;
    },
    "removeListener"
  );
  L2.prototype.off = L2.prototype.removeListener;
  L2.prototype.removeAllListeners = a(function(e2) {
    var t2, n3, i3;
    if (n3 = this._events, n3 === void 0)
      return this;
    if (n3.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n3[e2] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e2]), this;
    if (arguments.length === 0) {
      var s3 = Object.keys(n3), o4;
      for (i3 = 0; i3 < s3.length; ++i3)
        o4 = s3[i3], o4 !== "removeListener" && this.removeAllListeners(o4);
      return this.removeAllListeners(
        "removeListener"
      ), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t2 = n3[e2], typeof t2 == "function")
      this.removeListener(e2, t2);
    else if (t2 !== void 0)
      for (i3 = t2.length - 1; i3 >= 0; i3--)
        this.removeListener(e2, t2[i3]);
    return this;
  }, "removeAllListeners");
  function ei(r3, e2, t2) {
    var n3 = r3._events;
    if (n3 === void 0)
      return [];
    var i3 = n3[e2];
    return i3 === void 0 ? [] : typeof i3 == "function" ? t2 ? [i3.listener || i3] : [i3] : t2 ? Go(i3) : ri(i3, i3.length);
  }
  __name(ei, "ei");
  a(ei, "_listeners");
  L2.prototype.listeners = a(function(e2) {
    return ei(this, e2, true);
  }, "listeners");
  L2.prototype.rawListeners = a(function(e2) {
    return ei(this, e2, false);
  }, "rawListeners");
  L2.listenerCount = function(r3, e2) {
    return typeof r3.listenerCount == "function" ? r3.listenerCount(e2) : ti.call(r3, e2);
  };
  L2.prototype.listenerCount = ti;
  function ti(r3) {
    var e2 = this._events;
    if (e2 !== void 0) {
      var t2 = e2[r3];
      if (typeof t2 == "function")
        return 1;
      if (t2 !== void 0)
        return t2.length;
    }
    return 0;
  }
  __name(ti, "ti");
  a(ti, "listenerCount");
  L2.prototype.eventNames = a(function() {
    return this._eventsCount > 0 ? at(this._events) : [];
  }, "eventNames");
  function ri(r3, e2) {
    for (var t2 = new Array(e2), n3 = 0; n3 < e2; ++n3)
      t2[n3] = r3[n3];
    return t2;
  }
  __name(ri, "ri");
  a(ri, "arrayClone");
  function Ho(r3, e2) {
    for (; e2 + 1 < r3.length; e2++)
      r3[e2] = r3[e2 + 1];
    r3.pop();
  }
  __name(Ho, "Ho");
  a(Ho, "spliceOne");
  function Go(r3) {
    for (var e2 = new Array(r3.length), t2 = 0; t2 < e2.length; ++t2)
      e2[t2] = r3[t2].listener || r3[t2];
    return e2;
  }
  __name(Go, "Go");
  a(Go, "unwrapListeners");
  function $o(r3, e2) {
    return new Promise(
      function(t2, n3) {
        function i3(o4) {
          r3.removeListener(e2, s3), n3(o4);
        }
        __name(i3, "i");
        a(i3, "errorListener");
        function s3() {
          typeof r3.removeListener == "function" && r3.removeListener("error", i3), t2([].slice.call(
            arguments
          ));
        }
        __name(s3, "s");
        a(s3, "resolver"), ni(r3, e2, s3, { once: true }), e2 !== "error" && Vo(r3, i3, { once: true });
      }
    );
  }
  __name($o, "$o");
  a($o, "once");
  function Vo(r3, e2, t2) {
    typeof r3.on == "function" && ni(r3, "error", e2, t2);
  }
  __name(Vo, "Vo");
  a(
    Vo,
    "addErrorHandlerIfEventEmitter"
  );
  function ni(r3, e2, t2, n3) {
    if (typeof r3.on == "function")
      n3.once ? r3.once(e2, t2) : r3.on(e2, t2);
    else if (typeof r3.addEventListener == "function")
      r3.addEventListener(
        e2,
        a(/* @__PURE__ */ __name(function i3(s3) {
          n3.once && r3.removeEventListener(e2, i3), t2(s3);
        }, "i"), "wrapListener")
      );
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r3);
  }
  __name(ni, "ni");
  a(ni, "eventTargetAgnosticAddListener");
});
var He = {};
ie(He, { default: () => Ko });
var Ko;
var Ge = z2(() => {
  "use strict";
  p2();
  Ko = {};
});
function $e(r3) {
  let e2 = 1779033703, t2 = 3144134277, n3 = 1013904242, i3 = 2773480762, s3 = 1359893119, o4 = 2600822924, u3 = 528734635, c4 = 1541459225, h2 = 0, l3 = 0, d3 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], b3 = a(
    (A2, w3) => A2 >>> w3 | A2 << 32 - w3,
    "rrot"
  ), C3 = new Uint32Array(64), B = new Uint8Array(64), j3 = a(() => {
    for (let R = 0, G = 0; R < 16; R++, G += 4)
      C3[R] = B[G] << 24 | B[G + 1] << 16 | B[G + 2] << 8 | B[G + 3];
    for (let R = 16; R < 64; R++) {
      let G = b3(C3[R - 15], 7) ^ b3(C3[R - 15], 18) ^ C3[R - 15] >>> 3, ue = b3(C3[R - 2], 17) ^ b3(C3[R - 2], 19) ^ C3[R - 2] >>> 10;
      C3[R] = C3[R - 16] + G + C3[R - 7] + ue | 0;
    }
    let A2 = e2, w3 = t2, P = n3, V = i3, O3 = s3, W = o4, ae = u3, ee = c4;
    for (let R = 0; R < 64; R++) {
      let G = b3(
        O3,
        6
      ) ^ b3(O3, 11) ^ b3(O3, 25), ue = O3 & W ^ ~O3 & ae, de = ee + G + ue + d3[R] + C3[R] | 0, Ee = b3(A2, 2) ^ b3(A2, 13) ^ b3(A2, 22), ce = A2 & w3 ^ A2 & P ^ w3 & P, Ce = Ee + ce | 0;
      ee = ae, ae = W, W = O3, O3 = V + de | 0, V = P, P = w3, w3 = A2, A2 = de + Ce | 0;
    }
    e2 = e2 + A2 | 0, t2 = t2 + w3 | 0, n3 = n3 + P | 0, i3 = i3 + V | 0, s3 = s3 + O3 | 0, o4 = o4 + W | 0, u3 = u3 + ae | 0, c4 = c4 + ee | 0, l3 = 0;
  }, "process"), X = a((A2) => {
    typeof A2 == "string" && (A2 = new TextEncoder().encode(A2));
    for (let w3 = 0; w3 < A2.length; w3++)
      B[l3++] = A2[w3], l3 === 64 && j3();
    h2 += A2.length;
  }, "add"), pe = a(() => {
    if (B[l3++] = 128, l3 == 64 && j3(), l3 + 8 > 64) {
      for (; l3 < 64; )
        B[l3++] = 0;
      j3();
    }
    for (; l3 < 58; )
      B[l3++] = 0;
    let A2 = h2 * 8;
    B[l3++] = A2 / 1099511627776 & 255, B[l3++] = A2 / 4294967296 & 255, B[l3++] = A2 >>> 24, B[l3++] = A2 >>> 16 & 255, B[l3++] = A2 >>> 8 & 255, B[l3++] = A2 & 255, j3();
    let w3 = new Uint8Array(32);
    return w3[0] = e2 >>> 24, w3[1] = e2 >>> 16 & 255, w3[2] = e2 >>> 8 & 255, w3[3] = e2 & 255, w3[4] = t2 >>> 24, w3[5] = t2 >>> 16 & 255, w3[6] = t2 >>> 8 & 255, w3[7] = t2 & 255, w3[8] = n3 >>> 24, w3[9] = n3 >>> 16 & 255, w3[10] = n3 >>> 8 & 255, w3[11] = n3 & 255, w3[12] = i3 >>> 24, w3[13] = i3 >>> 16 & 255, w3[14] = i3 >>> 8 & 255, w3[15] = i3 & 255, w3[16] = s3 >>> 24, w3[17] = s3 >>> 16 & 255, w3[18] = s3 >>> 8 & 255, w3[19] = s3 & 255, w3[20] = o4 >>> 24, w3[21] = o4 >>> 16 & 255, w3[22] = o4 >>> 8 & 255, w3[23] = o4 & 255, w3[24] = u3 >>> 24, w3[25] = u3 >>> 16 & 255, w3[26] = u3 >>> 8 & 255, w3[27] = u3 & 255, w3[28] = c4 >>> 24, w3[29] = c4 >>> 16 & 255, w3[30] = c4 >>> 8 & 255, w3[31] = c4 & 255, w3;
  }, "digest");
  return r3 === void 0 ? { add: X, digest: pe } : (X(r3), pe());
}
__name($e, "$e");
var ii = z2(
  () => {
    "use strict";
    p2();
    a($e, "sha256");
  }
);
var U;
var Ve;
var si = z2(() => {
  "use strict";
  p2();
  U = /* @__PURE__ */ __name(class U2 {
    constructor() {
      _(
        this,
        "_dataLength",
        0
      );
      _(this, "_bufferLength", 0);
      _(this, "_state", new Int32Array(4));
      _(
        this,
        "_buffer",
        new ArrayBuffer(68)
      );
      _(this, "_buffer8");
      _(this, "_buffer32");
      this._buffer8 = new Uint8Array(
        this._buffer,
        0,
        68
      ), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashByteArray(e2, t2 = false) {
      return this.onePassHasher.start().appendByteArray(e2).end(t2);
    }
    static hashStr(e2, t2 = false) {
      return this.onePassHasher.start().appendStr(e2).end(t2);
    }
    static hashAsciiStr(e2, t2 = false) {
      return this.onePassHasher.start().appendAsciiStr(e2).end(t2);
    }
    static _hex(e2) {
      let t2 = U2.hexChars, n3 = U2.hexOut, i3, s3, o4, u3;
      for (u3 = 0; u3 < 4; u3 += 1)
        for (s3 = u3 * 8, i3 = e2[u3], o4 = 0; o4 < 8; o4 += 2)
          n3[s3 + 1 + o4] = t2.charAt(i3 & 15), i3 >>>= 4, n3[s3 + 0 + o4] = t2.charAt(i3 & 15), i3 >>>= 4;
      return n3.join("");
    }
    static _md5cycle(e2, t2) {
      let n3 = e2[0], i3 = e2[1], s3 = e2[2], o4 = e2[3];
      n3 += (i3 & s3 | ~i3 & o4) + t2[0] - 680876936 | 0, n3 = (n3 << 7 | n3 >>> 25) + i3 | 0, o4 += (n3 & i3 | ~n3 & s3) + t2[1] - 389564586 | 0, o4 = (o4 << 12 | o4 >>> 20) + n3 | 0, s3 += (o4 & n3 | ~o4 & i3) + t2[2] + 606105819 | 0, s3 = (s3 << 17 | s3 >>> 15) + o4 | 0, i3 += (s3 & o4 | ~s3 & n3) + t2[3] - 1044525330 | 0, i3 = (i3 << 22 | i3 >>> 10) + s3 | 0, n3 += (i3 & s3 | ~i3 & o4) + t2[4] - 176418897 | 0, n3 = (n3 << 7 | n3 >>> 25) + i3 | 0, o4 += (n3 & i3 | ~n3 & s3) + t2[5] + 1200080426 | 0, o4 = (o4 << 12 | o4 >>> 20) + n3 | 0, s3 += (o4 & n3 | ~o4 & i3) + t2[6] - 1473231341 | 0, s3 = (s3 << 17 | s3 >>> 15) + o4 | 0, i3 += (s3 & o4 | ~s3 & n3) + t2[7] - 45705983 | 0, i3 = (i3 << 22 | i3 >>> 10) + s3 | 0, n3 += (i3 & s3 | ~i3 & o4) + t2[8] + 1770035416 | 0, n3 = (n3 << 7 | n3 >>> 25) + i3 | 0, o4 += (n3 & i3 | ~n3 & s3) + t2[9] - 1958414417 | 0, o4 = (o4 << 12 | o4 >>> 20) + n3 | 0, s3 += (o4 & n3 | ~o4 & i3) + t2[10] - 42063 | 0, s3 = (s3 << 17 | s3 >>> 15) + o4 | 0, i3 += (s3 & o4 | ~s3 & n3) + t2[11] - 1990404162 | 0, i3 = (i3 << 22 | i3 >>> 10) + s3 | 0, n3 += (i3 & s3 | ~i3 & o4) + t2[12] + 1804603682 | 0, n3 = (n3 << 7 | n3 >>> 25) + i3 | 0, o4 += (n3 & i3 | ~n3 & s3) + t2[13] - 40341101 | 0, o4 = (o4 << 12 | o4 >>> 20) + n3 | 0, s3 += (o4 & n3 | ~o4 & i3) + t2[14] - 1502002290 | 0, s3 = (s3 << 17 | s3 >>> 15) + o4 | 0, i3 += (s3 & o4 | ~s3 & n3) + t2[15] + 1236535329 | 0, i3 = (i3 << 22 | i3 >>> 10) + s3 | 0, n3 += (i3 & o4 | s3 & ~o4) + t2[1] - 165796510 | 0, n3 = (n3 << 5 | n3 >>> 27) + i3 | 0, o4 += (n3 & s3 | i3 & ~s3) + t2[6] - 1069501632 | 0, o4 = (o4 << 9 | o4 >>> 23) + n3 | 0, s3 += (o4 & i3 | n3 & ~i3) + t2[11] + 643717713 | 0, s3 = (s3 << 14 | s3 >>> 18) + o4 | 0, i3 += (s3 & n3 | o4 & ~n3) + t2[0] - 373897302 | 0, i3 = (i3 << 20 | i3 >>> 12) + s3 | 0, n3 += (i3 & o4 | s3 & ~o4) + t2[5] - 701558691 | 0, n3 = (n3 << 5 | n3 >>> 27) + i3 | 0, o4 += (n3 & s3 | i3 & ~s3) + t2[10] + 38016083 | 0, o4 = (o4 << 9 | o4 >>> 23) + n3 | 0, s3 += (o4 & i3 | n3 & ~i3) + t2[15] - 660478335 | 0, s3 = (s3 << 14 | s3 >>> 18) + o4 | 0, i3 += (s3 & n3 | o4 & ~n3) + t2[4] - 405537848 | 0, i3 = (i3 << 20 | i3 >>> 12) + s3 | 0, n3 += (i3 & o4 | s3 & ~o4) + t2[9] + 568446438 | 0, n3 = (n3 << 5 | n3 >>> 27) + i3 | 0, o4 += (n3 & s3 | i3 & ~s3) + t2[14] - 1019803690 | 0, o4 = (o4 << 9 | o4 >>> 23) + n3 | 0, s3 += (o4 & i3 | n3 & ~i3) + t2[3] - 187363961 | 0, s3 = (s3 << 14 | s3 >>> 18) + o4 | 0, i3 += (s3 & n3 | o4 & ~n3) + t2[8] + 1163531501 | 0, i3 = (i3 << 20 | i3 >>> 12) + s3 | 0, n3 += (i3 & o4 | s3 & ~o4) + t2[13] - 1444681467 | 0, n3 = (n3 << 5 | n3 >>> 27) + i3 | 0, o4 += (n3 & s3 | i3 & ~s3) + t2[2] - 51403784 | 0, o4 = (o4 << 9 | o4 >>> 23) + n3 | 0, s3 += (o4 & i3 | n3 & ~i3) + t2[7] + 1735328473 | 0, s3 = (s3 << 14 | s3 >>> 18) + o4 | 0, i3 += (s3 & n3 | o4 & ~n3) + t2[12] - 1926607734 | 0, i3 = (i3 << 20 | i3 >>> 12) + s3 | 0, n3 += (i3 ^ s3 ^ o4) + t2[5] - 378558 | 0, n3 = (n3 << 4 | n3 >>> 28) + i3 | 0, o4 += (n3 ^ i3 ^ s3) + t2[8] - 2022574463 | 0, o4 = (o4 << 11 | o4 >>> 21) + n3 | 0, s3 += (o4 ^ n3 ^ i3) + t2[11] + 1839030562 | 0, s3 = (s3 << 16 | s3 >>> 16) + o4 | 0, i3 += (s3 ^ o4 ^ n3) + t2[14] - 35309556 | 0, i3 = (i3 << 23 | i3 >>> 9) + s3 | 0, n3 += (i3 ^ s3 ^ o4) + t2[1] - 1530992060 | 0, n3 = (n3 << 4 | n3 >>> 28) + i3 | 0, o4 += (n3 ^ i3 ^ s3) + t2[4] + 1272893353 | 0, o4 = (o4 << 11 | o4 >>> 21) + n3 | 0, s3 += (o4 ^ n3 ^ i3) + t2[7] - 155497632 | 0, s3 = (s3 << 16 | s3 >>> 16) + o4 | 0, i3 += (s3 ^ o4 ^ n3) + t2[10] - 1094730640 | 0, i3 = (i3 << 23 | i3 >>> 9) + s3 | 0, n3 += (i3 ^ s3 ^ o4) + t2[13] + 681279174 | 0, n3 = (n3 << 4 | n3 >>> 28) + i3 | 0, o4 += (n3 ^ i3 ^ s3) + t2[0] - 358537222 | 0, o4 = (o4 << 11 | o4 >>> 21) + n3 | 0, s3 += (o4 ^ n3 ^ i3) + t2[3] - 722521979 | 0, s3 = (s3 << 16 | s3 >>> 16) + o4 | 0, i3 += (s3 ^ o4 ^ n3) + t2[6] + 76029189 | 0, i3 = (i3 << 23 | i3 >>> 9) + s3 | 0, n3 += (i3 ^ s3 ^ o4) + t2[9] - 640364487 | 0, n3 = (n3 << 4 | n3 >>> 28) + i3 | 0, o4 += (n3 ^ i3 ^ s3) + t2[12] - 421815835 | 0, o4 = (o4 << 11 | o4 >>> 21) + n3 | 0, s3 += (o4 ^ n3 ^ i3) + t2[15] + 530742520 | 0, s3 = (s3 << 16 | s3 >>> 16) + o4 | 0, i3 += (s3 ^ o4 ^ n3) + t2[2] - 995338651 | 0, i3 = (i3 << 23 | i3 >>> 9) + s3 | 0, n3 += (s3 ^ (i3 | ~o4)) + t2[0] - 198630844 | 0, n3 = (n3 << 6 | n3 >>> 26) + i3 | 0, o4 += (i3 ^ (n3 | ~s3)) + t2[7] + 1126891415 | 0, o4 = (o4 << 10 | o4 >>> 22) + n3 | 0, s3 += (n3 ^ (o4 | ~i3)) + t2[14] - 1416354905 | 0, s3 = (s3 << 15 | s3 >>> 17) + o4 | 0, i3 += (o4 ^ (s3 | ~n3)) + t2[5] - 57434055 | 0, i3 = (i3 << 21 | i3 >>> 11) + s3 | 0, n3 += (s3 ^ (i3 | ~o4)) + t2[12] + 1700485571 | 0, n3 = (n3 << 6 | n3 >>> 26) + i3 | 0, o4 += (i3 ^ (n3 | ~s3)) + t2[3] - 1894986606 | 0, o4 = (o4 << 10 | o4 >>> 22) + n3 | 0, s3 += (n3 ^ (o4 | ~i3)) + t2[10] - 1051523 | 0, s3 = (s3 << 15 | s3 >>> 17) + o4 | 0, i3 += (o4 ^ (s3 | ~n3)) + t2[1] - 2054922799 | 0, i3 = (i3 << 21 | i3 >>> 11) + s3 | 0, n3 += (s3 ^ (i3 | ~o4)) + t2[8] + 1873313359 | 0, n3 = (n3 << 6 | n3 >>> 26) + i3 | 0, o4 += (i3 ^ (n3 | ~s3)) + t2[15] - 30611744 | 0, o4 = (o4 << 10 | o4 >>> 22) + n3 | 0, s3 += (n3 ^ (o4 | ~i3)) + t2[6] - 1560198380 | 0, s3 = (s3 << 15 | s3 >>> 17) + o4 | 0, i3 += (o4 ^ (s3 | ~n3)) + t2[13] + 1309151649 | 0, i3 = (i3 << 21 | i3 >>> 11) + s3 | 0, n3 += (s3 ^ (i3 | ~o4)) + t2[4] - 145523070 | 0, n3 = (n3 << 6 | n3 >>> 26) + i3 | 0, o4 += (i3 ^ (n3 | ~s3)) + t2[11] - 1120210379 | 0, o4 = (o4 << 10 | o4 >>> 22) + n3 | 0, s3 += (n3 ^ (o4 | ~i3)) + t2[2] + 718787259 | 0, s3 = (s3 << 15 | s3 >>> 17) + o4 | 0, i3 += (o4 ^ (s3 | ~n3)) + t2[9] - 343485551 | 0, i3 = (i3 << 21 | i3 >>> 11) + s3 | 0, e2[0] = n3 + e2[0] | 0, e2[1] = i3 + e2[1] | 0, e2[2] = s3 + e2[2] | 0, e2[3] = o4 + e2[3] | 0;
    }
    start() {
      return this._dataLength = 0, this._bufferLength = 0, this._state.set(U2.stateIdentity), this;
    }
    appendStr(e2) {
      let t2 = this._buffer8, n3 = this._buffer32, i3 = this._bufferLength, s3, o4;
      for (o4 = 0; o4 < e2.length; o4 += 1) {
        if (s3 = e2.charCodeAt(o4), s3 < 128)
          t2[i3++] = s3;
        else if (s3 < 2048)
          t2[i3++] = (s3 >>> 6) + 192, t2[i3++] = s3 & 63 | 128;
        else if (s3 < 55296 || s3 > 56319)
          t2[i3++] = (s3 >>> 12) + 224, t2[i3++] = s3 >>> 6 & 63 | 128, t2[i3++] = s3 & 63 | 128;
        else {
          if (s3 = (s3 - 55296) * 1024 + (e2.charCodeAt(++o4) - 56320) + 65536, s3 > 1114111)
            throw new Error("Unicode standard supports code points up to U+10FFFF");
          t2[i3++] = (s3 >>> 18) + 240, t2[i3++] = s3 >>> 12 & 63 | 128, t2[i3++] = s3 >>> 6 & 63 | 128, t2[i3++] = s3 & 63 | 128;
        }
        i3 >= 64 && (this._dataLength += 64, U2._md5cycle(this._state, n3), i3 -= 64, n3[0] = n3[16]);
      }
      return this._bufferLength = i3, this;
    }
    appendAsciiStr(e2) {
      let t2 = this._buffer8, n3 = this._buffer32, i3 = this._bufferLength, s3, o4 = 0;
      for (; ; ) {
        for (s3 = Math.min(e2.length - o4, 64 - i3); s3--; )
          t2[i3++] = e2.charCodeAt(o4++);
        if (i3 < 64)
          break;
        this._dataLength += 64, U2._md5cycle(
          this._state,
          n3
        ), i3 = 0;
      }
      return this._bufferLength = i3, this;
    }
    appendByteArray(e2) {
      let t2 = this._buffer8, n3 = this._buffer32, i3 = this._bufferLength, s3, o4 = 0;
      for (; ; ) {
        for (s3 = Math.min(e2.length - o4, 64 - i3); s3--; )
          t2[i3++] = e2[o4++];
        if (i3 < 64)
          break;
        this._dataLength += 64, U2._md5cycle(
          this._state,
          n3
        ), i3 = 0;
      }
      return this._bufferLength = i3, this;
    }
    getState() {
      let e2 = this._state;
      return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e2[0], e2[1], e2[2], e2[3]] };
    }
    setState(e2) {
      let t2 = e2.buffer, n3 = e2.state, i3 = this._state, s3;
      for (this._dataLength = e2.length, this._bufferLength = e2.buflen, i3[0] = n3[0], i3[1] = n3[1], i3[2] = n3[2], i3[3] = n3[3], s3 = 0; s3 < t2.length; s3 += 1)
        this._buffer8[s3] = t2.charCodeAt(s3);
    }
    end(e2 = false) {
      let t2 = this._bufferLength, n3 = this._buffer8, i3 = this._buffer32, s3 = (t2 >> 2) + 1;
      this._dataLength += t2;
      let o4 = this._dataLength * 8;
      if (n3[t2] = 128, n3[t2 + 1] = n3[t2 + 2] = n3[t2 + 3] = 0, i3.set(U2.buffer32Identity.subarray(s3), s3), t2 > 55 && (U2._md5cycle(this._state, i3), i3.set(U2.buffer32Identity)), o4 <= 4294967295)
        i3[14] = o4;
      else {
        let u3 = o4.toString(16).match(/(.*?)(.{0,8})$/);
        if (u3 === null)
          return;
        let c4 = parseInt(
          u3[2],
          16
        ), h2 = parseInt(u3[1], 16) || 0;
        i3[14] = c4, i3[15] = h2;
      }
      return U2._md5cycle(this._state, i3), e2 ? this._state : U2._hex(this._state);
    }
  }, "U");
  a(U, "Md5"), _(U, "stateIdentity", new Int32Array(
    [1732584193, -271733879, -1732584194, 271733878]
  )), _(U, "buffer32Identity", new Int32Array(
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  )), _(U, "hexChars", "0123456789abcdef"), _(U, "hexOut", []), _(U, "onePassHasher", new U());
  Ve = U;
});
var jt = {};
ie(jt, { createHash: () => Yo, createHmac: () => Zo, randomBytes: () => zo });
function zo(r3) {
  return g.getRandomValues(y.alloc(r3));
}
__name(zo, "zo");
function Yo(r3) {
  if (r3 === "sha256")
    return { update: a(
      function(e2) {
        return { digest: a(function() {
          return y.from($e(e2));
        }, "digest") };
      },
      "update"
    ) };
  if (r3 === "md5")
    return { update: a(function(e2) {
      return { digest: a(function() {
        return typeof e2 == "string" ? Ve.hashStr(e2) : Ve.hashByteArray(e2);
      }, "digest") };
    }, "update") };
  throw new Error(
    `Hash type '${r3}' not supported`
  );
}
__name(Yo, "Yo");
function Zo(r3, e2) {
  if (r3 !== "sha256")
    throw new Error(
      `Only sha256 is supported (requested: '${r3}')`
    );
  return { update: a(function(t2) {
    return {
      digest: a(function() {
        typeof e2 == "string" && (e2 = new TextEncoder().encode(e2)), typeof t2 == "string" && (t2 = new TextEncoder().encode(t2));
        let n3 = e2.length;
        if (n3 > 64)
          e2 = $e(e2);
        else if (n3 < 64) {
          let c4 = new Uint8Array(64);
          c4.set(e2), e2 = c4;
        }
        let i3 = new Uint8Array(64), s3 = new Uint8Array(
          64
        );
        for (let c4 = 0; c4 < 64; c4++)
          i3[c4] = 54 ^ e2[c4], s3[c4] = 92 ^ e2[c4];
        let o4 = new Uint8Array(t2.length + 64);
        o4.set(i3, 0), o4.set(t2, 64);
        let u3 = new Uint8Array(96);
        return u3.set(s3, 0), u3.set(
          $e(o4),
          64
        ), y.from($e(u3));
      }, "digest")
    };
  }, "update") };
}
__name(Zo, "Zo");
var Wt = z2(() => {
  "use strict";
  p2();
  ii();
  si();
  a(zo, "randomBytes");
  a(Yo, "createHash");
  a(Zo, "createHmac");
});
var Gt = I((oi) => {
  "use strict";
  p2();
  oi.parse = function(r3, e2) {
    return new Ht(r3, e2).parse();
  };
  var ct = /* @__PURE__ */ __name(class ct2 {
    constructor(e2, t2) {
      this.source = e2, this.transform = t2 || Jo, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var e2 = this.source[this.position++];
      return e2 === "\\" ? { value: this.source[this.position++], escaped: true } : { value: e2, escaped: false };
    }
    record(e2) {
      this.recorded.push(e2);
    }
    newEntry(e2) {
      var t2;
      (this.recorded.length > 0 || e2) && (t2 = this.recorded.join(""), t2 === "NULL" && !e2 && (t2 = null), t2 !== null && (t2 = this.transform(t2)), this.entries.push(
        t2
      ), this.recorded = []);
    }
    consumeDimensions() {
      if (this.source[0] === "[")
        for (; !this.isEof(); ) {
          var e2 = this.nextCharacter();
          if (e2.value === "=")
            break;
        }
    }
    parse(e2) {
      var t2, n3, i3;
      for (this.consumeDimensions(); !this.isEof(); )
        if (t2 = this.nextCharacter(), t2.value === "{" && !i3)
          this.dimension++, this.dimension > 1 && (n3 = new ct2(this.source.substr(this.position - 1), this.transform), this.entries.push(
            n3.parse(true)
          ), this.position += n3.position - 2);
        else if (t2.value === "}" && !i3) {
          if (this.dimension--, !this.dimension && (this.newEntry(), e2))
            return this.entries;
        } else
          t2.value === '"' && !t2.escaped ? (i3 && this.newEntry(true), i3 = !i3) : t2.value === "," && !i3 ? this.newEntry() : this.record(
            t2.value
          );
      if (this.dimension !== 0)
        throw new Error("array dimension not balanced");
      return this.entries;
    }
  }, "ct");
  a(ct, "ArrayParser");
  var Ht = ct;
  function Jo(r3) {
    return r3;
  }
  __name(Jo, "Jo");
  a(Jo, "identity");
});
var $t = I((wh, ai) => {
  p2();
  var Xo = Gt();
  ai.exports = { create: a(function(r3, e2) {
    return { parse: a(
      function() {
        return Xo.parse(r3, e2);
      },
      "parse"
    ) };
  }, "create") };
});
var hi = I((Eh, ci) => {
  "use strict";
  p2();
  var ea = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, ta = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, ra = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, na = /^-?infinity$/;
  ci.exports = a(function(e2) {
    if (na.test(e2))
      return Number(e2.replace("i", "I"));
    var t2 = ea.exec(e2);
    if (!t2)
      return ia(e2) || null;
    var n3 = !!t2[8], i3 = parseInt(t2[1], 10);
    n3 && (i3 = ui(i3));
    var s3 = parseInt(
      t2[2],
      10
    ) - 1, o4 = t2[3], u3 = parseInt(t2[4], 10), c4 = parseInt(t2[5], 10), h2 = parseInt(t2[6], 10), l3 = t2[7];
    l3 = l3 ? 1e3 * parseFloat(l3) : 0;
    var d3, b3 = sa(e2);
    return b3 != null ? (d3 = new Date(Date.UTC(
      i3,
      s3,
      o4,
      u3,
      c4,
      h2,
      l3
    )), Vt(i3) && d3.setUTCFullYear(i3), b3 !== 0 && d3.setTime(d3.getTime() - b3)) : (d3 = new Date(
      i3,
      s3,
      o4,
      u3,
      c4,
      h2,
      l3
    ), Vt(i3) && d3.setFullYear(i3)), d3;
  }, "parseDate");
  function ia(r3) {
    var e2 = ta.exec(r3);
    if (e2) {
      var t2 = parseInt(e2[1], 10), n3 = !!e2[4];
      n3 && (t2 = ui(t2));
      var i3 = parseInt(
        e2[2],
        10
      ) - 1, s3 = e2[3], o4 = new Date(t2, i3, s3);
      return Vt(t2) && o4.setFullYear(t2), o4;
    }
  }
  __name(ia, "ia");
  a(ia, "getDate");
  function sa(r3) {
    if (r3.endsWith("+00"))
      return 0;
    var e2 = ra.exec(r3.split(" ")[1]);
    if (e2) {
      var t2 = e2[1];
      if (t2 === "Z")
        return 0;
      var n3 = t2 === "-" ? -1 : 1, i3 = parseInt(e2[2], 10) * 3600 + parseInt(
        e2[3] || 0,
        10
      ) * 60 + parseInt(e2[4] || 0, 10);
      return i3 * n3 * 1e3;
    }
  }
  __name(sa, "sa");
  a(sa, "timeZoneOffset");
  function ui(r3) {
    return -(r3 - 1);
  }
  __name(ui, "ui");
  a(ui, "bcYearToNegativeYear");
  function Vt(r3) {
    return r3 >= 0 && r3 < 100;
  }
  __name(Vt, "Vt");
  a(
    Vt,
    "is0To99"
  );
});
var fi = I((_h, li) => {
  p2();
  li.exports = aa;
  var oa = Object.prototype.hasOwnProperty;
  function aa(r3) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var n3 in t2)
        oa.call(
          t2,
          n3
        ) && (r3[n3] = t2[n3]);
    }
    return r3;
  }
  __name(aa, "aa");
  a(aa, "extend");
});
var yi = I((Th, di) => {
  "use strict";
  p2();
  var ua = fi();
  di.exports = Me;
  function Me(r3) {
    if (!(this instanceof Me))
      return new Me(r3);
    ua(this, Sa(r3));
  }
  __name(Me, "Me");
  a(Me, "PostgresInterval");
  var ca = ["seconds", "minutes", "hours", "days", "months", "years"];
  Me.prototype.toPostgres = function() {
    var r3 = ca.filter(this.hasOwnProperty, this);
    return this.milliseconds && r3.indexOf("seconds") < 0 && r3.push("seconds"), r3.length === 0 ? "0" : r3.map(function(e2) {
      var t2 = this[e2] || 0;
      return e2 === "seconds" && this.milliseconds && (t2 = (t2 + this.milliseconds / 1e3).toFixed(6).replace(
        /\.?0+$/,
        ""
      )), t2 + " " + e2;
    }, this).join(" ");
  };
  var ha = { years: "Y", months: "M", days: "D", hours: "H", minutes: "M", seconds: "S" }, la = ["years", "months", "days"], fa = ["hours", "minutes", "seconds"];
  Me.prototype.toISOString = Me.prototype.toISO = function() {
    var r3 = la.map(t2, this).join(""), e2 = fa.map(t2, this).join("");
    return "P" + r3 + "T" + e2;
    function t2(n3) {
      var i3 = this[n3] || 0;
      return n3 === "seconds" && this.milliseconds && (i3 = (i3 + this.milliseconds / 1e3).toFixed(6).replace(
        /0+$/,
        ""
      )), i3 + ha[n3];
    }
    __name(t2, "t");
  };
  var Kt = "([+-]?\\d+)", pa = Kt + "\\s+years?", da = Kt + "\\s+mons?", ya = Kt + "\\s+days?", ma = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", ga = new RegExp([
    pa,
    da,
    ya,
    ma
  ].map(function(r3) {
    return "(" + r3 + ")?";
  }).join("\\s*")), pi = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  }, wa = ["hours", "minutes", "seconds", "milliseconds"];
  function ba(r3) {
    var e2 = r3 + "000000".slice(r3.length);
    return parseInt(
      e2,
      10
    ) / 1e3;
  }
  __name(ba, "ba");
  a(ba, "parseMilliseconds");
  function Sa(r3) {
    if (!r3)
      return {};
    var e2 = ga.exec(
      r3
    ), t2 = e2[8] === "-";
    return Object.keys(pi).reduce(function(n3, i3) {
      var s3 = pi[i3], o4 = e2[s3];
      return !o4 || (o4 = i3 === "milliseconds" ? ba(o4) : parseInt(o4, 10), !o4) || (t2 && ~wa.indexOf(i3) && (o4 *= -1), n3[i3] = o4), n3;
    }, {});
  }
  __name(Sa, "Sa");
  a(Sa, "parse");
});
var gi = I((Bh, mi) => {
  "use strict";
  p2();
  mi.exports = a(function(e2) {
    if (/^\\x/.test(e2))
      return new y(
        e2.substr(2),
        "hex"
      );
    for (var t2 = "", n3 = 0; n3 < e2.length; )
      if (e2[n3] !== "\\")
        t2 += e2[n3], ++n3;
      else if (/[0-7]{3}/.test(e2.substr(n3 + 1, 3)))
        t2 += String.fromCharCode(parseInt(e2.substr(n3 + 1, 3), 8)), n3 += 4;
      else {
        for (var i3 = 1; n3 + i3 < e2.length && e2[n3 + i3] === "\\"; )
          i3++;
        for (var s3 = 0; s3 < Math.floor(i3 / 2); ++s3)
          t2 += "\\";
        n3 += Math.floor(i3 / 2) * 2;
      }
    return new y(t2, "binary");
  }, "parseBytea");
});
var _i = I((Fh, vi) => {
  p2();
  var Ke = Gt(), ze = $t(), ht = hi(), bi = yi(), Si = gi();
  function lt2(r3) {
    return a(function(t2) {
      return t2 === null ? t2 : r3(t2);
    }, "nullAllowed");
  }
  __name(lt2, "lt");
  a(lt2, "allowNull");
  function Ei(r3) {
    return r3 === null ? r3 : r3 === "TRUE" || r3 === "t" || r3 === "true" || r3 === "y" || r3 === "yes" || r3 === "on" || r3 === "1";
  }
  __name(Ei, "Ei");
  a(Ei, "parseBool");
  function Ea(r3) {
    return r3 ? Ke.parse(r3, Ei) : null;
  }
  __name(Ea, "Ea");
  a(Ea, "parseBoolArray");
  function xa(r3) {
    return parseInt(r3, 10);
  }
  __name(xa, "xa");
  a(xa, "parseBaseTenInt");
  function zt(r3) {
    return r3 ? Ke.parse(r3, lt2(xa)) : null;
  }
  __name(zt, "zt");
  a(zt, "parseIntegerArray");
  function va(r3) {
    return r3 ? Ke.parse(r3, lt2(function(e2) {
      return xi(e2).trim();
    })) : null;
  }
  __name(va, "va");
  a(va, "parseBigIntegerArray");
  var _a126 = a(function(r3) {
    if (!r3)
      return null;
    var e2 = ze.create(r3, function(t2) {
      return t2 !== null && (t2 = Xt(t2)), t2;
    });
    return e2.parse();
  }, "parsePointArray"), Yt = a(function(r3) {
    if (!r3)
      return null;
    var e2 = ze.create(r3, function(t2) {
      return t2 !== null && (t2 = parseFloat(t2)), t2;
    });
    return e2.parse();
  }, "parseFloatArray"), re = a(function(r3) {
    if (!r3)
      return null;
    var e2 = ze.create(r3);
    return e2.parse();
  }, "parseStringArray"), Zt = a(function(r3) {
    if (!r3)
      return null;
    var e2 = ze.create(r3, function(t2) {
      return t2 !== null && (t2 = ht(t2)), t2;
    });
    return e2.parse();
  }, "parseDateArray"), Aa = a(function(r3) {
    if (!r3)
      return null;
    var e2 = ze.create(r3, function(t2) {
      return t2 !== null && (t2 = bi(t2)), t2;
    });
    return e2.parse();
  }, "parseIntervalArray"), Ca = a(function(r3) {
    return r3 ? Ke.parse(r3, lt2(Si)) : null;
  }, "parseByteAArray"), Jt = a(function(r3) {
    return parseInt(
      r3,
      10
    );
  }, "parseInteger"), xi = a(function(r3) {
    var e2 = String(r3);
    return /^\d+$/.test(e2) ? e2 : r3;
  }, "parseBigInteger"), wi = a(
    function(r3) {
      return r3 ? Ke.parse(r3, lt2(JSON.parse)) : null;
    },
    "parseJsonArray"
  ), Xt = a(function(r3) {
    return r3[0] !== "(" ? null : (r3 = r3.substring(1, r3.length - 1).split(","), { x: parseFloat(r3[0]), y: parseFloat(r3[1]) });
  }, "parsePoint"), Ta = a(function(r3) {
    if (r3[0] !== "<" && r3[1] !== "(")
      return null;
    for (var e2 = "(", t2 = "", n3 = false, i3 = 2; i3 < r3.length - 1; i3++) {
      if (n3 || (e2 += r3[i3]), r3[i3] === ")") {
        n3 = true;
        continue;
      } else if (!n3)
        continue;
      r3[i3] !== "," && (t2 += r3[i3]);
    }
    var s3 = Xt(e2);
    return s3.radius = parseFloat(t2), s3;
  }, "parseCircle"), Ia = a(function(r3) {
    r3(
      20,
      xi
    ), r3(21, Jt), r3(23, Jt), r3(26, Jt), r3(700, parseFloat), r3(701, parseFloat), r3(16, Ei), r3(
      1082,
      ht
    ), r3(1114, ht), r3(1184, ht), r3(600, Xt), r3(651, re), r3(718, Ta), r3(1e3, Ea), r3(1001, Ca), r3(
      1005,
      zt
    ), r3(1007, zt), r3(1028, zt), r3(1016, va), r3(1017, _a126), r3(1021, Yt), r3(1022, Yt), r3(1231, Yt), r3(1014, re), r3(1015, re), r3(1008, re), r3(1009, re), r3(1040, re), r3(1041, re), r3(1115, Zt), r3(
      1182,
      Zt
    ), r3(1185, Zt), r3(1186, bi), r3(1187, Aa), r3(17, Si), r3(114, JSON.parse.bind(JSON)), r3(
      3802,
      JSON.parse.bind(JSON)
    ), r3(199, wi), r3(3807, wi), r3(3907, re), r3(2951, re), r3(791, re), r3(
      1183,
      re
    ), r3(1270, re);
  }, "init");
  vi.exports = { init: Ia };
});
var Ci = I((kh, Ai) => {
  "use strict";
  p2();
  var Z = 1e6;
  function Pa(r3) {
    var e2 = r3.readInt32BE(
      0
    ), t2 = r3.readUInt32BE(4), n3 = "";
    e2 < 0 && (e2 = ~e2 + (t2 === 0), t2 = ~t2 + 1 >>> 0, n3 = "-");
    var i3 = "", s3, o4, u3, c4, h2, l3;
    {
      if (s3 = e2 % Z, e2 = e2 / Z >>> 0, o4 = 4294967296 * s3 + t2, t2 = o4 / Z >>> 0, u3 = "" + (o4 - Z * t2), t2 === 0 && e2 === 0)
        return n3 + u3 + i3;
      for (c4 = "", h2 = 6 - u3.length, l3 = 0; l3 < h2; l3++)
        c4 += "0";
      i3 = c4 + u3 + i3;
    }
    {
      if (s3 = e2 % Z, e2 = e2 / Z >>> 0, o4 = 4294967296 * s3 + t2, t2 = o4 / Z >>> 0, u3 = "" + (o4 - Z * t2), t2 === 0 && e2 === 0)
        return n3 + u3 + i3;
      for (c4 = "", h2 = 6 - u3.length, l3 = 0; l3 < h2; l3++)
        c4 += "0";
      i3 = c4 + u3 + i3;
    }
    {
      if (s3 = e2 % Z, e2 = e2 / Z >>> 0, o4 = 4294967296 * s3 + t2, t2 = o4 / Z >>> 0, u3 = "" + (o4 - Z * t2), t2 === 0 && e2 === 0)
        return n3 + u3 + i3;
      for (c4 = "", h2 = 6 - u3.length, l3 = 0; l3 < h2; l3++)
        c4 += "0";
      i3 = c4 + u3 + i3;
    }
    return s3 = e2 % Z, o4 = 4294967296 * s3 + t2, u3 = "" + o4 % Z, n3 + u3 + i3;
  }
  __name(Pa, "Pa");
  a(Pa, "readInt8");
  Ai.exports = Pa;
});
var Li = I((Nh, Bi) => {
  p2();
  var Ba = Ci(), F = a(function(r3, e2, t2, n3, i3) {
    t2 = t2 || 0, n3 = n3 || false, i3 = i3 || function(C3, B, j3) {
      return C3 * Math.pow(2, j3) + B;
    };
    var s3 = t2 >> 3, o4 = a(function(C3) {
      return n3 ? ~C3 & 255 : C3;
    }, "inv"), u3 = 255, c4 = 8 - t2 % 8;
    e2 < c4 && (u3 = 255 << 8 - e2 & 255, c4 = e2), t2 && (u3 = u3 >> t2 % 8);
    var h2 = 0;
    t2 % 8 + e2 >= 8 && (h2 = i3(0, o4(r3[s3]) & u3, c4));
    for (var l3 = e2 + t2 >> 3, d3 = s3 + 1; d3 < l3; d3++)
      h2 = i3(h2, o4(r3[d3]), 8);
    var b3 = (e2 + t2) % 8;
    return b3 > 0 && (h2 = i3(h2, o4(r3[l3]) >> 8 - b3, b3)), h2;
  }, "parseBits"), Pi = a(function(r3, e2, t2) {
    var n3 = Math.pow(2, t2 - 1) - 1, i3 = F(r3, 1), s3 = F(r3, t2, 1);
    if (s3 === 0)
      return 0;
    var o4 = 1, u3 = a(function(h2, l3, d3) {
      h2 === 0 && (h2 = 1);
      for (var b3 = 1; b3 <= d3; b3++)
        o4 /= 2, (l3 & 1 << d3 - b3) > 0 && (h2 += o4);
      return h2;
    }, "parsePrecisionBits"), c4 = F(r3, e2, t2 + 1, false, u3);
    return s3 == Math.pow(2, t2 + 1) - 1 ? c4 === 0 ? i3 === 0 ? 1 / 0 : -1 / 0 : NaN : (i3 === 0 ? 1 : -1) * Math.pow(2, s3 - n3) * c4;
  }, "parseFloatFromBits"), La = a(function(r3) {
    return F(r3, 1) == 1 ? -1 * (F(r3, 15, 1, true) + 1) : F(r3, 15, 1);
  }, "parseInt16"), Ti = a(function(r3) {
    return F(r3, 1) == 1 ? -1 * (F(
      r3,
      31,
      1,
      true
    ) + 1) : F(r3, 31, 1);
  }, "parseInt32"), Ra = a(function(r3) {
    return Pi(r3, 23, 8);
  }, "parseFloat32"), Fa = a(function(r3) {
    return Pi(r3, 52, 11);
  }, "parseFloat64"), Ma = a(function(r3) {
    var e2 = F(r3, 16, 32);
    if (e2 == 49152)
      return NaN;
    for (var t2 = Math.pow(1e4, F(r3, 16, 16)), n3 = 0, i3 = [], s3 = F(r3, 16), o4 = 0; o4 < s3; o4++)
      n3 += F(r3, 16, 64 + 16 * o4) * t2, t2 /= 1e4;
    var u3 = Math.pow(10, F(r3, 16, 48));
    return (e2 === 0 ? 1 : -1) * Math.round(n3 * u3) / u3;
  }, "parseNumeric"), Ii = a(function(r3, e2) {
    var t2 = F(
      e2,
      1
    ), n3 = F(e2, 63, 1), i3 = new Date((t2 === 0 ? 1 : -1) * n3 / 1e3 + 9466848e5);
    return r3 || i3.setTime(i3.getTime() + i3.getTimezoneOffset() * 6e4), i3.usec = n3 % 1e3, i3.getMicroSeconds = function() {
      return this.usec;
    }, i3.setMicroSeconds = function(s3) {
      this.usec = s3;
    }, i3.getUTCMicroSeconds = function() {
      return this.usec;
    }, i3;
  }, "parseDate"), Ye = a(function(r3) {
    for (var e2 = F(r3, 32), t2 = F(r3, 32, 32), n3 = F(r3, 32, 64), i3 = 96, s3 = [], o4 = 0; o4 < e2; o4++)
      s3[o4] = F(r3, 32, i3), i3 += 32, i3 += 32;
    var u3 = a(function(h2) {
      var l3 = F(r3, 32, i3);
      if (i3 += 32, l3 == 4294967295)
        return null;
      var d3;
      if (h2 == 23 || h2 == 20)
        return d3 = F(r3, l3 * 8, i3), i3 += l3 * 8, d3;
      if (h2 == 25)
        return d3 = r3.toString(this.encoding, i3 >> 3, (i3 += l3 << 3) >> 3), d3;
      console.log("ERROR: ElementType not implemented: " + h2);
    }, "parseElement"), c4 = a(function(h2, l3) {
      var d3 = [], b3;
      if (h2.length > 1) {
        var C3 = h2.shift();
        for (b3 = 0; b3 < C3; b3++)
          d3[b3] = c4(h2, l3);
        h2.unshift(
          C3
        );
      } else
        for (b3 = 0; b3 < h2[0]; b3++)
          d3[b3] = u3(l3);
      return d3;
    }, "parse");
    return c4(s3, n3);
  }, "parseArray"), Da = a(function(r3) {
    return r3.toString("utf8");
  }, "parseText"), ka = a(function(r3) {
    return r3 === null ? null : F(r3, 8) > 0;
  }, "parseBool"), Oa = a(function(r3) {
    r3(20, Ba), r3(21, La), r3(23, Ti), r3(
      26,
      Ti
    ), r3(1700, Ma), r3(700, Ra), r3(701, Fa), r3(16, ka), r3(1114, Ii.bind(null, false)), r3(1184, Ii.bind(
      null,
      true
    )), r3(1e3, Ye), r3(1007, Ye), r3(1016, Ye), r3(1008, Ye), r3(1009, Ye), r3(25, Da);
  }, "init");
  Bi.exports = { init: Oa };
});
var Fi = I((jh, Ri) => {
  p2();
  Ri.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});
var Xe = I((Je) => {
  p2();
  var Ua = _i(), Na = Li(), qa = $t(), Qa = Fi();
  Je.getTypeParser = ja;
  Je.setTypeParser = Wa;
  Je.arrayParser = qa;
  Je.builtins = Qa;
  var Ze = { text: {}, binary: {} };
  function Mi(r3) {
    return String(
      r3
    );
  }
  __name(Mi, "Mi");
  a(Mi, "noParse");
  function ja(r3, e2) {
    return e2 = e2 || "text", Ze[e2] && Ze[e2][r3] || Mi;
  }
  __name(ja, "ja");
  a(
    ja,
    "getTypeParser"
  );
  function Wa(r3, e2, t2) {
    typeof e2 == "function" && (t2 = e2, e2 = "text"), Ze[e2][r3] = t2;
  }
  __name(Wa, "Wa");
  a(Wa, "setTypeParser");
  Ua.init(function(r3, e2) {
    Ze.text[r3] = e2;
  });
  Na.init(function(r3, e2) {
    Ze.binary[r3] = e2;
  });
});
var et = I((Vh, er) => {
  "use strict";
  p2();
  er.exports = {
    host: "localhost",
    user: m2.platform === "win32" ? m2.env.USERNAME : m2.env.USER,
    database: void 0,
    password: null,
    connectionString: void 0,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 3e4,
    client_encoding: "",
    ssl: false,
    application_name: void 0,
    fallback_application_name: void 0,
    options: void 0,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var De = Xe(), Ha = De.getTypeParser(
    20,
    "text"
  ), Ga = De.getTypeParser(1016, "text");
  er.exports.__defineSetter__("parseInt8", function(r3) {
    De.setTypeParser(20, "text", r3 ? De.getTypeParser(23, "text") : Ha), De.setTypeParser(1016, "text", r3 ? De.getTypeParser(1007, "text") : Ga);
  });
});
var tt = I((zh, ki) => {
  "use strict";
  p2();
  var $a = (Wt(), N(jt)), Va = et();
  function Ka(r3) {
    var e2 = r3.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + e2 + '"';
  }
  __name(Ka, "Ka");
  a(Ka, "escapeElement");
  function Di(r3) {
    for (var e2 = "{", t2 = 0; t2 < r3.length; t2++)
      t2 > 0 && (e2 = e2 + ","), r3[t2] === null || typeof r3[t2] > "u" ? e2 = e2 + "NULL" : Array.isArray(r3[t2]) ? e2 = e2 + Di(r3[t2]) : r3[t2] instanceof y ? e2 += "\\\\x" + r3[t2].toString("hex") : e2 += Ka(ft(r3[t2]));
    return e2 = e2 + "}", e2;
  }
  __name(Di, "Di");
  a(Di, "arrayString");
  var ft = a(function(r3, e2) {
    if (r3 == null)
      return null;
    if (r3 instanceof y)
      return r3;
    if (ArrayBuffer.isView(r3)) {
      var t2 = y.from(r3.buffer, r3.byteOffset, r3.byteLength);
      return t2.length === r3.byteLength ? t2 : t2.slice(
        r3.byteOffset,
        r3.byteOffset + r3.byteLength
      );
    }
    return r3 instanceof Date ? Va.parseInputDatesAsUTC ? Za(r3) : Ya(r3) : Array.isArray(r3) ? Di(r3) : typeof r3 == "object" ? za(r3, e2) : r3.toString();
  }, "prepareValue");
  function za(r3, e2) {
    if (r3 && typeof r3.toPostgres == "function") {
      if (e2 = e2 || [], e2.indexOf(r3) !== -1)
        throw new Error('circular reference detected while preparing "' + r3 + '" for query');
      return e2.push(r3), ft(r3.toPostgres(ft), e2);
    }
    return JSON.stringify(r3);
  }
  __name(za, "za");
  a(za, "prepareObject");
  function H2(r3, e2) {
    for (r3 = "" + r3; r3.length < e2; )
      r3 = "0" + r3;
    return r3;
  }
  __name(H2, "H");
  a(
    H2,
    "pad"
  );
  function Ya(r3) {
    var e2 = -r3.getTimezoneOffset(), t2 = r3.getFullYear(), n3 = t2 < 1;
    n3 && (t2 = Math.abs(t2) + 1);
    var i3 = H2(t2, 4) + "-" + H2(r3.getMonth() + 1, 2) + "-" + H2(r3.getDate(), 2) + "T" + H2(r3.getHours(), 2) + ":" + H2(r3.getMinutes(), 2) + ":" + H2(r3.getSeconds(), 2) + "." + H2(
      r3.getMilliseconds(),
      3
    );
    return e2 < 0 ? (i3 += "-", e2 *= -1) : i3 += "+", i3 += H2(Math.floor(e2 / 60), 2) + ":" + H2(e2 % 60, 2), n3 && (i3 += " BC"), i3;
  }
  __name(Ya, "Ya");
  a(Ya, "dateToString");
  function Za(r3) {
    var e2 = r3.getUTCFullYear(), t2 = e2 < 1;
    t2 && (e2 = Math.abs(e2) + 1);
    var n3 = H2(e2, 4) + "-" + H2(r3.getUTCMonth() + 1, 2) + "-" + H2(r3.getUTCDate(), 2) + "T" + H2(r3.getUTCHours(), 2) + ":" + H2(r3.getUTCMinutes(), 2) + ":" + H2(r3.getUTCSeconds(), 2) + "." + H2(r3.getUTCMilliseconds(), 3);
    return n3 += "+00:00", t2 && (n3 += " BC"), n3;
  }
  __name(Za, "Za");
  a(Za, "dateToStringUTC");
  function Ja(r3, e2, t2) {
    return r3 = typeof r3 == "string" ? { text: r3 } : r3, e2 && (typeof e2 == "function" ? r3.callback = e2 : r3.values = e2), t2 && (r3.callback = t2), r3;
  }
  __name(Ja, "Ja");
  a(Ja, "normalizeQueryConfig");
  var tr = a(function(r3) {
    return $a.createHash("md5").update(r3, "utf-8").digest("hex");
  }, "md5"), Xa = a(function(r3, e2, t2) {
    var n3 = tr(e2 + r3), i3 = tr(y.concat([y.from(n3), t2]));
    return "md5" + i3;
  }, "postgresMd5PasswordHash");
  ki.exports = { prepareValue: a(function(e2) {
    return ft(
      e2
    );
  }, "prepareValueWrapper"), normalizeQueryConfig: Ja, postgresMd5PasswordHash: Xa, md5: tr };
});
var Qi = I((Jh, qi) => {
  "use strict";
  p2();
  var rr = (Wt(), N(jt));
  function eu(r3) {
    if (r3.indexOf(
      "SCRAM-SHA-256"
    ) === -1)
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    let e2 = rr.randomBytes(18).toString("base64");
    return { mechanism: "SCRAM-SHA-256", clientNonce: e2, response: "n,,n=*,r=" + e2, message: "SASLInitialResponse" };
  }
  __name(eu, "eu");
  a(eu, "startSession");
  function tu(r3, e2, t2) {
    if (r3.message !== "SASLInitialResponse")
      throw new Error(
        "SASL: Last message was not SASLInitialResponse"
      );
    if (typeof e2 != "string")
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string"
      );
    if (typeof t2 != "string")
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    let n3 = iu(t2);
    if (n3.nonce.startsWith(r3.clientNonce)) {
      if (n3.nonce.length === r3.clientNonce.length)
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    var i3 = y.from(n3.salt, "base64"), s3 = au(
      e2,
      i3,
      n3.iteration
    ), o4 = ke(s3, "Client Key"), u3 = ou(o4), c4 = "n=*,r=" + r3.clientNonce, h2 = "r=" + n3.nonce + ",s=" + n3.salt + ",i=" + n3.iteration, l3 = "c=biws,r=" + n3.nonce, d3 = c4 + "," + h2 + "," + l3, b3 = ke(u3, d3), C3 = Ni(
      o4,
      b3
    ), B = C3.toString("base64"), j3 = ke(s3, "Server Key"), X = ke(j3, d3);
    r3.message = "SASLResponse", r3.serverSignature = X.toString("base64"), r3.response = l3 + ",p=" + B;
  }
  __name(tu, "tu");
  a(tu, "continueSession");
  function ru(r3, e2) {
    if (r3.message !== "SASLResponse")
      throw new Error("SASL: Last message was not SASLResponse");
    if (typeof e2 != "string")
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    let { serverSignature: t2 } = su(
      e2
    );
    if (t2 !== r3.serverSignature)
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
  }
  __name(ru, "ru");
  a(ru, "finalizeSession");
  function nu(r3) {
    if (typeof r3 != "string")
      throw new TypeError("SASL: text must be a string");
    return r3.split("").map(
      (e2, t2) => r3.charCodeAt(t2)
    ).every((e2) => e2 >= 33 && e2 <= 43 || e2 >= 45 && e2 <= 126);
  }
  __name(nu, "nu");
  a(nu, "isPrintableChars");
  function Oi(r3) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r3);
  }
  __name(Oi, "Oi");
  a(Oi, "isBase64");
  function Ui(r3) {
    if (typeof r3 != "string")
      throw new TypeError(
        "SASL: attribute pairs text must be a string"
      );
    return new Map(r3.split(",").map((e2) => {
      if (!/^.=/.test(e2))
        throw new Error("SASL: Invalid attribute pair entry");
      let t2 = e2[0], n3 = e2.substring(2);
      return [t2, n3];
    }));
  }
  __name(Ui, "Ui");
  a(Ui, "parseAttributePairs");
  function iu(r3) {
    let e2 = Ui(
      r3
    ), t2 = e2.get("r");
    if (t2) {
      if (!nu(t2))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    let n3 = e2.get("s");
    if (n3) {
      if (!Oi(n3))
        throw new Error(
          "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64"
        );
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    let i3 = e2.get("i");
    if (i3) {
      if (!/^[1-9][0-9]*$/.test(i3))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    let s3 = parseInt(i3, 10);
    return { nonce: t2, salt: n3, iteration: s3 };
  }
  __name(iu, "iu");
  a(iu, "parseServerFirstMessage");
  function su(r3) {
    let t2 = Ui(r3).get("v");
    if (t2) {
      if (!Oi(t2))
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    } else
      throw new Error(
        "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing"
      );
    return { serverSignature: t2 };
  }
  __name(su, "su");
  a(su, "parseServerFinalMessage");
  function Ni(r3, e2) {
    if (!y.isBuffer(r3))
      throw new TypeError(
        "first argument must be a Buffer"
      );
    if (!y.isBuffer(e2))
      throw new TypeError("second argument must be a Buffer");
    if (r3.length !== e2.length)
      throw new Error("Buffer lengths must match");
    if (r3.length === 0)
      throw new Error("Buffers cannot be empty");
    return y.from(r3.map((t2, n3) => r3[n3] ^ e2[n3]));
  }
  __name(Ni, "Ni");
  a(Ni, "xorBuffers");
  function ou(r3) {
    return rr.createHash(
      "sha256"
    ).update(r3).digest();
  }
  __name(ou, "ou");
  a(ou, "sha256");
  function ke(r3, e2) {
    return rr.createHmac(
      "sha256",
      r3
    ).update(e2).digest();
  }
  __name(ke, "ke");
  a(ke, "hmacSha256");
  function au(r3, e2, t2) {
    for (var n3 = ke(
      r3,
      y.concat([e2, y.from([0, 0, 0, 1])])
    ), i3 = n3, s3 = 0; s3 < t2 - 1; s3++)
      n3 = ke(r3, n3), i3 = Ni(i3, n3);
    return i3;
  }
  __name(au, "au");
  a(au, "Hi");
  qi.exports = { startSession: eu, continueSession: tu, finalizeSession: ru };
});
var nr = {};
ie(nr, { join: () => uu });
function uu(...r3) {
  return r3.join("/");
}
__name(uu, "uu");
var ir = z2(() => {
  "use strict";
  p2();
  a(uu, "join");
});
var sr = {};
ie(sr, { stat: () => cu });
function cu(r3, e2) {
  e2(new Error("No filesystem"));
}
__name(cu, "cu");
var or2 = z2(
  () => {
    "use strict";
    p2();
    a(cu, "stat");
  }
);
var ar = {};
ie(ar, { default: () => hu });
var hu;
var ur = z2(() => {
  "use strict";
  p2();
  hu = {};
});
var ji = {};
ie(ji, { StringDecoder: () => cr });
var hr;
var cr;
var Wi = z2(() => {
  "use strict";
  p2();
  hr = /* @__PURE__ */ __name(class hr {
    constructor(e2) {
      _(this, "td");
      this.td = new TextDecoder(e2);
    }
    write(e2) {
      return this.td.decode(e2, { stream: true });
    }
    end(e2) {
      return this.td.decode(e2);
    }
  }, "hr");
  a(hr, "StringDecoder");
  cr = hr;
});
var Vi = I((ul, $i) => {
  "use strict";
  p2();
  var { Transform: lu } = (ur(), N(ar)), { StringDecoder: fu } = (Wi(), N(ji)), be = Symbol("last"), pt = Symbol("decoder");
  function pu(r3, e2, t2) {
    let n3;
    if (this.overflow) {
      if (n3 = this[pt].write(r3).split(this.matcher), n3.length === 1)
        return t2();
      n3.shift(), this.overflow = false;
    } else
      this[be] += this[pt].write(r3), n3 = this[be].split(this.matcher);
    this[be] = n3.pop();
    for (let i3 = 0; i3 < n3.length; i3++)
      try {
        Gi(this, this.mapper(n3[i3]));
      } catch (s3) {
        return t2(
          s3
        );
      }
    if (this.overflow = this[be].length > this.maxLength, this.overflow && !this.skipOverflow) {
      t2(new Error("maximum buffer reached"));
      return;
    }
    t2();
  }
  __name(pu, "pu");
  a(pu, "transform");
  function du(r3) {
    if (this[be] += this[pt].end(), this[be])
      try {
        Gi(this, this.mapper(this[be]));
      } catch (e2) {
        return r3(e2);
      }
    r3();
  }
  __name(du, "du");
  a(du, "flush");
  function Gi(r3, e2) {
    e2 !== void 0 && r3.push(e2);
  }
  __name(Gi, "Gi");
  a(Gi, "push");
  function Hi(r3) {
    return r3;
  }
  __name(Hi, "Hi");
  a(Hi, "noop");
  function yu(r3, e2, t2) {
    switch (r3 = r3 || /\r?\n/, e2 = e2 || Hi, t2 = t2 || {}, arguments.length) {
      case 1:
        typeof r3 == "function" ? (e2 = r3, r3 = /\r?\n/) : typeof r3 == "object" && !(r3 instanceof RegExp) && !r3[Symbol.split] && (t2 = r3, r3 = /\r?\n/);
        break;
      case 2:
        typeof r3 == "function" ? (t2 = e2, e2 = r3, r3 = /\r?\n/) : typeof e2 == "object" && (t2 = e2, e2 = Hi);
    }
    t2 = Object.assign({}, t2), t2.autoDestroy = true, t2.transform = pu, t2.flush = du, t2.readableObjectMode = true;
    let n3 = new lu(t2);
    return n3[be] = "", n3[pt] = new fu("utf8"), n3.matcher = r3, n3.mapper = e2, n3.maxLength = t2.maxLength, n3.skipOverflow = t2.skipOverflow || false, n3.overflow = false, n3._destroy = function(i3, s3) {
      this._writableState.errorEmitted = false, s3(i3);
    }, n3;
  }
  __name(yu, "yu");
  a(yu, "split");
  $i.exports = yu;
});
var Yi = I((ll, le) => {
  "use strict";
  p2();
  var Ki = (ir(), N(nr)), mu = (ur(), N(ar)).Stream, gu = Vi(), zi = (Ge(), N(He)), wu = 5432, dt = m2.platform === "win32", rt = m2.stderr, bu = 56, Su = 7, Eu = 61440, xu = 32768;
  function vu(r3) {
    return (r3 & Eu) == xu;
  }
  __name(vu, "vu");
  a(vu, "isRegFile");
  var Oe = [
    "host",
    "port",
    "database",
    "user",
    "password"
  ], lr = Oe.length, _u = Oe[lr - 1];
  function fr() {
    var r3 = rt instanceof mu && rt.writable === true;
    if (r3) {
      var e2 = Array.prototype.slice.call(arguments).concat(`
`);
      rt.write(zi.format.apply(zi, e2));
    }
  }
  __name(fr, "fr");
  a(fr, "warn");
  Object.defineProperty(
    le.exports,
    "isWin",
    { get: a(function() {
      return dt;
    }, "get"), set: a(function(r3) {
      dt = r3;
    }, "set") }
  );
  le.exports.warnTo = function(r3) {
    var e2 = rt;
    return rt = r3, e2;
  };
  le.exports.getFileName = function(r3) {
    var e2 = r3 || m2.env, t2 = e2.PGPASSFILE || (dt ? Ki.join(e2.APPDATA || "./", "postgresql", "pgpass.conf") : Ki.join(e2.HOME || "./", ".pgpass"));
    return t2;
  };
  le.exports.usePgPass = function(r3, e2) {
    return Object.prototype.hasOwnProperty.call(m2.env, "PGPASSWORD") ? false : dt ? true : (e2 = e2 || "<unkn>", vu(r3.mode) ? r3.mode & (bu | Su) ? (fr('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', e2), false) : true : (fr('WARNING: password file "%s" is not a plain file', e2), false));
  };
  var Au = le.exports.match = function(r3, e2) {
    return Oe.slice(0, -1).reduce(function(t2, n3, i3) {
      return i3 == 1 && Number(r3[n3] || wu) === Number(
        e2[n3]
      ) ? t2 && true : t2 && (e2[n3] === "*" || e2[n3] === r3[n3]);
    }, true);
  };
  le.exports.getPassword = function(r3, e2, t2) {
    var n3, i3 = e2.pipe(gu());
    function s3(c4) {
      var h2 = Cu(c4);
      h2 && Tu(h2) && Au(r3, h2) && (n3 = h2[_u], i3.end());
    }
    __name(s3, "s");
    a(s3, "onLine");
    var o4 = a(function() {
      e2.destroy(), t2(n3);
    }, "onEnd"), u3 = a(function(c4) {
      e2.destroy(), fr("WARNING: error on reading file: %s", c4), t2(void 0);
    }, "onErr");
    e2.on("error", u3), i3.on("data", s3).on("end", o4).on("error", u3);
  };
  var Cu = le.exports.parseLine = function(r3) {
    if (r3.length < 11 || r3.match(/^\s+#/))
      return null;
    for (var e2 = "", t2 = "", n3 = 0, i3 = 0, s3 = 0, o4 = {}, u3 = false, c4 = a(function(l3, d3, b3) {
      var C3 = r3.substring(d3, b3);
      Object.hasOwnProperty.call(
        m2.env,
        "PGPASS_NO_DEESCAPE"
      ) || (C3 = C3.replace(/\\([:\\])/g, "$1")), o4[Oe[l3]] = C3;
    }, "addToObj"), h2 = 0; h2 < r3.length - 1; h2 += 1) {
      if (e2 = r3.charAt(h2 + 1), t2 = r3.charAt(h2), u3 = n3 == lr - 1, u3) {
        c4(n3, i3);
        break;
      }
      h2 >= 0 && e2 == ":" && t2 !== "\\" && (c4(n3, i3, h2 + 1), i3 = h2 + 2, n3 += 1);
    }
    return o4 = Object.keys(o4).length === lr ? o4 : null, o4;
  }, Tu = le.exports.isValidEntry = function(r3) {
    for (var e2 = { 0: function(o4) {
      return o4.length > 0;
    }, 1: function(o4) {
      return o4 === "*" ? true : (o4 = Number(o4), isFinite(o4) && o4 > 0 && o4 < 9007199254740992 && Math.floor(o4) === o4);
    }, 2: function(o4) {
      return o4.length > 0;
    }, 3: function(o4) {
      return o4.length > 0;
    }, 4: function(o4) {
      return o4.length > 0;
    } }, t2 = 0; t2 < Oe.length; t2 += 1) {
      var n3 = e2[t2], i3 = r3[Oe[t2]] || "", s3 = n3(i3);
      if (!s3)
        return false;
    }
    return true;
  };
});
var Ji = I((yl, pr) => {
  "use strict";
  p2();
  var dl = (ir(), N(nr)), Zi = (or2(), N(sr)), yt = Yi();
  pr.exports = function(r3, e2) {
    var t2 = yt.getFileName();
    Zi.stat(t2, function(n3, i3) {
      if (n3 || !yt.usePgPass(i3, t2))
        return e2(void 0);
      var s3 = Zi.createReadStream(t2);
      yt.getPassword(
        r3,
        s3,
        e2
      );
    });
  };
  pr.exports.warnTo = yt.warnTo;
});
var gt2 = I((gl, Xi) => {
  "use strict";
  p2();
  var Iu = Xe();
  function mt(r3) {
    this._types = r3 || Iu, this.text = {}, this.binary = {};
  }
  __name(mt, "mt");
  a(mt, "TypeOverrides");
  mt.prototype.getOverrides = function(r3) {
    switch (r3) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  mt.prototype.setTypeParser = function(r3, e2, t2) {
    typeof e2 == "function" && (t2 = e2, e2 = "text"), this.getOverrides(e2)[r3] = t2;
  };
  mt.prototype.getTypeParser = function(r3, e2) {
    return e2 = e2 || "text", this.getOverrides(e2)[r3] || this._types.getTypeParser(r3, e2);
  };
  Xi.exports = mt;
});
var es = {};
ie(es, { default: () => Pu });
var Pu;
var ts = z2(() => {
  "use strict";
  p2();
  Pu = {};
});
var rs = {};
ie(rs, { parse: () => dr });
function dr(r3, e2 = false) {
  let { protocol: t2 } = new URL(r3), n3 = "http:" + r3.substring(t2.length), {
    username: i3,
    password: s3,
    host: o4,
    hostname: u3,
    port: c4,
    pathname: h2,
    search: l3,
    searchParams: d3,
    hash: b3
  } = new URL(n3);
  s3 = decodeURIComponent(s3), i3 = decodeURIComponent(
    i3
  ), h2 = decodeURIComponent(h2);
  let C3 = i3 + ":" + s3, B = e2 ? Object.fromEntries(d3.entries()) : l3;
  return {
    href: r3,
    protocol: t2,
    auth: C3,
    username: i3,
    password: s3,
    host: o4,
    hostname: u3,
    port: c4,
    pathname: h2,
    search: l3,
    query: B,
    hash: b3
  };
}
__name(dr, "dr");
var yr = z2(() => {
  "use strict";
  p2();
  a(dr, "parse");
});
var is2 = I((vl, ns) => {
  "use strict";
  p2();
  var Bu = (yr(), N(rs)), mr = (or2(), N(sr));
  function gr(r3) {
    if (r3.charAt(0) === "/") {
      var t2 = r3.split(" ");
      return { host: t2[0], database: t2[1] };
    }
    var e2 = Bu.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r3) ? encodeURI(r3).replace(
      /\%25(\d\d)/g,
      "%$1"
    ) : r3, true), t2 = e2.query;
    for (var n3 in t2)
      Array.isArray(t2[n3]) && (t2[n3] = t2[n3][t2[n3].length - 1]);
    var i3 = (e2.auth || ":").split(":");
    if (t2.user = i3[0], t2.password = i3.splice(1).join(":"), t2.port = e2.port, e2.protocol == "socket:")
      return t2.host = decodeURI(e2.pathname), t2.database = e2.query.db, t2.client_encoding = e2.query.encoding, t2;
    t2.host || (t2.host = e2.hostname);
    var s3 = e2.pathname;
    if (!t2.host && s3 && /^%2f/i.test(s3)) {
      var o4 = s3.split("/");
      t2.host = decodeURIComponent(
        o4[0]
      ), s3 = o4.splice(1).join("/");
    }
    switch (s3 && s3.charAt(0) === "/" && (s3 = s3.slice(1) || null), t2.database = s3 && decodeURI(s3), (t2.ssl === "true" || t2.ssl === "1") && (t2.ssl = true), t2.ssl === "0" && (t2.ssl = false), (t2.sslcert || t2.sslkey || t2.sslrootcert || t2.sslmode) && (t2.ssl = {}), t2.sslcert && (t2.ssl.cert = mr.readFileSync(t2.sslcert).toString()), t2.sslkey && (t2.ssl.key = mr.readFileSync(
      t2.sslkey
    ).toString()), t2.sslrootcert && (t2.ssl.ca = mr.readFileSync(t2.sslrootcert).toString()), t2.sslmode) {
      case "disable": {
        t2.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        break;
      case "no-verify": {
        t2.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return t2;
  }
  __name(gr, "gr");
  a(gr, "parse");
  ns.exports = gr;
  gr.parse = gr;
});
var wt = I((Cl, as) => {
  "use strict";
  p2();
  var Lu = (ts(), N(es)), os = et(), ss = is2().parse, $2 = a(
    function(r3, e2, t2) {
      return t2 === void 0 ? t2 = m2.env["PG" + r3.toUpperCase()] : t2 === false || (t2 = m2.env[t2]), e2[r3] || t2 || os[r3];
    },
    "val"
  ), Ru = a(function() {
    switch (m2.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return os.ssl;
  }, "readSSLConfigFromEnvironment"), Ue = a(
    function(r3) {
      return "'" + ("" + r3).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    },
    "quoteParamValue"
  ), ne2 = a(function(r3, e2, t2) {
    var n3 = e2[t2];
    n3 != null && r3.push(t2 + "=" + Ue(n3));
  }, "add"), br = /* @__PURE__ */ __name(class br {
    constructor(e2) {
      e2 = typeof e2 == "string" ? ss(e2) : e2 || {}, e2.connectionString && (e2 = Object.assign({}, e2, ss(e2.connectionString))), this.user = $2("user", e2), this.database = $2("database", e2), this.database === void 0 && (this.database = this.user), this.port = parseInt(
        $2("port", e2),
        10
      ), this.host = $2("host", e2), Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: $2("password", e2)
      }), this.binary = $2("binary", e2), this.options = $2("options", e2), this.ssl = typeof e2.ssl > "u" ? Ru() : e2.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = true), this.ssl === "no-verify" && (this.ssl = { rejectUnauthorized: false }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this.client_encoding = $2("client_encoding", e2), this.replication = $2("replication", e2), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = $2("application_name", e2, "PGAPPNAME"), this.fallback_application_name = $2("fallback_application_name", e2, false), this.statement_timeout = $2("statement_timeout", e2, false), this.lock_timeout = $2(
        "lock_timeout",
        e2,
        false
      ), this.idle_in_transaction_session_timeout = $2("idle_in_transaction_session_timeout", e2, false), this.query_timeout = $2("query_timeout", e2, false), e2.connectionTimeoutMillis === void 0 ? this.connect_timeout = m2.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e2.connectionTimeoutMillis / 1e3), e2.keepAlive === false ? this.keepalives = 0 : e2.keepAlive === true && (this.keepalives = 1), typeof e2.keepAliveInitialDelayMillis == "number" && (this.keepalives_idle = Math.floor(e2.keepAliveInitialDelayMillis / 1e3));
    }
    getLibpqConnectionString(e2) {
      var t2 = [];
      ne2(t2, this, "user"), ne2(t2, this, "password"), ne2(t2, this, "port"), ne2(t2, this, "application_name"), ne2(t2, this, "fallback_application_name"), ne2(t2, this, "connect_timeout"), ne2(
        t2,
        this,
        "options"
      );
      var n3 = typeof this.ssl == "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      if (ne2(t2, n3, "sslmode"), ne2(t2, n3, "sslca"), ne2(t2, n3, "sslkey"), ne2(t2, n3, "sslcert"), ne2(t2, n3, "sslrootcert"), this.database && t2.push("dbname=" + Ue(this.database)), this.replication && t2.push("replication=" + Ue(this.replication)), this.host && t2.push("host=" + Ue(this.host)), this.isDomainSocket)
        return e2(null, t2.join(" "));
      this.client_encoding && t2.push("client_encoding=" + Ue(this.client_encoding)), Lu.lookup(this.host, function(i3, s3) {
        return i3 ? e2(i3, null) : (t2.push("hostaddr=" + Ue(s3)), e2(null, t2.join(" ")));
      });
    }
  }, "br");
  a(br, "ConnectionParameters");
  var wr = br;
  as.exports = wr;
});
var hs = I((Pl, cs) => {
  "use strict";
  p2();
  var Fu = Xe(), us = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, Er = /* @__PURE__ */ __name(class Er {
    constructor(e2, t2) {
      this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t2, this.RowCtor = null, this.rowAsArray = e2 === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
    }
    addCommandComplete(e2) {
      var t2;
      e2.text ? t2 = us.exec(e2.text) : t2 = us.exec(e2.command), t2 && (this.command = t2[1], t2[3] ? (this.oid = parseInt(t2[2], 10), this.rowCount = parseInt(t2[3], 10)) : t2[2] && (this.rowCount = parseInt(
        t2[2],
        10
      )));
    }
    _parseRowAsArray(e2) {
      for (var t2 = new Array(e2.length), n3 = 0, i3 = e2.length; n3 < i3; n3++) {
        var s3 = e2[n3];
        s3 !== null ? t2[n3] = this._parsers[n3](s3) : t2[n3] = null;
      }
      return t2;
    }
    parseRow(e2) {
      for (var t2 = {}, n3 = 0, i3 = e2.length; n3 < i3; n3++) {
        var s3 = e2[n3], o4 = this.fields[n3].name;
        s3 !== null ? t2[o4] = this._parsers[n3](
          s3
        ) : t2[o4] = null;
      }
      return t2;
    }
    addRow(e2) {
      this.rows.push(e2);
    }
    addFields(e2) {
      this.fields = e2, this.fields.length && (this._parsers = new Array(e2.length));
      for (var t2 = 0; t2 < e2.length; t2++) {
        var n3 = e2[t2];
        this._types ? this._parsers[t2] = this._types.getTypeParser(n3.dataTypeID, n3.format || "text") : this._parsers[t2] = Fu.getTypeParser(n3.dataTypeID, n3.format || "text");
      }
    }
  }, "Er");
  a(Er, "Result");
  var Sr = Er;
  cs.exports = Sr;
});
var ds = I((Rl, ps) => {
  "use strict";
  p2();
  var { EventEmitter: Mu } = we(), ls = hs(), fs = tt(), vr = /* @__PURE__ */ __name(class vr extends Mu {
    constructor(e2, t2, n3) {
      super(), e2 = fs.normalizeQueryConfig(e2, t2, n3), this.text = e2.text, this.values = e2.values, this.rows = e2.rows, this.types = e2.types, this.name = e2.name, this.binary = e2.binary, this.portal = e2.portal || "", this.callback = e2.callback, this._rowMode = e2.rowMode, m2.domain && e2.callback && (this.callback = m2.domain.bind(e2.callback)), this._result = new ls(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = false, this._canceledDueToError = false, this._promise = null;
    }
    requiresPreparation() {
      return this.name || this.rows ? true : !this.text || !this.values ? false : this.values.length > 0;
    }
    _checkForMultirow() {
      this._result.command && (Array.isArray(this._results) || (this._results = [this._result]), this._result = new ls(
        this._rowMode,
        this.types
      ), this._results.push(this._result));
    }
    handleRowDescription(e2) {
      this._checkForMultirow(), this._result.addFields(e2.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(e2) {
      let t2;
      if (!this._canceledDueToError) {
        try {
          t2 = this._result.parseRow(e2.fields);
        } catch (n3) {
          this._canceledDueToError = n3;
          return;
        }
        this.emit("row", t2, this._result), this._accumulateRows && this._result.addRow(t2);
      }
    }
    handleCommandComplete(e2, t2) {
      this._checkForMultirow(), this._result.addCommandComplete(e2), this.rows && t2.sync();
    }
    handleEmptyQuery(e2) {
      this.rows && e2.sync();
    }
    handleError(e2, t2) {
      if (this._canceledDueToError && (e2 = this._canceledDueToError, this._canceledDueToError = false), this.callback)
        return this.callback(e2);
      this.emit("error", e2);
    }
    handleReadyForQuery(e2) {
      if (this._canceledDueToError)
        return this.handleError(
          this._canceledDueToError,
          e2
        );
      if (this.callback)
        try {
          this.callback(null, this._results);
        } catch (t2) {
          m2.nextTick(() => {
            throw t2;
          });
        }
      this.emit("end", this._results);
    }
    submit(e2) {
      if (typeof this.text != "string" && typeof this.name != "string")
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      let t2 = e2.parsedStatements[this.name];
      return this.text && t2 && this.text !== t2 ? new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query values must be an array") : (this.requiresPreparation() ? this.prepare(e2) : e2.query(this.text), null);
    }
    hasBeenParsed(e2) {
      return this.name && e2.parsedStatements[this.name];
    }
    handlePortalSuspended(e2) {
      this._getRows(e2, this.rows);
    }
    _getRows(e2, t2) {
      e2.execute(
        { portal: this.portal, rows: t2 }
      ), t2 ? e2.flush() : e2.sync();
    }
    prepare(e2) {
      this.isPreparedStatement = true, this.hasBeenParsed(e2) || e2.parse({ text: this.text, name: this.name, types: this.types });
      try {
        e2.bind({ portal: this.portal, statement: this.name, values: this.values, binary: this.binary, valueMapper: fs.prepareValue });
      } catch (t2) {
        this.handleError(t2, e2);
        return;
      }
      e2.describe(
        { type: "P", name: this.portal || "" }
      ), this._getRows(e2, this.rows);
    }
    handleCopyInResponse(e2) {
      e2.sendCopyFail("No source stream defined");
    }
    handleCopyData(e2, t2) {
    }
  }, "vr");
  a(vr, "Query");
  var xr = vr;
  ps.exports = xr;
});
var gs = {};
ie(gs, { Socket: () => Ae, isIP: () => Du });
function Du(r3) {
  return 0;
}
__name(Du, "Du");
var ms;
var ys;
var v;
var Ae;
var bt = z2(() => {
  "use strict";
  p2();
  ms = Ie(we(), 1);
  a(Du, "isIP");
  ys = /^[^.]+\./, v = /* @__PURE__ */ __name(class v4 extends ms.EventEmitter {
    constructor() {
      super(...arguments);
      _(this, "opts", {});
      _(this, "connecting", false);
      _(this, "pending", true);
      _(this, "writable", true);
      _(this, "encrypted", false);
      _(this, "authorized", false);
      _(this, "destroyed", false);
      _(this, "ws", null);
      _(this, "writeBuffer");
      _(this, "tlsState", 0);
      _(
        this,
        "tlsRead"
      );
      _(this, "tlsWrite");
    }
    static get poolQueryViaFetch() {
      return v4.opts.poolQueryViaFetch ?? v4.defaults.poolQueryViaFetch;
    }
    static set poolQueryViaFetch(t2) {
      v4.opts.poolQueryViaFetch = t2;
    }
    static get fetchEndpoint() {
      return v4.opts.fetchEndpoint ?? v4.defaults.fetchEndpoint;
    }
    static set fetchEndpoint(t2) {
      v4.opts.fetchEndpoint = t2;
    }
    static get fetchConnectionCache() {
      return true;
    }
    static set fetchConnectionCache(t2) {
      console.warn("The `fetchConnectionCache` option is deprecated (now always `true`)");
    }
    static get fetchFunction() {
      return v4.opts.fetchFunction ?? v4.defaults.fetchFunction;
    }
    static set fetchFunction(t2) {
      v4.opts.fetchFunction = t2;
    }
    static get webSocketConstructor() {
      return v4.opts.webSocketConstructor ?? v4.defaults.webSocketConstructor;
    }
    static set webSocketConstructor(t2) {
      v4.opts.webSocketConstructor = t2;
    }
    get webSocketConstructor() {
      return this.opts.webSocketConstructor ?? v4.webSocketConstructor;
    }
    set webSocketConstructor(t2) {
      this.opts.webSocketConstructor = t2;
    }
    static get wsProxy() {
      return v4.opts.wsProxy ?? v4.defaults.wsProxy;
    }
    static set wsProxy(t2) {
      v4.opts.wsProxy = t2;
    }
    get wsProxy() {
      return this.opts.wsProxy ?? v4.wsProxy;
    }
    set wsProxy(t2) {
      this.opts.wsProxy = t2;
    }
    static get coalesceWrites() {
      return v4.opts.coalesceWrites ?? v4.defaults.coalesceWrites;
    }
    static set coalesceWrites(t2) {
      v4.opts.coalesceWrites = t2;
    }
    get coalesceWrites() {
      return this.opts.coalesceWrites ?? v4.coalesceWrites;
    }
    set coalesceWrites(t2) {
      this.opts.coalesceWrites = t2;
    }
    static get useSecureWebSocket() {
      return v4.opts.useSecureWebSocket ?? v4.defaults.useSecureWebSocket;
    }
    static set useSecureWebSocket(t2) {
      v4.opts.useSecureWebSocket = t2;
    }
    get useSecureWebSocket() {
      return this.opts.useSecureWebSocket ?? v4.useSecureWebSocket;
    }
    set useSecureWebSocket(t2) {
      this.opts.useSecureWebSocket = t2;
    }
    static get forceDisablePgSSL() {
      return v4.opts.forceDisablePgSSL ?? v4.defaults.forceDisablePgSSL;
    }
    static set forceDisablePgSSL(t2) {
      v4.opts.forceDisablePgSSL = t2;
    }
    get forceDisablePgSSL() {
      return this.opts.forceDisablePgSSL ?? v4.forceDisablePgSSL;
    }
    set forceDisablePgSSL(t2) {
      this.opts.forceDisablePgSSL = t2;
    }
    static get disableSNI() {
      return v4.opts.disableSNI ?? v4.defaults.disableSNI;
    }
    static set disableSNI(t2) {
      v4.opts.disableSNI = t2;
    }
    get disableSNI() {
      return this.opts.disableSNI ?? v4.disableSNI;
    }
    set disableSNI(t2) {
      this.opts.disableSNI = t2;
    }
    static get pipelineConnect() {
      return v4.opts.pipelineConnect ?? v4.defaults.pipelineConnect;
    }
    static set pipelineConnect(t2) {
      v4.opts.pipelineConnect = t2;
    }
    get pipelineConnect() {
      return this.opts.pipelineConnect ?? v4.pipelineConnect;
    }
    set pipelineConnect(t2) {
      this.opts.pipelineConnect = t2;
    }
    static get subtls() {
      return v4.opts.subtls ?? v4.defaults.subtls;
    }
    static set subtls(t2) {
      v4.opts.subtls = t2;
    }
    get subtls() {
      return this.opts.subtls ?? v4.subtls;
    }
    set subtls(t2) {
      this.opts.subtls = t2;
    }
    static get pipelineTLS() {
      return v4.opts.pipelineTLS ?? v4.defaults.pipelineTLS;
    }
    static set pipelineTLS(t2) {
      v4.opts.pipelineTLS = t2;
    }
    get pipelineTLS() {
      return this.opts.pipelineTLS ?? v4.pipelineTLS;
    }
    set pipelineTLS(t2) {
      this.opts.pipelineTLS = t2;
    }
    static get rootCerts() {
      return v4.opts.rootCerts ?? v4.defaults.rootCerts;
    }
    static set rootCerts(t2) {
      v4.opts.rootCerts = t2;
    }
    get rootCerts() {
      return this.opts.rootCerts ?? v4.rootCerts;
    }
    set rootCerts(t2) {
      this.opts.rootCerts = t2;
    }
    wsProxyAddrForHost(t2, n3) {
      let i3 = this.wsProxy;
      if (i3 === void 0)
        throw new Error("No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string");
      return typeof i3 == "function" ? i3(t2, n3) : `${i3}?address=${t2}:${n3}`;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    connect(t2, n3, i3) {
      this.connecting = true, i3 && this.once("connect", i3);
      let s3 = a(() => {
        this.connecting = false, this.pending = false, this.emit("connect"), this.emit("ready");
      }, "handleWebSocketOpen"), o4 = a((c4, h2 = false) => {
        c4.binaryType = "arraybuffer", c4.addEventListener("error", (l3) => {
          this.emit("error", l3), this.emit("close");
        }), c4.addEventListener("message", (l3) => {
          if (this.tlsState === 0) {
            let d3 = y.from(l3.data);
            this.emit(
              "data",
              d3
            );
          }
        }), c4.addEventListener("close", () => {
          this.emit("close");
        }), h2 ? s3() : c4.addEventListener(
          "open",
          s3
        );
      }, "configureWebSocket"), u3;
      try {
        u3 = this.wsProxyAddrForHost(n3, typeof t2 == "string" ? parseInt(t2, 10) : t2);
      } catch (c4) {
        this.emit("error", c4), this.emit("close");
        return;
      }
      try {
        let h2 = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u3;
        if (this.webSocketConstructor !== void 0)
          this.ws = new this.webSocketConstructor(h2), o4(this.ws);
        else
          try {
            this.ws = new WebSocket(
              h2
            ), o4(this.ws);
          } catch {
            this.ws = new __unstable_WebSocket(h2), o4(this.ws);
          }
      } catch (c4) {
        let l3 = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u3;
        fetch(l3, { headers: { Upgrade: "websocket" } }).then((d3) => {
          if (this.ws = d3.webSocket, this.ws == null)
            throw c4;
          this.ws.accept(), o4(
            this.ws,
            true
          );
        }).catch((d3) => {
          this.emit("error", new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websocket--undefined. Details: ${d3.message}`)), this.emit("close");
        });
      }
    }
    async startTls(t2) {
      if (this.subtls === void 0)
        throw new Error("For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information.");
      this.tlsState = 1;
      let n3 = this.subtls.TrustedCert.fromPEM(this.rootCerts), i3 = new this.subtls.WebSocketReadQueue(this.ws), s3 = i3.read.bind(
        i3
      ), o4 = this.rawWrite.bind(this), [u3, c4] = await this.subtls.startTls(t2, n3, s3, o4, { useSNI: !this.disableSNI, expectPreData: this.pipelineTLS ? new Uint8Array([83]) : void 0 });
      this.tlsRead = u3, this.tlsWrite = c4, this.tlsState = 2, this.encrypted = true, this.authorized = true, this.emit(
        "secureConnection",
        this
      ), this.tlsReadLoop();
    }
    async tlsReadLoop() {
      for (; ; ) {
        let t2 = await this.tlsRead();
        if (t2 === void 0)
          break;
        {
          let n3 = y.from(t2);
          this.emit("data", n3);
        }
      }
    }
    rawWrite(t2) {
      if (!this.coalesceWrites) {
        this.ws.send(t2);
        return;
      }
      if (this.writeBuffer === void 0)
        this.writeBuffer = t2, setTimeout(
          () => {
            this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
          },
          0
        );
      else {
        let n3 = new Uint8Array(this.writeBuffer.length + t2.length);
        n3.set(this.writeBuffer), n3.set(t2, this.writeBuffer.length), this.writeBuffer = n3;
      }
    }
    write(t2, n3 = "utf8", i3 = (s3) => {
    }) {
      return t2.length === 0 ? (i3(), true) : (typeof t2 == "string" && (t2 = y.from(t2, n3)), this.tlsState === 0 ? (this.rawWrite(t2), i3()) : this.tlsState === 1 ? this.once("secureConnection", () => {
        this.write(
          t2,
          n3,
          i3
        );
      }) : (this.tlsWrite(t2), i3()), true);
    }
    end(t2 = y.alloc(0), n3 = "utf8", i3 = () => {
    }) {
      return this.write(t2, n3, () => {
        this.ws.close(), i3();
      }), this;
    }
    destroy() {
      return this.destroyed = true, this.end();
    }
  }, "v");
  a(v, "Socket"), _(v, "defaults", {
    poolQueryViaFetch: false,
    fetchEndpoint: a((t2, n3, i3) => {
      let s3;
      return i3?.jwtAuth ? s3 = t2.replace(ys, "apiauth.") : s3 = t2.replace(ys, "api."), "https://" + s3 + "/sql";
    }, "fetchEndpoint"),
    fetchConnectionCache: true,
    fetchFunction: void 0,
    webSocketConstructor: void 0,
    wsProxy: a((t2) => t2 + "/v2", "wsProxy"),
    useSecureWebSocket: true,
    forceDisablePgSSL: true,
    coalesceWrites: true,
    pipelineConnect: "password",
    subtls: void 0,
    rootCerts: "",
    pipelineTLS: false,
    disableSNI: false
  }), _(v, "opts", {});
  Ae = v;
});
var Jr = I((T2) => {
  "use strict";
  p2();
  Object.defineProperty(T2, "__esModule", { value: true });
  T2.NoticeMessage = T2.DataRowMessage = T2.CommandCompleteMessage = T2.ReadyForQueryMessage = T2.NotificationResponseMessage = T2.BackendKeyDataMessage = T2.AuthenticationMD5Password = T2.ParameterStatusMessage = T2.ParameterDescriptionMessage = T2.RowDescriptionMessage = T2.Field = T2.CopyResponse = T2.CopyDataMessage = T2.DatabaseError = T2.copyDone = T2.emptyQuery = T2.replicationStart = T2.portalSuspended = T2.noData = T2.closeComplete = T2.bindComplete = T2.parseComplete = void 0;
  T2.parseComplete = { name: "parseComplete", length: 5 };
  T2.bindComplete = { name: "bindComplete", length: 5 };
  T2.closeComplete = { name: "closeComplete", length: 5 };
  T2.noData = { name: "noData", length: 5 };
  T2.portalSuspended = { name: "portalSuspended", length: 5 };
  T2.replicationStart = { name: "replicationStart", length: 4 };
  T2.emptyQuery = { name: "emptyQuery", length: 4 };
  T2.copyDone = { name: "copyDone", length: 4 };
  var Ur = /* @__PURE__ */ __name(class Ur extends Error {
    constructor(e2, t2, n3) {
      super(
        e2
      ), this.length = t2, this.name = n3;
    }
  }, "Ur");
  a(Ur, "DatabaseError");
  var _r = Ur;
  T2.DatabaseError = _r;
  var Nr = /* @__PURE__ */ __name(class Nr {
    constructor(e2, t2) {
      this.length = e2, this.chunk = t2, this.name = "copyData";
    }
  }, "Nr");
  a(Nr, "CopyDataMessage");
  var Ar = Nr;
  T2.CopyDataMessage = Ar;
  var qr = /* @__PURE__ */ __name(class qr {
    constructor(e2, t2, n3, i3) {
      this.length = e2, this.name = t2, this.binary = n3, this.columnTypes = new Array(i3);
    }
  }, "qr");
  a(qr, "CopyResponse");
  var Cr = qr;
  T2.CopyResponse = Cr;
  var Qr = /* @__PURE__ */ __name(class Qr {
    constructor(e2, t2, n3, i3, s3, o4, u3) {
      this.name = e2, this.tableID = t2, this.columnID = n3, this.dataTypeID = i3, this.dataTypeSize = s3, this.dataTypeModifier = o4, this.format = u3;
    }
  }, "Qr");
  a(Qr, "Field");
  var Tr = Qr;
  T2.Field = Tr;
  var jr = /* @__PURE__ */ __name(class jr {
    constructor(e2, t2) {
      this.length = e2, this.fieldCount = t2, this.name = "rowDescription", this.fields = new Array(
        this.fieldCount
      );
    }
  }, "jr");
  a(jr, "RowDescriptionMessage");
  var Ir = jr;
  T2.RowDescriptionMessage = Ir;
  var Wr = /* @__PURE__ */ __name(class Wr {
    constructor(e2, t2) {
      this.length = e2, this.parameterCount = t2, this.name = "parameterDescription", this.dataTypeIDs = new Array(this.parameterCount);
    }
  }, "Wr");
  a(Wr, "ParameterDescriptionMessage");
  var Pr = Wr;
  T2.ParameterDescriptionMessage = Pr;
  var Hr = /* @__PURE__ */ __name(class Hr {
    constructor(e2, t2, n3) {
      this.length = e2, this.parameterName = t2, this.parameterValue = n3, this.name = "parameterStatus";
    }
  }, "Hr");
  a(Hr, "ParameterStatusMessage");
  var Br = Hr;
  T2.ParameterStatusMessage = Br;
  var Gr = /* @__PURE__ */ __name(class Gr {
    constructor(e2, t2) {
      this.length = e2, this.salt = t2, this.name = "authenticationMD5Password";
    }
  }, "Gr");
  a(Gr, "AuthenticationMD5Password");
  var Lr = Gr;
  T2.AuthenticationMD5Password = Lr;
  var $r = /* @__PURE__ */ __name(class $r {
    constructor(e2, t2, n3) {
      this.length = e2, this.processID = t2, this.secretKey = n3, this.name = "backendKeyData";
    }
  }, "$r");
  a(
    $r,
    "BackendKeyDataMessage"
  );
  var Rr = $r;
  T2.BackendKeyDataMessage = Rr;
  var Vr = /* @__PURE__ */ __name(class Vr {
    constructor(e2, t2, n3, i3) {
      this.length = e2, this.processId = t2, this.channel = n3, this.payload = i3, this.name = "notification";
    }
  }, "Vr");
  a(Vr, "NotificationResponseMessage");
  var Fr = Vr;
  T2.NotificationResponseMessage = Fr;
  var Kr = /* @__PURE__ */ __name(class Kr {
    constructor(e2, t2) {
      this.length = e2, this.status = t2, this.name = "readyForQuery";
    }
  }, "Kr");
  a(Kr, "ReadyForQueryMessage");
  var Mr = Kr;
  T2.ReadyForQueryMessage = Mr;
  var zr = /* @__PURE__ */ __name(class zr {
    constructor(e2, t2) {
      this.length = e2, this.text = t2, this.name = "commandComplete";
    }
  }, "zr");
  a(zr, "CommandCompleteMessage");
  var Dr = zr;
  T2.CommandCompleteMessage = Dr;
  var Yr = /* @__PURE__ */ __name(class Yr {
    constructor(e2, t2) {
      this.length = e2, this.fields = t2, this.name = "dataRow", this.fieldCount = t2.length;
    }
  }, "Yr");
  a(Yr, "DataRowMessage");
  var kr = Yr;
  T2.DataRowMessage = kr;
  var Zr = /* @__PURE__ */ __name(class Zr {
    constructor(e2, t2) {
      this.length = e2, this.message = t2, this.name = "notice";
    }
  }, "Zr");
  a(Zr, "NoticeMessage");
  var Or = Zr;
  T2.NoticeMessage = Or;
});
var ws = I((St) => {
  "use strict";
  p2();
  Object.defineProperty(St, "__esModule", { value: true });
  St.Writer = void 0;
  var en = /* @__PURE__ */ __name(class en {
    constructor(e2 = 256) {
      this.size = e2, this.offset = 5, this.headerPosition = 0, this.buffer = y.allocUnsafe(e2);
    }
    ensure(e2) {
      var t2 = this.buffer.length - this.offset;
      if (t2 < e2) {
        var n3 = this.buffer, i3 = n3.length + (n3.length >> 1) + e2;
        this.buffer = y.allocUnsafe(
          i3
        ), n3.copy(this.buffer);
      }
    }
    addInt32(e2) {
      return this.ensure(4), this.buffer[this.offset++] = e2 >>> 24 & 255, this.buffer[this.offset++] = e2 >>> 16 & 255, this.buffer[this.offset++] = e2 >>> 8 & 255, this.buffer[this.offset++] = e2 >>> 0 & 255, this;
    }
    addInt16(e2) {
      return this.ensure(2), this.buffer[this.offset++] = e2 >>> 8 & 255, this.buffer[this.offset++] = e2 >>> 0 & 255, this;
    }
    addCString(e2) {
      if (!e2)
        this.ensure(1);
      else {
        var t2 = y.byteLength(e2);
        this.ensure(t2 + 1), this.buffer.write(
          e2,
          this.offset,
          "utf-8"
        ), this.offset += t2;
      }
      return this.buffer[this.offset++] = 0, this;
    }
    addString(e2 = "") {
      var t2 = y.byteLength(e2);
      return this.ensure(t2), this.buffer.write(e2, this.offset), this.offset += t2, this;
    }
    add(e2) {
      return this.ensure(e2.length), e2.copy(this.buffer, this.offset), this.offset += e2.length, this;
    }
    join(e2) {
      if (e2) {
        this.buffer[this.headerPosition] = e2;
        let t2 = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(t2, this.headerPosition + 1);
      }
      return this.buffer.slice(e2 ? 0 : 5, this.offset);
    }
    flush(e2) {
      var t2 = this.join(e2);
      return this.offset = 5, this.headerPosition = 0, this.buffer = y.allocUnsafe(this.size), t2;
    }
  }, "en");
  a(en, "Writer");
  var Xr = en;
  St.Writer = Xr;
});
var Ss = I((xt) => {
  "use strict";
  p2();
  Object.defineProperty(xt, "__esModule", { value: true });
  xt.serialize = void 0;
  var tn = ws(), M2 = new tn.Writer(), ku = a((r3) => {
    M2.addInt16(3).addInt16(
      0
    );
    for (let n3 of Object.keys(r3))
      M2.addCString(n3).addCString(r3[n3]);
    M2.addCString("client_encoding").addCString("UTF8");
    var e2 = M2.addCString("").flush(), t2 = e2.length + 4;
    return new tn.Writer().addInt32(t2).add(e2).flush();
  }, "startup"), Ou = a(() => {
    let r3 = y.allocUnsafe(8);
    return r3.writeInt32BE(8, 0), r3.writeInt32BE(80877103, 4), r3;
  }, "requestSsl"), Uu = a((r3) => M2.addCString(r3).flush(112), "password"), Nu = a(function(r3, e2) {
    return M2.addCString(r3).addInt32(
      y.byteLength(e2)
    ).addString(e2), M2.flush(112);
  }, "sendSASLInitialResponseMessage"), qu = a(
    function(r3) {
      return M2.addString(r3).flush(112);
    },
    "sendSCRAMClientFinalMessage"
  ), Qu = a(
    (r3) => M2.addCString(r3).flush(81),
    "query"
  ), bs = [], ju = a((r3) => {
    let e2 = r3.name || "";
    e2.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e2, e2.length), console.error("This can cause conflicts and silent errors executing queries"));
    let t2 = r3.types || bs;
    for (var n3 = t2.length, i3 = M2.addCString(e2).addCString(r3.text).addInt16(n3), s3 = 0; s3 < n3; s3++)
      i3.addInt32(t2[s3]);
    return M2.flush(80);
  }, "parse"), Ne = new tn.Writer(), Wu = a(function(r3, e2) {
    for (let t2 = 0; t2 < r3.length; t2++) {
      let n3 = e2 ? e2(r3[t2], t2) : r3[t2];
      n3 == null ? (M2.addInt16(0), Ne.addInt32(-1)) : n3 instanceof y ? (M2.addInt16(1), Ne.addInt32(n3.length), Ne.add(n3)) : (M2.addInt16(0), Ne.addInt32(y.byteLength(
        n3
      )), Ne.addString(n3));
    }
  }, "writeValues"), Hu = a((r3 = {}) => {
    let e2 = r3.portal || "", t2 = r3.statement || "", n3 = r3.binary || false, i3 = r3.values || bs, s3 = i3.length;
    return M2.addCString(e2).addCString(t2), M2.addInt16(s3), Wu(i3, r3.valueMapper), M2.addInt16(s3), M2.add(Ne.flush()), M2.addInt16(n3 ? 1 : 0), M2.flush(66);
  }, "bind"), Gu = y.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]), $u = a((r3) => {
    if (!r3 || !r3.portal && !r3.rows)
      return Gu;
    let e2 = r3.portal || "", t2 = r3.rows || 0, n3 = y.byteLength(e2), i3 = 4 + n3 + 1 + 4, s3 = y.allocUnsafe(1 + i3);
    return s3[0] = 69, s3.writeInt32BE(i3, 1), s3.write(e2, 5, "utf-8"), s3[n3 + 5] = 0, s3.writeUInt32BE(t2, s3.length - 4), s3;
  }, "execute"), Vu = a((r3, e2) => {
    let t2 = y.allocUnsafe(16);
    return t2.writeInt32BE(16, 0), t2.writeInt16BE(1234, 4), t2.writeInt16BE(5678, 6), t2.writeInt32BE(
      r3,
      8
    ), t2.writeInt32BE(e2, 12), t2;
  }, "cancel"), rn = a(
    (r3, e2) => {
      let n3 = 4 + y.byteLength(e2) + 1, i3 = y.allocUnsafe(1 + n3);
      return i3[0] = r3, i3.writeInt32BE(n3, 1), i3.write(e2, 5, "utf-8"), i3[n3] = 0, i3;
    },
    "cstringMessage"
  ), Ku = M2.addCString("P").flush(68), zu = M2.addCString("S").flush(68), Yu = a((r3) => r3.name ? rn(68, `${r3.type}${r3.name || ""}`) : r3.type === "P" ? Ku : zu, "describe"), Zu = a(
    (r3) => {
      let e2 = `${r3.type}${r3.name || ""}`;
      return rn(67, e2);
    },
    "close"
  ), Ju = a((r3) => M2.add(r3).flush(
    100
  ), "copyData"), Xu = a((r3) => rn(102, r3), "copyFail"), Et = a((r3) => y.from([r3, 0, 0, 0, 4]), "codeOnlyBuffer"), ec = Et(72), tc = Et(83), rc = Et(88), nc = Et(99), ic = {
    startup: ku,
    password: Uu,
    requestSsl: Ou,
    sendSASLInitialResponseMessage: Nu,
    sendSCRAMClientFinalMessage: qu,
    query: Qu,
    parse: ju,
    bind: Hu,
    execute: $u,
    describe: Yu,
    close: Zu,
    flush: a(() => ec, "flush"),
    sync: a(
      () => tc,
      "sync"
    ),
    end: a(() => rc, "end"),
    copyData: Ju,
    copyDone: a(() => nc, "copyDone"),
    copyFail: Xu,
    cancel: Vu
  };
  xt.serialize = ic;
});
var Es = I((vt) => {
  "use strict";
  p2();
  Object.defineProperty(vt, "__esModule", { value: true });
  vt.BufferReader = void 0;
  var sc = y.allocUnsafe(0), sn = /* @__PURE__ */ __name(class sn {
    constructor(e2 = 0) {
      this.offset = e2, this.buffer = sc, this.encoding = "utf-8";
    }
    setBuffer(e2, t2) {
      this.offset = e2, this.buffer = t2;
    }
    int16() {
      let e2 = this.buffer.readInt16BE(this.offset);
      return this.offset += 2, e2;
    }
    byte() {
      let e2 = this.buffer[this.offset];
      return this.offset++, e2;
    }
    int32() {
      let e2 = this.buffer.readInt32BE(this.offset);
      return this.offset += 4, e2;
    }
    string(e2) {
      let t2 = this.buffer.toString(this.encoding, this.offset, this.offset + e2);
      return this.offset += e2, t2;
    }
    cstring() {
      let e2 = this.offset, t2 = e2;
      for (; this.buffer[t2++] !== 0; )
        ;
      return this.offset = t2, this.buffer.toString(this.encoding, e2, t2 - 1);
    }
    bytes(e2) {
      let t2 = this.buffer.slice(this.offset, this.offset + e2);
      return this.offset += e2, t2;
    }
  }, "sn");
  a(sn, "BufferReader");
  var nn = sn;
  vt.BufferReader = nn;
});
var _s = I((_t) => {
  "use strict";
  p2();
  Object.defineProperty(_t, "__esModule", { value: true });
  _t.Parser = void 0;
  var D = Jr(), oc = Es(), on3 = 1, ac = 4, xs = on3 + ac, vs = y.allocUnsafe(0), un = /* @__PURE__ */ __name(class un {
    constructor(e2) {
      if (this.buffer = vs, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new oc.BufferReader(), e2?.mode === "binary")
        throw new Error("Binary mode not supported yet");
      this.mode = e2?.mode || "text";
    }
    parse(e2, t2) {
      this.mergeBuffer(e2);
      let n3 = this.bufferOffset + this.bufferLength, i3 = this.bufferOffset;
      for (; i3 + xs <= n3; ) {
        let s3 = this.buffer[i3], o4 = this.buffer.readUInt32BE(
          i3 + on3
        ), u3 = on3 + o4;
        if (u3 + i3 <= n3) {
          let c4 = this.handlePacket(i3 + xs, s3, o4, this.buffer);
          t2(c4), i3 += u3;
        } else
          break;
      }
      i3 === n3 ? (this.buffer = vs, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n3 - i3, this.bufferOffset = i3);
    }
    mergeBuffer(e2) {
      if (this.bufferLength > 0) {
        let t2 = this.bufferLength + e2.byteLength;
        if (t2 + this.bufferOffset > this.buffer.byteLength) {
          let i3;
          if (t2 <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength)
            i3 = this.buffer;
          else {
            let s3 = this.buffer.byteLength * 2;
            for (; t2 >= s3; )
              s3 *= 2;
            i3 = y.allocUnsafe(s3);
          }
          this.buffer.copy(
            i3,
            0,
            this.bufferOffset,
            this.bufferOffset + this.bufferLength
          ), this.buffer = i3, this.bufferOffset = 0;
        }
        e2.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t2;
      } else
        this.buffer = e2, this.bufferOffset = 0, this.bufferLength = e2.byteLength;
    }
    handlePacket(e2, t2, n3, i3) {
      switch (t2) {
        case 50:
          return D.bindComplete;
        case 49:
          return D.parseComplete;
        case 51:
          return D.closeComplete;
        case 110:
          return D.noData;
        case 115:
          return D.portalSuspended;
        case 99:
          return D.copyDone;
        case 87:
          return D.replicationStart;
        case 73:
          return D.emptyQuery;
        case 68:
          return this.parseDataRowMessage(
            e2,
            n3,
            i3
          );
        case 67:
          return this.parseCommandCompleteMessage(e2, n3, i3);
        case 90:
          return this.parseReadyForQueryMessage(e2, n3, i3);
        case 65:
          return this.parseNotificationMessage(
            e2,
            n3,
            i3
          );
        case 82:
          return this.parseAuthenticationResponse(e2, n3, i3);
        case 83:
          return this.parseParameterStatusMessage(e2, n3, i3);
        case 75:
          return this.parseBackendKeyData(e2, n3, i3);
        case 69:
          return this.parseErrorMessage(e2, n3, i3, "error");
        case 78:
          return this.parseErrorMessage(
            e2,
            n3,
            i3,
            "notice"
          );
        case 84:
          return this.parseRowDescriptionMessage(e2, n3, i3);
        case 116:
          return this.parseParameterDescriptionMessage(e2, n3, i3);
        case 71:
          return this.parseCopyInMessage(
            e2,
            n3,
            i3
          );
        case 72:
          return this.parseCopyOutMessage(e2, n3, i3);
        case 100:
          return this.parseCopyData(
            e2,
            n3,
            i3
          );
        default:
          return new D.DatabaseError("received invalid response: " + t2.toString(
            16
          ), n3, "error");
      }
    }
    parseReadyForQueryMessage(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.string(1);
      return new D.ReadyForQueryMessage(t2, i3);
    }
    parseCommandCompleteMessage(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.cstring();
      return new D.CommandCompleteMessage(
        t2,
        i3
      );
    }
    parseCopyData(e2, t2, n3) {
      let i3 = n3.slice(e2, e2 + (t2 - 4));
      return new D.CopyDataMessage(
        t2,
        i3
      );
    }
    parseCopyInMessage(e2, t2, n3) {
      return this.parseCopyMessage(e2, t2, n3, "copyInResponse");
    }
    parseCopyOutMessage(e2, t2, n3) {
      return this.parseCopyMessage(e2, t2, n3, "copyOutResponse");
    }
    parseCopyMessage(e2, t2, n3, i3) {
      this.reader.setBuffer(e2, n3);
      let s3 = this.reader.byte() !== 0, o4 = this.reader.int16(), u3 = new D.CopyResponse(t2, i3, s3, o4);
      for (let c4 = 0; c4 < o4; c4++)
        u3.columnTypes[c4] = this.reader.int16();
      return u3;
    }
    parseNotificationMessage(e2, t2, n3) {
      this.reader.setBuffer(
        e2,
        n3
      );
      let i3 = this.reader.int32(), s3 = this.reader.cstring(), o4 = this.reader.cstring();
      return new D.NotificationResponseMessage(t2, i3, s3, o4);
    }
    parseRowDescriptionMessage(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.int16(), s3 = new D.RowDescriptionMessage(t2, i3);
      for (let o4 = 0; o4 < i3; o4++)
        s3.fields[o4] = this.parseField();
      return s3;
    }
    parseField() {
      let e2 = this.reader.cstring(), t2 = this.reader.int32(), n3 = this.reader.int16(), i3 = this.reader.int32(), s3 = this.reader.int16(), o4 = this.reader.int32(), u3 = this.reader.int16() === 0 ? "text" : "binary";
      return new D.Field(e2, t2, n3, i3, s3, o4, u3);
    }
    parseParameterDescriptionMessage(e2, t2, n3) {
      this.reader.setBuffer(
        e2,
        n3
      );
      let i3 = this.reader.int16(), s3 = new D.ParameterDescriptionMessage(t2, i3);
      for (let o4 = 0; o4 < i3; o4++)
        s3.dataTypeIDs[o4] = this.reader.int32();
      return s3;
    }
    parseDataRowMessage(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.int16(), s3 = new Array(i3);
      for (let o4 = 0; o4 < i3; o4++) {
        let u3 = this.reader.int32();
        s3[o4] = u3 === -1 ? null : this.reader.string(u3);
      }
      return new D.DataRowMessage(
        t2,
        s3
      );
    }
    parseParameterStatusMessage(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.cstring(), s3 = this.reader.cstring();
      return new D.ParameterStatusMessage(t2, i3, s3);
    }
    parseBackendKeyData(e2, t2, n3) {
      this.reader.setBuffer(e2, n3);
      let i3 = this.reader.int32(), s3 = this.reader.int32();
      return new D.BackendKeyDataMessage(t2, i3, s3);
    }
    parseAuthenticationResponse(e2, t2, n3) {
      this.reader.setBuffer(
        e2,
        n3
      );
      let i3 = this.reader.int32(), s3 = { name: "authenticationOk", length: t2 };
      switch (i3) {
        case 0:
          break;
        case 3:
          s3.length === 8 && (s3.name = "authenticationCleartextPassword");
          break;
        case 5:
          if (s3.length === 12) {
            s3.name = "authenticationMD5Password";
            let u3 = this.reader.bytes(4);
            return new D.AuthenticationMD5Password(t2, u3);
          }
          break;
        case 10:
          s3.name = "authenticationSASL", s3.mechanisms = [];
          let o4;
          do
            o4 = this.reader.cstring(), o4 && s3.mechanisms.push(o4);
          while (o4);
          break;
        case 11:
          s3.name = "authenticationSASLContinue", s3.data = this.reader.string(t2 - 8);
          break;
        case 12:
          s3.name = "authenticationSASLFinal", s3.data = this.reader.string(t2 - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + i3);
      }
      return s3;
    }
    parseErrorMessage(e2, t2, n3, i3) {
      this.reader.setBuffer(e2, n3);
      let s3 = {}, o4 = this.reader.string(1);
      for (; o4 !== "\0"; )
        s3[o4] = this.reader.cstring(), o4 = this.reader.string(1);
      let u3 = s3.M, c4 = i3 === "notice" ? new D.NoticeMessage(
        t2,
        u3
      ) : new D.DatabaseError(u3, t2, i3);
      return c4.severity = s3.S, c4.code = s3.C, c4.detail = s3.D, c4.hint = s3.H, c4.position = s3.P, c4.internalPosition = s3.p, c4.internalQuery = s3.q, c4.where = s3.W, c4.schema = s3.s, c4.table = s3.t, c4.column = s3.c, c4.dataType = s3.d, c4.constraint = s3.n, c4.file = s3.F, c4.line = s3.L, c4.routine = s3.R, c4;
    }
  }, "un");
  a(un, "Parser");
  var an = un;
  _t.Parser = an;
});
var cn = I((Se) => {
  "use strict";
  p2();
  Object.defineProperty(Se, "__esModule", { value: true });
  Se.DatabaseError = Se.serialize = Se.parse = void 0;
  var uc = Jr();
  Object.defineProperty(
    Se,
    "DatabaseError",
    { enumerable: true, get: a(function() {
      return uc.DatabaseError;
    }, "get") }
  );
  var cc = Ss();
  Object.defineProperty(Se, "serialize", { enumerable: true, get: a(function() {
    return cc.serialize;
  }, "get") });
  var hc = _s();
  function lc(r3, e2) {
    let t2 = new hc.Parser();
    return r3.on("data", (n3) => t2.parse(n3, e2)), new Promise((n3) => r3.on("end", () => n3()));
  }
  __name(lc, "lc");
  a(lc, "parse");
  Se.parse = lc;
});
var As = {};
ie(As, { connect: () => fc });
function fc({ socket: r3, servername: e2 }) {
  return r3.startTls(e2), r3;
}
__name(fc, "fc");
var Cs = z2(() => {
  "use strict";
  p2();
  a(fc, "connect");
});
var fn2 = I((nf, Ps) => {
  "use strict";
  p2();
  var Ts = (bt(), N(gs)), pc = we().EventEmitter, {
    parse: dc,
    serialize: Q
  } = cn(), Is = Q.flush(), yc = Q.sync(), mc = Q.end(), ln = /* @__PURE__ */ __name(class ln extends pc {
    constructor(e2) {
      super(), e2 = e2 || {}, this.stream = e2.stream || new Ts.Socket(), this._keepAlive = e2.keepAlive, this._keepAliveInitialDelayMillis = e2.keepAliveInitialDelayMillis, this.lastBuffer = false, this.parsedStatements = {}, this.ssl = e2.ssl || false, this._ending = false, this._emitMessage = false;
      var t2 = this;
      this.on("newListener", function(n3) {
        n3 === "message" && (t2._emitMessage = true);
      });
    }
    connect(e2, t2) {
      var n3 = this;
      this._connecting = true, this.stream.setNoDelay(true), this.stream.connect(
        e2,
        t2
      ), this.stream.once("connect", function() {
        n3._keepAlive && n3.stream.setKeepAlive(
          true,
          n3._keepAliveInitialDelayMillis
        ), n3.emit("connect");
      });
      let i3 = a(function(s3) {
        n3._ending && (s3.code === "ECONNRESET" || s3.code === "EPIPE") || n3.emit("error", s3);
      }, "reportStreamError");
      if (this.stream.on("error", i3), this.stream.on("close", function() {
        n3.emit("end");
      }), !this.ssl)
        return this.attachListeners(this.stream);
      this.stream.once("data", function(s3) {
        var o4 = s3.toString("utf8");
        switch (o4) {
          case "S":
            break;
          case "N":
            return n3.stream.end(), n3.emit("error", new Error("The server does not support SSL connections"));
          default:
            return n3.stream.end(), n3.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        var u3 = (Cs(), N(As));
        let c4 = { socket: n3.stream };
        n3.ssl !== true && (Object.assign(
          c4,
          n3.ssl
        ), "key" in n3.ssl && (c4.key = n3.ssl.key)), Ts.isIP(t2) === 0 && (c4.servername = t2);
        try {
          n3.stream = u3.connect(c4);
        } catch (h2) {
          return n3.emit("error", h2);
        }
        n3.attachListeners(n3.stream), n3.stream.on("error", i3), n3.emit("sslconnect");
      });
    }
    attachListeners(e2) {
      e2.on("end", () => {
        this.emit("end");
      }), dc(e2, (t2) => {
        var n3 = t2.name === "error" ? "errorMessage" : t2.name;
        this._emitMessage && this.emit("message", t2), this.emit(n3, t2);
      });
    }
    requestSsl() {
      this.stream.write(Q.requestSsl());
    }
    startup(e2) {
      this.stream.write(Q.startup(e2));
    }
    cancel(e2, t2) {
      this._send(Q.cancel(e2, t2));
    }
    password(e2) {
      this._send(Q.password(e2));
    }
    sendSASLInitialResponseMessage(e2, t2) {
      this._send(Q.sendSASLInitialResponseMessage(
        e2,
        t2
      ));
    }
    sendSCRAMClientFinalMessage(e2) {
      this._send(Q.sendSCRAMClientFinalMessage(e2));
    }
    _send(e2) {
      return this.stream.writable ? this.stream.write(e2) : false;
    }
    query(e2) {
      this._send(Q.query(
        e2
      ));
    }
    parse(e2) {
      this._send(Q.parse(e2));
    }
    bind(e2) {
      this._send(Q.bind(e2));
    }
    execute(e2) {
      this._send(Q.execute(e2));
    }
    flush() {
      this.stream.writable && this.stream.write(Is);
    }
    sync() {
      this._ending = true, this._send(Is), this._send(yc);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      if (this._ending = true, !this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(mc, () => {
        this.stream.end();
      });
    }
    close(e2) {
      this._send(Q.close(e2));
    }
    describe(e2) {
      this._send(Q.describe(e2));
    }
    sendCopyFromChunk(e2) {
      this._send(Q.copyData(e2));
    }
    endCopyFrom() {
      this._send(Q.copyDone());
    }
    sendCopyFail(e2) {
      this._send(Q.copyFail(e2));
    }
  }, "ln");
  a(ln, "Connection");
  var hn = ln;
  Ps.exports = hn;
});
var Rs = I((uf, Ls) => {
  "use strict";
  p2();
  var gc = we().EventEmitter, af = (Ge(), N(He)), wc = tt(), pn = Qi(), bc = Ji(), Sc = gt2(), Ec = wt(), Bs = ds(), xc = et(), vc = fn2(), dn = /* @__PURE__ */ __name(class dn extends gc {
    constructor(e2) {
      super(), this.connectionParameters = new Ec(e2), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(this, "password", { configurable: true, enumerable: false, writable: true, value: this.connectionParameters.password }), this.replication = this.connectionParameters.replication;
      var t2 = e2 || {};
      this._Promise = t2.Promise || S.Promise, this._types = new Sc(t2.types), this._ending = false, this._connecting = false, this._connected = false, this._connectionError = false, this._queryable = true, this.connection = t2.connection || new vc({ stream: t2.stream, ssl: this.connectionParameters.ssl, keepAlive: t2.keepAlive || false, keepAliveInitialDelayMillis: t2.keepAliveInitialDelayMillis || 0, encoding: this.connectionParameters.client_encoding || "utf8" }), this.queryQueue = [], this.binary = t2.binary || xc.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || false, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this._connectionTimeoutMillis = t2.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(e2) {
      let t2 = a(
        (n3) => {
          m2.nextTick(() => {
            n3.handleError(e2, this.connection);
          });
        },
        "enqueueError"
      );
      this.activeQuery && (t2(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t2), this.queryQueue.length = 0;
    }
    _connect(e2) {
      var t2 = this, n3 = this.connection;
      if (this._connectionCallback = e2, this._connecting || this._connected) {
        let i3 = new Error("Client has already been connected. You cannot reuse a client.");
        m2.nextTick(() => {
          e2(i3);
        });
        return;
      }
      this._connecting = true, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(() => {
        n3._ending = true, n3.stream.destroy(new Error("timeout expired"));
      }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n3.connect(this.host + "/.s.PGSQL." + this.port) : n3.connect(this.port, this.host), n3.on("connect", function() {
        t2.ssl ? n3.requestSsl() : n3.startup(t2.getStartupConf());
      }), n3.on("sslconnect", function() {
        n3.startup(t2.getStartupConf());
      }), this._attachListeners(n3), n3.once("end", () => {
        let i3 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i3), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i3) : this._handleErrorEvent(i3) : this._connectionError || this._handleErrorEvent(
          i3
        )), m2.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(e2) {
      if (e2) {
        this._connect(e2);
        return;
      }
      return new this._Promise((t2, n3) => {
        this._connect((i3) => {
          i3 ? n3(i3) : t2();
        });
      });
    }
    _attachListeners(e2) {
      e2.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e2.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e2.on("authenticationSASL", this._handleAuthSASL.bind(this)), e2.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e2.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e2.on("backendKeyData", this._handleBackendKeyData.bind(this)), e2.on("error", this._handleErrorEvent.bind(this)), e2.on(
        "errorMessage",
        this._handleErrorMessage.bind(this)
      ), e2.on("readyForQuery", this._handleReadyForQuery.bind(this)), e2.on("notice", this._handleNotice.bind(this)), e2.on("rowDescription", this._handleRowDescription.bind(this)), e2.on("dataRow", this._handleDataRow.bind(this)), e2.on("portalSuspended", this._handlePortalSuspended.bind(this)), e2.on(
        "emptyQuery",
        this._handleEmptyQuery.bind(this)
      ), e2.on("commandComplete", this._handleCommandComplete.bind(this)), e2.on("parseComplete", this._handleParseComplete.bind(this)), e2.on("copyInResponse", this._handleCopyInResponse.bind(this)), e2.on("copyData", this._handleCopyData.bind(this)), e2.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(e2) {
      let t2 = this.connection;
      typeof this.password == "function" ? this._Promise.resolve().then(
        () => this.password()
      ).then((n3) => {
        if (n3 !== void 0) {
          if (typeof n3 != "string") {
            t2.emit("error", new TypeError("Password must be a string"));
            return;
          }
          this.connectionParameters.password = this.password = n3;
        } else
          this.connectionParameters.password = this.password = null;
        e2();
      }).catch((n3) => {
        t2.emit("error", n3);
      }) : this.password !== null ? e2() : bc(
        this.connectionParameters,
        (n3) => {
          n3 !== void 0 && (this.connectionParameters.password = this.password = n3), e2();
        }
      );
    }
    _handleAuthCleartextPassword(e2) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(e2) {
      this._checkPgPass(() => {
        let t2 = wc.postgresMd5PasswordHash(
          this.user,
          this.password,
          e2.salt
        );
        this.connection.password(t2);
      });
    }
    _handleAuthSASL(e2) {
      this._checkPgPass(() => {
        this.saslSession = pn.startSession(e2.mechanisms), this.connection.sendSASLInitialResponseMessage(
          this.saslSession.mechanism,
          this.saslSession.response
        );
      });
    }
    _handleAuthSASLContinue(e2) {
      pn.continueSession(this.saslSession, this.password, e2.data), this.connection.sendSCRAMClientFinalMessage(
        this.saslSession.response
      );
    }
    _handleAuthSASLFinal(e2) {
      pn.finalizeSession(
        this.saslSession,
        e2.data
      ), this.saslSession = null;
    }
    _handleBackendKeyData(e2) {
      this.processID = e2.processID, this.secretKey = e2.secretKey;
    }
    _handleReadyForQuery(e2) {
      this._connecting && (this._connecting = false, this._connected = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
      let { activeQuery: t2 } = this;
      this.activeQuery = null, this.readyForQuery = true, t2 && t2.handleReadyForQuery(this.connection), this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(e2) {
      if (!this._connectionError) {
        if (this._connectionError = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback)
          return this._connectionCallback(e2);
        this.emit("error", e2);
      }
    }
    _handleErrorEvent(e2) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e2);
      this._queryable = false, this._errorAllQueries(e2), this.emit("error", e2);
    }
    _handleErrorMessage(e2) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e2);
      let t2 = this.activeQuery;
      if (!t2) {
        this._handleErrorEvent(
          e2
        );
        return;
      }
      this.activeQuery = null, t2.handleError(e2, this.connection);
    }
    _handleRowDescription(e2) {
      this.activeQuery.handleRowDescription(e2);
    }
    _handleDataRow(e2) {
      this.activeQuery.handleDataRow(
        e2
      );
    }
    _handlePortalSuspended(e2) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(e2) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(e2) {
      this.activeQuery.handleCommandComplete(e2, this.connection);
    }
    _handleParseComplete(e2) {
      this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
    }
    _handleCopyInResponse(e2) {
      this.activeQuery.handleCopyInResponse(
        this.connection
      );
    }
    _handleCopyData(e2) {
      this.activeQuery.handleCopyData(e2, this.connection);
    }
    _handleNotification(e2) {
      this.emit("notification", e2);
    }
    _handleNotice(e2) {
      this.emit("notice", e2);
    }
    getStartupConf() {
      var e2 = this.connectionParameters, t2 = { user: e2.user, database: e2.database }, n3 = e2.application_name || e2.fallback_application_name;
      return n3 && (t2.application_name = n3), e2.replication && (t2.replication = "" + e2.replication), e2.statement_timeout && (t2.statement_timeout = String(parseInt(
        e2.statement_timeout,
        10
      ))), e2.lock_timeout && (t2.lock_timeout = String(parseInt(e2.lock_timeout, 10))), e2.idle_in_transaction_session_timeout && (t2.idle_in_transaction_session_timeout = String(parseInt(
        e2.idle_in_transaction_session_timeout,
        10
      ))), e2.options && (t2.options = e2.options), t2;
    }
    cancel(e2, t2) {
      if (e2.activeQuery === t2) {
        var n3 = this.connection;
        this.host && this.host.indexOf("/") === 0 ? n3.connect(this.host + "/.s.PGSQL." + this.port) : n3.connect(this.port, this.host), n3.on("connect", function() {
          n3.cancel(
            e2.processID,
            e2.secretKey
          );
        });
      } else
        e2.queryQueue.indexOf(t2) !== -1 && e2.queryQueue.splice(e2.queryQueue.indexOf(t2), 1);
    }
    setTypeParser(e2, t2, n3) {
      return this._types.setTypeParser(e2, t2, n3);
    }
    getTypeParser(e2, t2) {
      return this._types.getTypeParser(e2, t2);
    }
    escapeIdentifier(e2) {
      return '"' + e2.replace(
        /"/g,
        '""'
      ) + '"';
    }
    escapeLiteral(e2) {
      for (var t2 = false, n3 = "'", i3 = 0; i3 < e2.length; i3++) {
        var s3 = e2[i3];
        s3 === "'" ? n3 += s3 + s3 : s3 === "\\" ? (n3 += s3 + s3, t2 = true) : n3 += s3;
      }
      return n3 += "'", t2 === true && (n3 = " E" + n3), n3;
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true)
        if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
          this.readyForQuery = false, this.hasExecuted = true;
          let e2 = this.activeQuery.submit(this.connection);
          e2 && m2.nextTick(() => {
            this.activeQuery.handleError(e2, this.connection), this.readyForQuery = true, this._pulseQueryQueue();
          });
        } else
          this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
    }
    query(e2, t2, n3) {
      var i3, s3, o4, u3, c4;
      if (e2 == null)
        throw new TypeError("Client was passed a null or undefined query");
      return typeof e2.submit == "function" ? (o4 = e2.query_timeout || this.connectionParameters.query_timeout, s3 = i3 = e2, typeof t2 == "function" && (i3.callback = i3.callback || t2)) : (o4 = this.connectionParameters.query_timeout, i3 = new Bs(
        e2,
        t2,
        n3
      ), i3.callback || (s3 = new this._Promise((h2, l3) => {
        i3.callback = (d3, b3) => d3 ? l3(d3) : h2(b3);
      }))), o4 && (c4 = i3.callback, u3 = setTimeout(() => {
        var h2 = new Error("Query read timeout");
        m2.nextTick(
          () => {
            i3.handleError(h2, this.connection);
          }
        ), c4(h2), i3.callback = () => {
        };
        var l3 = this.queryQueue.indexOf(i3);
        l3 > -1 && this.queryQueue.splice(l3, 1), this._pulseQueryQueue();
      }, o4), i3.callback = (h2, l3) => {
        clearTimeout(u3), c4(h2, l3);
      }), this.binary && !i3.binary && (i3.binary = true), i3._result && !i3._result._types && (i3._result._types = this._types), this._queryable ? this._ending ? (m2.nextTick(() => {
        i3.handleError(
          new Error("Client was closed and is not queryable"),
          this.connection
        );
      }), s3) : (this.queryQueue.push(i3), this._pulseQueryQueue(), s3) : (m2.nextTick(
        () => {
          i3.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        }
      ), s3);
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(e2) {
      if (this._ending = true, !this.connection._connecting)
        if (e2)
          e2();
        else
          return this._Promise.resolve();
      if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e2)
        this.connection.once("end", e2);
      else
        return new this._Promise((t2) => {
          this.connection.once("end", t2);
        });
    }
  }, "dn");
  a(dn, "Client");
  var At = dn;
  At.Query = Bs;
  Ls.exports = At;
});
var ks = I((lf, Ds) => {
  "use strict";
  p2();
  var _c = we().EventEmitter, Fs = a(function() {
  }, "NOOP"), Ms = a(
    (r3, e2) => {
      let t2 = r3.findIndex(e2);
      return t2 === -1 ? void 0 : r3.splice(t2, 1)[0];
    },
    "removeWhere"
  ), gn = /* @__PURE__ */ __name(class gn {
    constructor(e2, t2, n3) {
      this.client = e2, this.idleListener = t2, this.timeoutId = n3;
    }
  }, "gn");
  a(gn, "IdleItem");
  var yn = gn, wn = /* @__PURE__ */ __name(class wn {
    constructor(e2) {
      this.callback = e2;
    }
  }, "wn");
  a(wn, "PendingItem");
  var qe = wn;
  function Ac() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  __name(Ac, "Ac");
  a(Ac, "throwOnDoubleRelease");
  function Ct(r3, e2) {
    if (e2)
      return { callback: e2, result: void 0 };
    let t2, n3, i3 = a(function(o4, u3) {
      o4 ? t2(o4) : n3(u3);
    }, "cb"), s3 = new r3(function(o4, u3) {
      n3 = o4, t2 = u3;
    }).catch((o4) => {
      throw Error.captureStackTrace(
        o4
      ), o4;
    });
    return { callback: i3, result: s3 };
  }
  __name(Ct, "Ct");
  a(Ct, "promisify");
  function Cc(r3, e2) {
    return a(
      /* @__PURE__ */ __name(function t2(n3) {
        n3.client = e2, e2.removeListener("error", t2), e2.on("error", () => {
          r3.log("additional client error after disconnection due to error", n3);
        }), r3._remove(e2), r3.emit("error", n3, e2);
      }, "t"),
      "idleListener"
    );
  }
  __name(Cc, "Cc");
  a(Cc, "makeIdleListener");
  var bn = /* @__PURE__ */ __name(class bn extends _c {
    constructor(e2, t2) {
      super(), this.options = Object.assign({}, e2), e2 != null && "password" in e2 && Object.defineProperty(
        this.options,
        "password",
        { configurable: true, enumerable: false, writable: true, value: e2.password }
      ), e2 != null && e2.ssl && e2.ssl.key && Object.defineProperty(this.options.ssl, "key", { enumerable: false }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || false, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {
      }, this.Client = this.options.Client || t2 || Tt().Client, this.Promise = this.options.Promise || S.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = /* @__PURE__ */ new WeakSet(), this._pendingQueue = [], this._endCallback = void 0, this.ending = false, this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      if (this.log("pulse queue"), this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log(
          "pulse queue on ending"
        ), this._idle.length && this._idle.slice().map((t2) => {
          this._remove(
            t2.client
          );
        }), this._clients.length || (this.ended = true, this._endCallback());
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull())
        return;
      let e2 = this._pendingQueue.shift();
      if (this._idle.length) {
        let t2 = this._idle.pop();
        clearTimeout(t2.timeoutId);
        let n3 = t2.client;
        n3.ref && n3.ref();
        let i3 = t2.idleListener;
        return this._acquireClient(n3, e2, i3, false);
      }
      if (!this._isFull())
        return this.newClient(e2);
      throw new Error("unexpected condition");
    }
    _remove(e2) {
      let t2 = Ms(this._idle, (n3) => n3.client === e2);
      t2 !== void 0 && clearTimeout(t2.timeoutId), this._clients = this._clients.filter((n3) => n3 !== e2), e2.end(), this.emit("remove", e2);
    }
    connect(e2) {
      if (this.ending) {
        let i3 = new Error("Cannot use a pool after calling end on the pool");
        return e2 ? e2(i3) : this.Promise.reject(
          i3
        );
      }
      let t2 = Ct(this.Promise, e2), n3 = t2.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length && m2.nextTick(() => this._pulseQueue()), !this.options.connectionTimeoutMillis)
          return this._pendingQueue.push(new qe(t2.callback)), n3;
        let i3 = a((u3, c4, h2) => {
          clearTimeout(
            o4
          ), t2.callback(u3, c4, h2);
        }, "queueCallback"), s3 = new qe(i3), o4 = setTimeout(() => {
          Ms(
            this._pendingQueue,
            (u3) => u3.callback === i3
          ), s3.timedOut = true, t2.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        return this._pendingQueue.push(s3), n3;
      }
      return this.newClient(new qe(t2.callback)), n3;
    }
    newClient(e2) {
      let t2 = new this.Client(this.options);
      this._clients.push(t2);
      let n3 = Cc(this, t2);
      this.log("checking client timeout");
      let i3, s3 = false;
      this.options.connectionTimeoutMillis && (i3 = setTimeout(() => {
        this.log("ending client due to timeout"), s3 = true, t2.connection ? t2.connection.stream.destroy() : t2.end();
      }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t2.connect((o4) => {
        if (i3 && clearTimeout(i3), t2.on("error", n3), o4)
          this.log("client failed to connect", o4), this._clients = this._clients.filter((u3) => u3 !== t2), s3 && (o4.message = "Connection terminated due to connection timeout"), this._pulseQueue(), e2.timedOut || e2.callback(
            o4,
            void 0,
            Fs
          );
        else {
          if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
            let u3 = setTimeout(() => {
              this.log("ending client due to expired lifetime"), this._expired.add(t2), this._idle.findIndex((h2) => h2.client === t2) !== -1 && this._acquireClient(
                t2,
                new qe((h2, l3, d3) => d3()),
                n3,
                false
              );
            }, this.options.maxLifetimeSeconds * 1e3);
            u3.unref(), t2.once(
              "end",
              () => clearTimeout(u3)
            );
          }
          return this._acquireClient(t2, e2, n3, true);
        }
      });
    }
    _acquireClient(e2, t2, n3, i3) {
      i3 && this.emit("connect", e2), this.emit("acquire", e2), e2.release = this._releaseOnce(e2, n3), e2.removeListener("error", n3), t2.timedOut ? i3 && this.options.verify ? this.options.verify(
        e2,
        e2.release
      ) : e2.release() : i3 && this.options.verify ? this.options.verify(e2, (s3) => {
        if (s3)
          return e2.release(s3), t2.callback(s3, void 0, Fs);
        t2.callback(void 0, e2, e2.release);
      }) : t2.callback(
        void 0,
        e2,
        e2.release
      );
    }
    _releaseOnce(e2, t2) {
      let n3 = false;
      return (i3) => {
        n3 && Ac(), n3 = true, this._release(
          e2,
          t2,
          i3
        );
      };
    }
    _release(e2, t2, n3) {
      if (e2.on("error", t2), e2._poolUseCount = (e2._poolUseCount || 0) + 1, this.emit("release", n3, e2), n3 || this.ending || !e2._queryable || e2._ending || e2._poolUseCount >= this.options.maxUses) {
        e2._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e2), this._pulseQueue();
        return;
      }
      if (this._expired.has(e2)) {
        this.log("remove expired client"), this._expired.delete(e2), this._remove(e2), this._pulseQueue();
        return;
      }
      let s3;
      this.options.idleTimeoutMillis && (s3 = setTimeout(() => {
        this.log("remove idle client"), this._remove(e2);
      }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s3.unref()), this.options.allowExitOnIdle && e2.unref(), this._idle.push(new yn(e2, t2, s3)), this._pulseQueue();
    }
    query(e2, t2, n3) {
      if (typeof e2 == "function") {
        let s3 = Ct(this.Promise, e2);
        return E(function() {
          return s3.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        }), s3.result;
      }
      typeof t2 == "function" && (n3 = t2, t2 = void 0);
      let i3 = Ct(this.Promise, n3);
      return n3 = i3.callback, this.connect((s3, o4) => {
        if (s3)
          return n3(s3);
        let u3 = false, c4 = a((h2) => {
          u3 || (u3 = true, o4.release(h2), n3(h2));
        }, "onError");
        o4.once("error", c4), this.log("dispatching query");
        try {
          o4.query(e2, t2, (h2, l3) => {
            if (this.log("query dispatched"), o4.removeListener("error", c4), !u3)
              return u3 = true, o4.release(h2), h2 ? n3(h2) : n3(
                void 0,
                l3
              );
          });
        } catch (h2) {
          return o4.release(h2), n3(h2);
        }
      }), i3.result;
    }
    end(e2) {
      if (this.log("ending"), this.ending) {
        let n3 = new Error("Called end on pool more than once");
        return e2 ? e2(n3) : this.Promise.reject(n3);
      }
      this.ending = true;
      let t2 = Ct(this.Promise, e2);
      return this._endCallback = t2.callback, this._pulseQueue(), t2.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((e2, t2) => e2 + (this._expired.has(t2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }, "bn");
  a(bn, "Pool");
  var mn = bn;
  Ds.exports = mn;
});
var Os = {};
ie(Os, { default: () => Tc });
var Tc;
var Us = z2(() => {
  "use strict";
  p2();
  Tc = {};
});
var Ns = I((yf, Ic) => {
  Ic.exports = { name: "pg", version: "8.8.0", description: "PostgreSQL client - pure javascript & libpq with the same API", keywords: [
    "database",
    "libpq",
    "pg",
    "postgre",
    "postgres",
    "postgresql",
    "rdbms"
  ], homepage: "https://github.com/brianc/node-postgres", repository: { type: "git", url: "git://github.com/brianc/node-postgres.git", directory: "packages/pg" }, author: "Brian Carlson <brian.m.carlson@gmail.com>", main: "./lib", dependencies: {
    "buffer-writer": "2.0.0",
    "packet-reader": "1.0.0",
    "pg-connection-string": "^2.5.0",
    "pg-pool": "^3.5.2",
    "pg-protocol": "^1.5.0",
    "pg-types": "^2.1.0",
    pgpass: "1.x"
  }, devDependencies: { async: "2.6.4", bluebird: "3.5.2", co: "4.6.0", "pg-copy-streams": "0.3.0" }, peerDependencies: { "pg-native": ">=3.0.1" }, peerDependenciesMeta: {
    "pg-native": { optional: true }
  }, scripts: { test: "make test-all" }, files: ["lib", "SPONSORS.md"], license: "MIT", engines: { node: ">= 8.0.0" }, gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655" };
});
var js = I((mf, Qs) => {
  "use strict";
  p2();
  var qs = we().EventEmitter, Pc = (Ge(), N(He)), Sn = tt(), Qe = Qs.exports = function(r3, e2, t2) {
    qs.call(this), r3 = Sn.normalizeQueryConfig(r3, e2, t2), this.text = r3.text, this.values = r3.values, this.name = r3.name, this.callback = r3.callback, this.state = "new", this._arrayMode = r3.rowMode === "array", this._emitRowEvents = false, this.on("newListener", function(n3) {
      n3 === "row" && (this._emitRowEvents = true);
    }.bind(this));
  };
  Pc.inherits(
    Qe,
    qs
  );
  var Bc = { sqlState: "code", statementPosition: "position", messagePrimary: "message", context: "where", schemaName: "schema", tableName: "table", columnName: "column", dataTypeName: "dataType", constraintName: "constraint", sourceFile: "file", sourceLine: "line", sourceFunction: "routine" };
  Qe.prototype.handleError = function(r3) {
    var e2 = this.native.pq.resultErrorFields();
    if (e2)
      for (var t2 in e2) {
        var n3 = Bc[t2] || t2;
        r3[n3] = e2[t2];
      }
    this.callback ? this.callback(r3) : this.emit("error", r3), this.state = "error";
  };
  Qe.prototype.then = function(r3, e2) {
    return this._getPromise().then(r3, e2);
  };
  Qe.prototype.catch = function(r3) {
    return this._getPromise().catch(r3);
  };
  Qe.prototype._getPromise = function() {
    return this._promise ? this._promise : (this._promise = new Promise(function(r3, e2) {
      this._once("end", r3), this._once(
        "error",
        e2
      );
    }.bind(this)), this._promise);
  };
  Qe.prototype.submit = function(r3) {
    this.state = "running";
    var e2 = this;
    this.native = r3.native, r3.native.arrayMode = this._arrayMode;
    var t2 = a(
      function(s3, o4, u3) {
        if (r3.native.arrayMode = false, E(function() {
          e2.emit("_done");
        }), s3)
          return e2.handleError(s3);
        e2._emitRowEvents && (u3.length > 1 ? o4.forEach((c4, h2) => {
          c4.forEach((l3) => {
            e2.emit(
              "row",
              l3,
              u3[h2]
            );
          });
        }) : o4.forEach(function(c4) {
          e2.emit("row", c4, u3);
        })), e2.state = "end", e2.emit(
          "end",
          u3
        ), e2.callback && e2.callback(null, u3);
      },
      "after"
    );
    if (m2.domain && (t2 = m2.domain.bind(
      t2
    )), this.name) {
      this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error(
        "You supplied %s (%s)",
        this.name,
        this.name.length
      ), console.error("This can cause conflicts and silent errors executing queries"));
      var n3 = (this.values || []).map(Sn.prepareValue);
      if (r3.namedQueries[this.name]) {
        if (this.text && r3.namedQueries[this.name] !== this.text) {
          let s3 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return t2(s3);
        }
        return r3.native.execute(this.name, n3, t2);
      }
      return r3.native.prepare(
        this.name,
        this.text,
        n3.length,
        function(s3) {
          return s3 ? t2(s3) : (r3.namedQueries[e2.name] = e2.text, e2.native.execute(e2.name, n3, t2));
        }
      );
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        let s3 = new Error("Query values must be an array");
        return t2(s3);
      }
      var i3 = this.values.map(Sn.prepareValue);
      r3.native.query(this.text, i3, t2);
    } else
      r3.native.query(this.text, t2);
  };
});
var $s = I((Sf, Gs) => {
  "use strict";
  p2();
  var Lc = (Us(), N(Os)), Rc = gt2(), bf = Ns(), Ws = we().EventEmitter, Fc = (Ge(), N(He)), Mc = wt(), Hs = js(), J = Gs.exports = function(r3) {
    Ws.call(this), r3 = r3 || {}, this._Promise = r3.Promise || S.Promise, this._types = new Rc(r3.types), this.native = new Lc({ types: this._types }), this._queryQueue = [], this._ending = false, this._connecting = false, this._connected = false, this._queryable = true;
    var e2 = this.connectionParameters = new Mc(
      r3
    );
    this.user = e2.user, Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: e2.password
    }), this.database = e2.database, this.host = e2.host, this.port = e2.port, this.namedQueries = {};
  };
  J.Query = Hs;
  Fc.inherits(J, Ws);
  J.prototype._errorAllQueries = function(r3) {
    let e2 = a(
      (t2) => {
        m2.nextTick(() => {
          t2.native = this.native, t2.handleError(r3);
        });
      },
      "enqueueError"
    );
    this._hasActiveQuery() && (e2(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e2), this._queryQueue.length = 0;
  };
  J.prototype._connect = function(r3) {
    var e2 = this;
    if (this._connecting) {
      m2.nextTick(() => r3(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true, this.connectionParameters.getLibpqConnectionString(function(t2, n3) {
      if (t2)
        return r3(
          t2
        );
      e2.native.connect(n3, function(i3) {
        if (i3)
          return e2.native.end(), r3(i3);
        e2._connected = true, e2.native.on("error", function(s3) {
          e2._queryable = false, e2._errorAllQueries(s3), e2.emit("error", s3);
        }), e2.native.on("notification", function(s3) {
          e2.emit("notification", { channel: s3.relname, payload: s3.extra });
        }), e2.emit("connect"), e2._pulseQueryQueue(true), r3();
      });
    });
  };
  J.prototype.connect = function(r3) {
    if (r3) {
      this._connect(r3);
      return;
    }
    return new this._Promise(
      (e2, t2) => {
        this._connect((n3) => {
          n3 ? t2(n3) : e2();
        });
      }
    );
  };
  J.prototype.query = function(r3, e2, t2) {
    var n3, i3, s3, o4, u3;
    if (r3 == null)
      throw new TypeError("Client was passed a null or undefined query");
    if (typeof r3.submit == "function")
      s3 = r3.query_timeout || this.connectionParameters.query_timeout, i3 = n3 = r3, typeof e2 == "function" && (r3.callback = e2);
    else if (s3 = this.connectionParameters.query_timeout, n3 = new Hs(r3, e2, t2), !n3.callback) {
      let c4, h2;
      i3 = new this._Promise((l3, d3) => {
        c4 = l3, h2 = d3;
      }), n3.callback = (l3, d3) => l3 ? h2(l3) : c4(d3);
    }
    return s3 && (u3 = n3.callback, o4 = setTimeout(() => {
      var c4 = new Error("Query read timeout");
      m2.nextTick(() => {
        n3.handleError(c4, this.connection);
      }), u3(c4), n3.callback = () => {
      };
      var h2 = this._queryQueue.indexOf(n3);
      h2 > -1 && this._queryQueue.splice(h2, 1), this._pulseQueryQueue();
    }, s3), n3.callback = (c4, h2) => {
      clearTimeout(o4), u3(c4, h2);
    }), this._queryable ? this._ending ? (n3.native = this.native, m2.nextTick(() => {
      n3.handleError(
        new Error("Client was closed and is not queryable")
      );
    }), i3) : (this._queryQueue.push(
      n3
    ), this._pulseQueryQueue(), i3) : (n3.native = this.native, m2.nextTick(() => {
      n3.handleError(
        new Error("Client has encountered a connection error and is not queryable")
      );
    }), i3);
  };
  J.prototype.end = function(r3) {
    var e2 = this;
    this._ending = true, this._connected || this.once(
      "connect",
      this.end.bind(this, r3)
    );
    var t2;
    return r3 || (t2 = new this._Promise(function(n3, i3) {
      r3 = a((s3) => s3 ? i3(s3) : n3(), "cb");
    })), this.native.end(function() {
      e2._errorAllQueries(new Error(
        "Connection terminated"
      )), m2.nextTick(() => {
        e2.emit("end"), r3 && r3();
      });
    }), t2;
  };
  J.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  J.prototype._pulseQueryQueue = function(r3) {
    if (this._connected && !this._hasActiveQuery()) {
      var e2 = this._queryQueue.shift();
      if (!e2) {
        r3 || this.emit("drain");
        return;
      }
      this._activeQuery = e2, e2.submit(this);
      var t2 = this;
      e2.once(
        "_done",
        function() {
          t2._pulseQueryQueue();
        }
      );
    }
  };
  J.prototype.cancel = function(r3) {
    this._activeQuery === r3 ? this.native.cancel(function() {
    }) : this._queryQueue.indexOf(r3) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r3), 1);
  };
  J.prototype.ref = function() {
  };
  J.prototype.unref = function() {
  };
  J.prototype.setTypeParser = function(r3, e2, t2) {
    return this._types.setTypeParser(r3, e2, t2);
  };
  J.prototype.getTypeParser = function(r3, e2) {
    return this._types.getTypeParser(r3, e2);
  };
});
var En = I((vf, Vs) => {
  "use strict";
  p2();
  Vs.exports = $s();
});
var Tt = I((Af, nt) => {
  "use strict";
  p2();
  var Dc = Rs(), kc = et(), Oc = fn2(), Uc = ks(), { DatabaseError: Nc } = cn(), qc = a((r3) => {
    var e2;
    return e2 = /* @__PURE__ */ __name(class extends Uc {
      constructor(n3) {
        super(n3, r3);
      }
    }, "e"), a(e2, "BoundPool"), e2;
  }, "poolFactory"), xn = a(function(r3) {
    this.defaults = kc, this.Client = r3, this.Query = this.Client.Query, this.Pool = qc(this.Client), this._pools = [], this.Connection = Oc, this.types = Xe(), this.DatabaseError = Nc;
  }, "PG");
  typeof m2.env.NODE_PG_FORCE_NATIVE < "u" ? nt.exports = new xn(En()) : (nt.exports = new xn(Dc), Object.defineProperty(nt.exports, "native", { configurable: true, enumerable: false, get() {
    var r3 = null;
    try {
      r3 = new xn(En());
    } catch (e2) {
      if (e2.code !== "MODULE_NOT_FOUND")
        throw e2;
    }
    return Object.defineProperty(nt.exports, "native", { value: r3 }), r3;
  } }));
});
p2();
var Pt = Ie(Tt());
bt();
p2();
bt();
yr();
var Ys = Ie(tt());
var Zs = Ie(gt2());
var It = /* @__PURE__ */ __name(class It2 extends Error {
  constructor(t2) {
    super(t2);
    _(this, "name", "NeonDbError");
    _(this, "severity");
    _(this, "code");
    _(this, "detail");
    _(this, "hint");
    _(this, "position");
    _(this, "internalPosition");
    _(this, "internalQuery");
    _(this, "where");
    _(this, "schema");
    _(this, "table");
    _(this, "column");
    _(this, "dataType");
    _(this, "constraint");
    _(this, "file");
    _(this, "line");
    _(this, "routine");
    _(this, "sourceError");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(
      this,
      It2
    );
  }
}, "It");
a(It, "NeonDbError");
var fe = It;
var Ks = "transaction() expects an array of queries, or a function returning an array of queries";
var Qc = [
  "severity",
  "code",
  "detail",
  "hint",
  "position",
  "internalPosition",
  "internalQuery",
  "where",
  "schema",
  "table",
  "column",
  "dataType",
  "constraint",
  "file",
  "line",
  "routine"
];
function Js(r3, {
  arrayMode: e2,
  fullResults: t2,
  fetchOptions: n3,
  isolationLevel: i3,
  readOnly: s3,
  deferrable: o4,
  queryCallback: u3,
  resultCallback: c4,
  authToken: h2
} = {}) {
  if (!r3)
    throw new Error("No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?");
  let l3;
  try {
    l3 = dr(r3);
  } catch {
    throw new Error("Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(r3));
  }
  let {
    protocol: d3,
    username: b3,
    hostname: C3,
    port: B,
    pathname: j3
  } = l3;
  if (d3 !== "postgres:" && d3 !== "postgresql:" || !b3 || !C3 || !j3)
    throw new Error("Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value");
  function X(A2, ...w3) {
    let P, V;
    if (typeof A2 == "string")
      P = A2, V = w3[1], w3 = w3[0] ?? [];
    else {
      P = "";
      for (let W = 0; W < A2.length; W++)
        P += A2[W], W < w3.length && (P += "$" + (W + 1));
    }
    w3 = w3.map((W) => (0, Ys.prepareValue)(W));
    let O3 = {
      query: P,
      params: w3
    };
    return u3 && u3(O3), jc(pe, O3, V);
  }
  __name(X, "X");
  a(X, "resolve"), X.transaction = async (A2, w3) => {
    if (typeof A2 == "function" && (A2 = A2(X)), !Array.isArray(A2))
      throw new Error(Ks);
    A2.forEach((O3) => {
      if (O3[Symbol.toStringTag] !== "NeonQueryPromise")
        throw new Error(Ks);
    });
    let P = A2.map((O3) => O3.parameterizedQuery), V = A2.map((O3) => O3.opts ?? {});
    return pe(P, V, w3);
  };
  async function pe(A2, w3, P) {
    let {
      fetchEndpoint: V,
      fetchFunction: O3
    } = Ae, W = typeof V == "function" ? V(C3, B, { jwtAuth: h2 !== void 0 }) : V, ae = Array.isArray(A2) ? { queries: A2 } : A2, ee = n3 ?? {}, R = e2 ?? false, G = t2 ?? false, ue = i3, de = s3, Ee = o4;
    P !== void 0 && (P.fetchOptions !== void 0 && (ee = { ...ee, ...P.fetchOptions }), P.arrayMode !== void 0 && (R = P.arrayMode), P.fullResults !== void 0 && (G = P.fullResults), P.isolationLevel !== void 0 && (ue = P.isolationLevel), P.readOnly !== void 0 && (de = P.readOnly), P.deferrable !== void 0 && (Ee = P.deferrable)), w3 !== void 0 && !Array.isArray(w3) && w3.fetchOptions !== void 0 && (ee = {
      ...ee,
      ...w3.fetchOptions
    });
    let ce = { "Neon-Connection-String": r3, "Neon-Raw-Text-Output": "true", "Neon-Array-Mode": "true" }, Ce = await Wc(h2);
    Ce && (ce.Authorization = `Bearer ${Ce}`), Array.isArray(A2) && (ue !== void 0 && (ce["Neon-Batch-Isolation-Level"] = ue), de !== void 0 && (ce["Neon-Batch-Read-Only"] = String(de)), Ee !== void 0 && (ce["Neon-Batch-Deferrable"] = String(Ee)));
    let ye;
    try {
      ye = await (O3 ?? fetch)(W, { method: "POST", body: JSON.stringify(ae), headers: ce, ...ee });
    } catch (K) {
      let k3 = new fe(`Error connecting to database: ${K.message}`);
      throw k3.sourceError = K, k3;
    }
    if (ye.ok) {
      let K = await ye.json();
      if (Array.isArray(A2)) {
        let k3 = K.results;
        if (!Array.isArray(k3))
          throw new fe("Neon internal error: unexpected result format");
        return k3.map((me, xe) => {
          let Bt = w3[xe] ?? {}, to = Bt.arrayMode ?? R, ro = Bt.fullResults ?? G;
          return zs(me, {
            arrayMode: to,
            fullResults: ro,
            parameterizedQuery: A2[xe],
            resultCallback: c4,
            types: Bt.types
          });
        });
      } else {
        let k3 = w3 ?? {}, me = k3.arrayMode ?? R, xe = k3.fullResults ?? G;
        return zs(K, {
          arrayMode: me,
          fullResults: xe,
          parameterizedQuery: A2,
          resultCallback: c4,
          types: k3.types
        });
      }
    } else {
      let { status: K } = ye;
      if (K === 400) {
        let k3 = await ye.json(), me = new fe(
          k3.message
        );
        for (let xe of Qc)
          me[xe] = k3[xe] ?? void 0;
        throw me;
      } else {
        let k3 = await ye.text();
        throw new fe(`Server error (HTTP status ${K}): ${k3}`);
      }
    }
  }
  __name(pe, "pe");
  return a(pe, "execute"), X;
}
__name(Js, "Js");
a(Js, "neon");
function jc(r3, e2, t2) {
  return {
    [Symbol.toStringTag]: "NeonQueryPromise",
    parameterizedQuery: e2,
    opts: t2,
    then: a((n3, i3) => r3(e2, t2).then(n3, i3), "then"),
    catch: a((n3) => r3(e2, t2).catch(n3), "catch"),
    finally: a((n3) => r3(e2, t2).finally(n3), "finally")
  };
}
__name(jc, "jc");
a(jc, "createNeonQueryPromise");
function zs(r3, {
  arrayMode: e2,
  fullResults: t2,
  parameterizedQuery: n3,
  resultCallback: i3,
  types: s3
}) {
  let o4 = new Zs.default(
    s3
  ), u3 = r3.fields.map((l3) => l3.name), c4 = r3.fields.map((l3) => o4.getTypeParser(l3.dataTypeID)), h2 = e2 === true ? r3.rows.map((l3) => l3.map((d3, b3) => d3 === null ? null : c4[b3](d3))) : r3.rows.map((l3) => Object.fromEntries(
    l3.map((d3, b3) => [u3[b3], d3 === null ? null : c4[b3](d3)])
  ));
  return i3 && i3(n3, r3, h2, { arrayMode: e2, fullResults: t2 }), t2 ? (r3.viaNeonFetch = true, r3.rowAsArray = e2, r3.rows = h2, r3._parsers = c4, r3._types = o4, r3) : h2;
}
__name(zs, "zs");
a(zs, "processQueryResult");
async function Wc(r3) {
  if (typeof r3 == "string")
    return r3;
  if (typeof r3 == "function")
    try {
      return await Promise.resolve(r3());
    } catch (e2) {
      let t2 = new fe("Error getting auth token.");
      throw e2 instanceof Error && (t2 = new fe(`Error getting auth token: ${e2.message}`)), t2;
    }
}
__name(Wc, "Wc");
a(Wc, "getAuthToken");
var eo = Ie(wt());
var je = Ie(Tt());
var _n = /* @__PURE__ */ __name(class _n2 extends Pt.Client {
  constructor(t2) {
    super(t2);
    this.config = t2;
  }
  get neonConfig() {
    return this.connection.stream;
  }
  connect(t2) {
    let { neonConfig: n3 } = this;
    n3.forceDisablePgSSL && (this.ssl = this.connection.ssl = false), this.ssl && n3.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
    let i3 = this.config?.host !== void 0 || this.config?.connectionString !== void 0 || m2.env.PGHOST !== void 0, s3 = m2.env.USER ?? m2.env.USERNAME;
    if (!i3 && this.host === "localhost" && this.user === s3 && this.database === s3 && this.password === null)
      throw new Error(`No database host or connection string was set, and key parameters have default values (host: localhost, user: ${s3}, db: ${s3}, password: null). Is an environment variable missing? Alternatively, if you intended to connect with these parameters, please set the host to 'localhost' explicitly.`);
    let o4 = super.connect(t2), u3 = n3.pipelineTLS && this.ssl, c4 = n3.pipelineConnect === "password";
    if (!u3 && !n3.pipelineConnect)
      return o4;
    let h2 = this.connection;
    if (u3 && h2.on("connect", () => h2.stream.emit("data", "S")), c4) {
      h2.removeAllListeners(
        "authenticationCleartextPassword"
      ), h2.removeAllListeners("readyForQuery"), h2.once(
        "readyForQuery",
        () => h2.on("readyForQuery", this._handleReadyForQuery.bind(this))
      );
      let l3 = this.ssl ? "sslconnect" : "connect";
      h2.on(l3, () => {
        this._handleAuthCleartextPassword(), this._handleReadyForQuery();
      });
    }
    return o4;
  }
  async _handleAuthSASLContinue(t2) {
    let n3 = this.saslSession, i3 = this.password, s3 = t2.data;
    if (n3.message !== "SASLInitialResponse" || typeof i3 != "string" || typeof s3 != "string")
      throw new Error("SASL: protocol error");
    let o4 = Object.fromEntries(s3.split(",").map((K) => {
      if (!/^.=/.test(K))
        throw new Error("SASL: Invalid attribute pair entry");
      let k3 = K[0], me = K.substring(2);
      return [k3, me];
    })), u3 = o4.r, c4 = o4.s, h2 = o4.i;
    if (!u3 || !/^[!-+--~]+$/.test(u3))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable");
    if (!c4 || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(c4))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64");
    if (!h2 || !/^[1-9][0-9]*$/.test(h2))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count");
    if (!u3.startsWith(n3.clientNonce))
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce"
      );
    if (u3.length === n3.clientNonce.length)
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    let l3 = parseInt(h2, 10), d3 = y.from(c4, "base64"), b3 = new TextEncoder(), C3 = b3.encode(i3), B = await g.subtle.importKey("raw", C3, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), j3 = new Uint8Array(await g.subtle.sign("HMAC", B, y.concat([d3, y.from(
      [0, 0, 0, 1]
    )]))), X = j3;
    for (var pe = 0; pe < l3 - 1; pe++)
      j3 = new Uint8Array(await g.subtle.sign(
        "HMAC",
        B,
        j3
      )), X = y.from(X.map((K, k3) => X[k3] ^ j3[k3]));
    let A2 = X, w3 = await g.subtle.importKey(
      "raw",
      A2,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), P = new Uint8Array(await g.subtle.sign("HMAC", w3, b3.encode("Client Key"))), V = await g.subtle.digest(
      "SHA-256",
      P
    ), O3 = "n=*,r=" + n3.clientNonce, W = "r=" + u3 + ",s=" + c4 + ",i=" + l3, ae = "c=biws,r=" + u3, ee = O3 + "," + W + "," + ae, R = await g.subtle.importKey(
      "raw",
      V,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    );
    var G = new Uint8Array(await g.subtle.sign("HMAC", R, b3.encode(ee))), ue = y.from(P.map((K, k3) => P[k3] ^ G[k3])), de = ue.toString("base64");
    let Ee = await g.subtle.importKey(
      "raw",
      A2,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), ce = await g.subtle.sign(
      "HMAC",
      Ee,
      b3.encode("Server Key")
    ), Ce = await g.subtle.importKey("raw", ce, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var ye = y.from(await g.subtle.sign(
      "HMAC",
      Ce,
      b3.encode(ee)
    ));
    n3.message = "SASLResponse", n3.serverSignature = ye.toString("base64"), n3.response = ae + ",p=" + de, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
  }
}, "_n");
a(_n, "NeonClient");
var vn = _n;
function Hc(r3, e2) {
  if (e2)
    return {
      callback: e2,
      result: void 0
    };
  let t2, n3, i3 = a(function(o4, u3) {
    o4 ? t2(o4) : n3(u3);
  }, "cb"), s3 = new r3(function(o4, u3) {
    n3 = o4, t2 = u3;
  });
  return { callback: i3, result: s3 };
}
__name(Hc, "Hc");
a(Hc, "promisify");
var An = /* @__PURE__ */ __name(class An2 extends Pt.Pool {
  constructor() {
    super(...arguments);
    _(this, "Client", vn);
    _(this, "hasFetchUnsupportedListeners", false);
  }
  on(t2, n3) {
    return t2 !== "error" && (this.hasFetchUnsupportedListeners = true), super.on(t2, n3);
  }
  query(t2, n3, i3) {
    if (!Ae.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t2 == "function")
      return super.query(t2, n3, i3);
    typeof n3 == "function" && (i3 = n3, n3 = void 0);
    let s3 = Hc(
      this.Promise,
      i3
    );
    i3 = s3.callback;
    try {
      let o4 = new eo.default(this.options), u3 = encodeURIComponent, c4 = encodeURI, h2 = `postgresql://${u3(o4.user)}:${u3(o4.password)}@${u3(o4.host)}/${c4(o4.database)}`, l3 = typeof t2 == "string" ? t2 : t2.text, d3 = n3 ?? t2.values ?? [];
      Js(h2, { fullResults: true, arrayMode: t2.rowMode === "array" })(l3, d3, { types: t2.types ?? this.options?.types }).then((C3) => i3(void 0, C3)).catch((C3) => i3(
        C3
      ));
    } catch (o4) {
      i3(o4);
    }
    return s3.result;
  }
}, "An");
a(An, "NeonPool");
var export_ClientBase = je.ClientBase;
var export_Connection = je.Connection;
var export_DatabaseError = je.DatabaseError;
var export_Query = je.Query;
var export_defaults = je.defaults;
var export_types = je.types;

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/neon-http/session.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var rawQueryConfig = {
  arrayMode: false,
  fullResults: true
};
var queryConfig = {
  arrayMode: true,
  fullResults: true
};
var _a121;
var NeonHttpPreparedQuery = class extends PgPreparedQuery {
  constructor(client, query, logger2, fields, _isResponseInArrayMode, customResultMapper) {
    super(query);
    this.client = client;
    this.logger = logger2;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
  }
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    const { fields, client, query, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return client(query.sql, params, rawQueryConfig);
    }
    const result = await client(query.sql, params, queryConfig);
    return this.mapResult(result);
  }
  mapResult(result) {
    if (!this.fields && !this.customResultMapper) {
      return result;
    }
    const rows = result.rows;
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.client(this.query.sql, params, rawQueryConfig).then((result) => result.rows);
  }
  values(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.client(this.query.sql, params, { arrayMode: true, fullResults: true }).then((result) => result.rows);
  }
  /** @internal */
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
};
__name(NeonHttpPreparedQuery, "NeonHttpPreparedQuery");
_a121 = entityKind;
__publicField(NeonHttpPreparedQuery, _a121, "NeonHttpPreparedQuery");
var _a122;
var NeonHttpSession = class extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
  }
  logger;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper) {
    return new NeonHttpPreparedQuery(
      this.client,
      query,
      this.logger,
      fields,
      isResponseInArrayMode,
      customResultMapper
    );
  }
  async batch(queries) {
    const preparedQueries = [];
    const builtQueries = [];
    for (const query of queries) {
      const preparedQuery = query._prepare();
      const builtQuery = preparedQuery.getQuery();
      preparedQueries.push(preparedQuery);
      builtQueries.push(
        this.client(builtQuery.sql, builtQuery.params, {
          fullResults: true,
          arrayMode: preparedQuery.isResponseInArrayMode()
        })
      );
    }
    const batchResults = await this.client.transaction(builtQueries, queryConfig);
    return batchResults.map((result, i3) => preparedQueries[i3].mapResult(result, true));
  }
  // change return type to QueryRows<true>
  async query(query, params) {
    this.logger.logQuery(query, params);
    const result = await this.client(query, params, { arrayMode: true, fullResults: true });
    return result;
  }
  // change return type to QueryRows<false>
  async queryObjects(query, params) {
    return this.client(query, params, { arrayMode: false, fullResults: true });
  }
  async transaction(_transaction, _config = {}) {
    throw new Error("No transactions support in neon-http driver");
  }
};
__name(NeonHttpSession, "NeonHttpSession");
_a122 = entityKind;
__publicField(NeonHttpSession, _a122, "NeonHttpSession");
var _a123;
var NeonTransaction = class extends PgTransaction {
  async transaction(_transaction) {
    throw new Error("No transactions support in neon-http driver");
  }
};
__name(NeonTransaction, "NeonTransaction");
_a123 = entityKind;
__publicField(NeonTransaction, _a123, "NeonHttpTransaction");

// node_modules/.pnpm/drizzle-orm@0.33.0_@cloudflare+workers-types@4.20241004.0_@neondatabase+serverless@0.10.1_@ty_y3ibcs6n2634343pyxnmcscery/node_modules/drizzle-orm/neon-http/driver.js
var _a124;
var NeonHttpDriver = class {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
    this.initMappers();
  }
  createSession(schema) {
    return new NeonHttpSession(this.client, this.dialect, schema, { logger: this.options.logger });
  }
  initMappers() {
    export_types.setTypeParser(export_types.builtins.TIMESTAMPTZ, (val) => val);
    export_types.setTypeParser(export_types.builtins.TIMESTAMP, (val) => val);
    export_types.setTypeParser(export_types.builtins.DATE, (val) => val);
    export_types.setTypeParser(export_types.builtins.INTERVAL, (val) => val);
  }
};
__name(NeonHttpDriver, "NeonHttpDriver");
_a124 = entityKind;
__publicField(NeonHttpDriver, _a124, "NeonDriver");
var _a125;
var NeonHttpDatabase = class extends PgDatabase {
  async batch(batch) {
    return this.session.batch(batch);
  }
};
__name(NeonHttpDatabase, "NeonHttpDatabase");
_a125 = entityKind;
__publicField(NeonHttpDatabase, _a125, "NeonHttpDatabase");
function drizzle(client, config2 = {}) {
  const dialect = new PgDialect();
  let logger2;
  if (config2.logger === true) {
    logger2 = new DefaultLogger();
  } else if (config2.logger !== false) {
    logger2 = config2.logger;
  }
  let schema;
  if (config2.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config2.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config2.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NeonHttpDriver(client, dialect, { logger: logger2 });
  const session2 = driver.createSession(schema);
  return new NeonHttpDatabase(
    dialect,
    session2,
    schema
  );
}
__name(drizzle, "drizzle");

// src/db/db.ts
var sql2 = Js(process.env.DATABASE_URL);
var db = drizzle(sql2);

// src/controllers/products/get-product.ts
var getProducts = /* @__PURE__ */ __name(async (paginationParams) => {
  const {
    limit = 10,
    offset = 0,
    search = "",
    priceFilter,
    sortBy = "createdAt"
  } = paginationParams;
  const similarityThreshold = 0.3;
  const searchQuery = search ? sql`(similarity(${products.name}, ${search}) > ${similarityThreshold} OR similarity(${products.description}, ${search}) > ${similarityThreshold})` : void 0;
  const whereClause = and(
    searchQuery,
    // Full-text search on name and description
    priceFilter ? lte(products.price, priceFilter?.toString()) : void 0
    // Filter by price (<=)
  );
  const productList = await db.select().from(products).where(whereClause).limit(limit).offset(offset).orderBy(products[sortBy] || products.name);
  const totalProducts = await db.select({ count: count3() }).from(products).where(whereClause);
  return {
    products: productList,
    pagination: {
      total: totalProducts[0].count,
      // total number of products
      limit,
      offset
    }
  };
}, "getProducts");

// src/controllers/products/home-api/new-arrival.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var getNewARrival = /* @__PURE__ */ __name(async () => {
  const latestProducts = await db.select({
    id: products.id,
    name: products.name,
    price: products.price,
    discountedPrice: products.discountedPrice,
    primaryImage: products.primaryImage,
    stock: products.stock,
    brand: products.brand,
    categoryName: categories.name
    // Joining category name
  }).from(products).innerJoin(categories, eq(products.categoryId, categories.id)).where(
    and(
      eq(products.isAvailable, true),
      // Product is available
      gt(products.stock, 0)
      // Stock greater than 0
    )
  ).orderBy(desc(products.createdAt)).limit(20);
  return latestProducts;
}, "getNewARrival");

// src/controllers/products/product-details.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var getProductDetails = /* @__PURE__ */ __name(async (id) => {
  try {
    const parent = alias(products, "parent");
    const sibling = alias(products, "sibling");
    const result = await db.select({
      id: products.id,
      name: products.name,
      sortDescription: products.sortDescription,
      description: products.description,
      sku: products.sku,
      price: products.price,
      rating: products.rating,
      discountedPrice: products.discountedPrice,
      currentVariantType: products.currentVariantType,
      currentVariantValue: products.variantValue,
      category: products.categoryName,
      stock: products.stock,
      primaryImage: products.primaryImage,
      subImage: {
        image: productImages.imageUrl
      },
      brand: products.brand,
      meta: products.meta,
      isAvailable: products.isAvailable,
      parent: {
        id: parent.id,
        name: parent.name,
        primaryImage: parent.primaryImage,
        stock: parent.stock,
        price: parent.price,
        discountedPrice: parent.discountedPrice,
        variantValue: parent.variantValue
      },
      sibling: {
        id: sibling.id,
        name: sibling.name,
        primaryImage: sibling.primaryImage,
        stock: sibling.stock,
        price: sibling.price,
        discountedPrice: sibling.discountedPrice,
        variantValue: sibling.variantValue
      }
    }).from(products).leftJoin(parent, eq(products.parentId, parent.id)).leftJoin(
      sibling,
      or(
        and(
          eq(sibling.parentId, products.parentId),
          ne(sibling.id, products.id)
        ),
        eq(sibling.parentId, products.id)
      )
    ).leftJoin(productImages, eq(productImages.productId, products.id)).where(eq(products.id, id));
    if (!result.length) {
      return null;
    }
    const siblingsMap = /* @__PURE__ */ new Map();
    const imagesMap = /* @__PURE__ */ new Map();
    result.forEach((r3) => {
      if (r3.sibling?.id) {
        siblingsMap.set(r3.sibling.id, r3.sibling);
      }
      if (r3.subImage?.image) {
        imagesMap.set(r3.subImage.image, { image: r3.subImage.image });
      }
    });
    const siblings = Array.from(siblingsMap.values());
    const images = Array.from(imagesMap.values());
    const typeOfVars = result[0]?.sibling;
    const variants = result[0]?.parent?.id ? [result[0].parent, ...siblings] : siblings;
    const output = {
      product: {
        ...result[0],
        subImages: images,
        subImage: void 0,
        parent: void 0,
        sibling: void 0
      },
      variants
    };
    return output;
  } catch (error4) {
    console.log("This is error", error4);
    return null;
  }
}, "getProductDetails");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/http-exception.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var HTTPException = /* @__PURE__ */ __name(class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
}, "HTTPException");

// src/routes/product.ts
var product = new Hono2().get("/home-api/new-arrival", async (c4) => {
  const newArrival = await getNewARrival();
  return c4.json(newArrival);
}).get("/", async (c4) => {
  const params = c4.req.query();
  const product2 = await getProducts({
    limit: 10,
    offset: 0,
    priceFilter: +params.priceFilter,
    search: params.search,
    sortBy: params.sortBy
  });
  return c4.json(product2);
}).get("/product-details/:id", async (c4) => {
  const params = c4.req.param("id") || "";
  const product2 = await getProductDetails(params);
  if (!product2) {
    throw new HTTPException(401, { message: "Product not found" });
  }
  return c4.json(product2);
}).post("/", async (c4) => {
  const formData = await c4.req.parseBody({ all: true });
  const validationResult = insertProductSchema.safeParse(formData);
  if (!validationResult.success) {
    return c4.json({ errors: validationResult.error.errors }, 400);
  }
  const files = formData.files;
  if (!files || files.length === 0) {
    return c4.json({ error: "At least one file is required" }, 400);
  }
  const savedFiles = await uploadService_default.uploadFiles(files);
  if ("error" in savedFiles) {
    return c4.json({ error: savedFiles.error }, 400);
  }
  return c4.json({
    message: "Product created successfully",
    data: validationResult.data,
    uploadedFiles: savedFiles
  });
}).post("/delete", async (c4) => {
  return c4.json({ message: "File deleted successfully" });
});
var product_default = product;

// src/routes/banners.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/controllers/banners/get-banner.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var getBannersByType = /* @__PURE__ */ __name(async (type2) => {
  const result = await db.select({
    id: banners.id,
    imageUrl: banners.imageUrl,
    href: banners.link,
    title: banners.title
  }).from(banners).where(
    and(
      eq(banners.bannerType, type2),
      eq(banners.isActive, true),
      lte(banners.startDate, /* @__PURE__ */ new Date()),
      gte(banners.endDate, /* @__PURE__ */ new Date())
    )
  ).orderBy(banners.priority).limit(10).execute();
  return result;
}, "getBannersByType");

// src/routes/banners.ts
var banner = new Hono2().get("/:type", async (c4) => {
  const params = c4.req.param("type") || "";
  const banners2 = await getBannersByType(params);
  return c4.json(banners2);
});
var banners_default = banner;

// src/routes/testRoute.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var testRoute = new Hono2().get("/", (c4) => {
  return c4.json({ message: "Hello World" });
});
var testRoute_default = testRoute;

// src/routes/wishlist.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/lib/utils/middlewareUtils.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@hono+auth-js@1.0.11_@auth+core@0.35.3_hono@4.6.3_react@18.3.1/node_modules/@hono/auth-js/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/assert.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/cookie.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var __classPrivateFieldSet2 = function(receiver, state2, value, kind, f4) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state2.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state2, kind, f4) {
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state2.get(receiver);
};
var _SessionStore_instances;
var _SessionStore_chunks;
var _SessionStore_option;
var _SessionStore_logger;
var _SessionStore_chunk;
var _SessionStore_clean;
var ALLOWED_COOKIE_SIZE = 4096;
var ESTIMATED_EMPTY_COOKIE_SIZE = 160;
var CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;
function defaultCookies(useSecureCookies) {
  const cookiePrefix = useSecureCookies ? "__Secure-" : "";
  return {
    // default cookie options
    sessionToken: {
      name: `${cookiePrefix}authjs.session-token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies
      }
    },
    callbackUrl: {
      name: `${cookiePrefix}authjs.callback-url`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies
      }
    },
    csrfToken: {
      // Default to __Host- for CSRF token for additional protection if using useSecureCookies
      // NB: The `__Host-` prefix is stricter than the `__Secure-` prefix.
      name: `${useSecureCookies ? "__Host-" : ""}authjs.csrf-token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies
      }
    },
    pkceCodeVerifier: {
      name: `${cookiePrefix}authjs.pkce.code_verifier`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    },
    state: {
      name: `${cookiePrefix}authjs.state`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    },
    nonce: {
      name: `${cookiePrefix}authjs.nonce`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies
      }
    },
    webauthnChallenge: {
      name: `${cookiePrefix}authjs.challenge`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: useSecureCookies,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    }
  };
}
__name(defaultCookies, "defaultCookies");
var SessionStore = class {
  constructor(option, cookies, logger2) {
    _SessionStore_instances.add(this);
    _SessionStore_chunks.set(this, {});
    _SessionStore_option.set(this, void 0);
    _SessionStore_logger.set(this, void 0);
    __classPrivateFieldSet2(this, _SessionStore_logger, logger2, "f");
    __classPrivateFieldSet2(this, _SessionStore_option, option, "f");
    if (!cookies)
      return;
    const { name: sessionCookiePrefix } = option;
    for (const [name, value] of Object.entries(cookies)) {
      if (!name.startsWith(sessionCookiePrefix) || !value)
        continue;
      __classPrivateFieldGet2(this, _SessionStore_chunks, "f")[name] = value;
    }
  }
  /**
   * The JWT Session or database Session ID
   * constructed from the cookie chunks.
   */
  get value() {
    const sortedKeys = Object.keys(__classPrivateFieldGet2(this, _SessionStore_chunks, "f")).sort((a4, b3) => {
      const aSuffix = parseInt(a4.split(".").pop() || "0");
      const bSuffix = parseInt(b3.split(".").pop() || "0");
      return aSuffix - bSuffix;
    });
    return sortedKeys.map((key) => __classPrivateFieldGet2(this, _SessionStore_chunks, "f")[key]).join("");
  }
  /**
   * Given a cookie value, return new cookies, chunked, to fit the allowed cookie size.
   * If the cookie has changed from chunked to unchunked or vice versa,
   * it deletes the old cookies as well.
   */
  chunk(value, options) {
    const cookies = __classPrivateFieldGet2(this, _SessionStore_instances, "m", _SessionStore_clean).call(this);
    const chunked = __classPrivateFieldGet2(this, _SessionStore_instances, "m", _SessionStore_chunk).call(this, {
      name: __classPrivateFieldGet2(this, _SessionStore_option, "f").name,
      value,
      options: { ...__classPrivateFieldGet2(this, _SessionStore_option, "f").options, ...options }
    });
    for (const chunk of chunked) {
      cookies[chunk.name] = chunk;
    }
    return Object.values(cookies);
  }
  /** Returns a list of cookies that should be cleaned. */
  clean() {
    return Object.values(__classPrivateFieldGet2(this, _SessionStore_instances, "m", _SessionStore_clean).call(this));
  }
};
__name(SessionStore, "SessionStore");
_SessionStore_chunks = /* @__PURE__ */ new WeakMap(), _SessionStore_option = /* @__PURE__ */ new WeakMap(), _SessionStore_logger = /* @__PURE__ */ new WeakMap(), _SessionStore_instances = /* @__PURE__ */ new WeakSet(), _SessionStore_chunk = /* @__PURE__ */ __name(function _SessionStore_chunk2(cookie) {
  const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);
  if (chunkCount === 1) {
    __classPrivateFieldGet2(this, _SessionStore_chunks, "f")[cookie.name] = cookie.value;
    return [cookie];
  }
  const cookies = [];
  for (let i3 = 0; i3 < chunkCount; i3++) {
    const name = `${cookie.name}.${i3}`;
    const value = cookie.value.substr(i3 * CHUNK_SIZE, CHUNK_SIZE);
    cookies.push({ ...cookie, name, value });
    __classPrivateFieldGet2(this, _SessionStore_chunks, "f")[name] = value;
  }
  __classPrivateFieldGet2(this, _SessionStore_logger, "f").debug("CHUNKING_SESSION_COOKIE", {
    message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,
    emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,
    valueSize: cookie.value.length,
    chunks: cookies.map((c4) => c4.value.length + ESTIMATED_EMPTY_COOKIE_SIZE)
  });
  return cookies;
}, "_SessionStore_chunk"), _SessionStore_clean = /* @__PURE__ */ __name(function _SessionStore_clean2() {
  const cleanedChunks = {};
  for (const name in __classPrivateFieldGet2(this, _SessionStore_chunks, "f")) {
    delete __classPrivateFieldGet2(this, _SessionStore_chunks, "f")?.[name];
    cleanedChunks[name] = {
      name,
      value: "",
      options: { ...__classPrivateFieldGet2(this, _SessionStore_option, "f").options, maxAge: 0 }
    };
  }
  return cleanedChunks;
}, "_SessionStore_clean");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/errors.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var AuthError = class extends Error {
  constructor(message2, errorOptions) {
    if (message2 instanceof Error) {
      super(void 0, {
        cause: { err: message2, ...message2.cause, ...errorOptions }
      });
    } else if (typeof message2 === "string") {
      if (errorOptions instanceof Error) {
        errorOptions = { err: errorOptions, ...errorOptions.cause };
      }
      super(message2, errorOptions);
    } else {
      super(void 0, message2);
    }
    this.name = this.constructor.name;
    this.type = this.constructor.type ?? "AuthError";
    this.kind = this.constructor.kind ?? "error";
    Error.captureStackTrace?.(this, this.constructor);
    const url = `https://errors.authjs.dev#${this.type.toLowerCase()}`;
    this.message += `${this.message ? ". " : ""}Read more at ${url}`;
  }
};
__name(AuthError, "AuthError");
var SignInError = class extends AuthError {
};
__name(SignInError, "SignInError");
SignInError.kind = "signIn";
var AdapterError = class extends AuthError {
};
__name(AdapterError, "AdapterError");
AdapterError.type = "AdapterError";
var AccessDenied = class extends AuthError {
};
__name(AccessDenied, "AccessDenied");
AccessDenied.type = "AccessDenied";
var CallbackRouteError = class extends AuthError {
};
__name(CallbackRouteError, "CallbackRouteError");
CallbackRouteError.type = "CallbackRouteError";
var ErrorPageLoop = class extends AuthError {
};
__name(ErrorPageLoop, "ErrorPageLoop");
ErrorPageLoop.type = "ErrorPageLoop";
var EventError = class extends AuthError {
};
__name(EventError, "EventError");
EventError.type = "EventError";
var InvalidCallbackUrl = class extends AuthError {
};
__name(InvalidCallbackUrl, "InvalidCallbackUrl");
InvalidCallbackUrl.type = "InvalidCallbackUrl";
var CredentialsSignin = class extends SignInError {
  constructor() {
    super(...arguments);
    this.code = "credentials";
  }
};
__name(CredentialsSignin, "CredentialsSignin");
CredentialsSignin.type = "CredentialsSignin";
var InvalidEndpoints = class extends AuthError {
};
__name(InvalidEndpoints, "InvalidEndpoints");
InvalidEndpoints.type = "InvalidEndpoints";
var InvalidCheck = class extends AuthError {
};
__name(InvalidCheck, "InvalidCheck");
InvalidCheck.type = "InvalidCheck";
var JWTSessionError = class extends AuthError {
};
__name(JWTSessionError, "JWTSessionError");
JWTSessionError.type = "JWTSessionError";
var MissingAdapter = class extends AuthError {
};
__name(MissingAdapter, "MissingAdapter");
MissingAdapter.type = "MissingAdapter";
var MissingAdapterMethods = class extends AuthError {
};
__name(MissingAdapterMethods, "MissingAdapterMethods");
MissingAdapterMethods.type = "MissingAdapterMethods";
var MissingAuthorize = class extends AuthError {
};
__name(MissingAuthorize, "MissingAuthorize");
MissingAuthorize.type = "MissingAuthorize";
var MissingSecret = class extends AuthError {
};
__name(MissingSecret, "MissingSecret");
MissingSecret.type = "MissingSecret";
var OAuthAccountNotLinked = class extends SignInError {
};
__name(OAuthAccountNotLinked, "OAuthAccountNotLinked");
OAuthAccountNotLinked.type = "OAuthAccountNotLinked";
var OAuthCallbackError = class extends SignInError {
};
__name(OAuthCallbackError, "OAuthCallbackError");
OAuthCallbackError.type = "OAuthCallbackError";
var OAuthProfileParseError = class extends AuthError {
};
__name(OAuthProfileParseError, "OAuthProfileParseError");
OAuthProfileParseError.type = "OAuthProfileParseError";
var SessionTokenError = class extends AuthError {
};
__name(SessionTokenError, "SessionTokenError");
SessionTokenError.type = "SessionTokenError";
var OAuthSignInError = class extends SignInError {
};
__name(OAuthSignInError, "OAuthSignInError");
OAuthSignInError.type = "OAuthSignInError";
var EmailSignInError = class extends SignInError {
};
__name(EmailSignInError, "EmailSignInError");
EmailSignInError.type = "EmailSignInError";
var SignOutError = class extends AuthError {
};
__name(SignOutError, "SignOutError");
SignOutError.type = "SignOutError";
var UnknownAction = class extends AuthError {
};
__name(UnknownAction, "UnknownAction");
UnknownAction.type = "UnknownAction";
var UnsupportedStrategy = class extends AuthError {
};
__name(UnsupportedStrategy, "UnsupportedStrategy");
UnsupportedStrategy.type = "UnsupportedStrategy";
var InvalidProvider = class extends AuthError {
};
__name(InvalidProvider, "InvalidProvider");
InvalidProvider.type = "InvalidProvider";
var UntrustedHost = class extends AuthError {
};
__name(UntrustedHost, "UntrustedHost");
UntrustedHost.type = "UntrustedHost";
var Verification = class extends AuthError {
};
__name(Verification, "Verification");
Verification.type = "Verification";
var MissingCSRF = class extends SignInError {
};
__name(MissingCSRF, "MissingCSRF");
MissingCSRF.type = "MissingCSRF";
var clientErrors = /* @__PURE__ */ new Set([
  "CredentialsSignin",
  "OAuthAccountNotLinked",
  "OAuthCallbackError",
  "AccessDenied",
  "Verification",
  "MissingCSRF",
  "AccountNotLinked",
  "WebAuthnVerificationError"
]);
function isClientError(error4) {
  if (error4 instanceof AuthError)
    return clientErrors.has(error4.type);
  return false;
}
__name(isClientError, "isClientError");
var DuplicateConditionalUI = class extends AuthError {
};
__name(DuplicateConditionalUI, "DuplicateConditionalUI");
DuplicateConditionalUI.type = "DuplicateConditionalUI";
var MissingWebAuthnAutocomplete = class extends AuthError {
};
__name(MissingWebAuthnAutocomplete, "MissingWebAuthnAutocomplete");
MissingWebAuthnAutocomplete.type = "MissingWebAuthnAutocomplete";
var WebAuthnVerificationError = class extends AuthError {
};
__name(WebAuthnVerificationError, "WebAuthnVerificationError");
WebAuthnVerificationError.type = "WebAuthnVerificationError";
var AccountNotLinked = class extends SignInError {
};
__name(AccountNotLinked, "AccountNotLinked");
AccountNotLinked.type = "AccountNotLinked";
var ExperimentalFeatureNotEnabled = class extends AuthError {
};
__name(ExperimentalFeatureNotEnabled, "ExperimentalFeatureNotEnabled");
ExperimentalFeatureNotEnabled.type = "ExperimentalFeatureNotEnabled";

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/assert.js
var warned = false;
function isValidHttpUrl(url, baseUrl) {
  try {
    return /^https?:/.test(new URL(url, url.startsWith("/") ? baseUrl : void 0).protocol);
  } catch {
    return false;
  }
}
__name(isValidHttpUrl, "isValidHttpUrl");
function isSemverString(version4) {
  return /^v\d+(?:\.\d+){0,2}$/.test(version4);
}
__name(isSemverString, "isSemverString");
var hasCredentials = false;
var hasEmail = false;
var hasWebAuthn = false;
var emailMethods = [
  "createVerificationToken",
  "useVerificationToken",
  "getUserByEmail"
];
var sessionMethods = [
  "createUser",
  "getUser",
  "getUserByEmail",
  "getUserByAccount",
  "updateUser",
  "linkAccount",
  "createSession",
  "getSessionAndUser",
  "updateSession",
  "deleteSession"
];
var webauthnMethods = [
  "createUser",
  "getUser",
  "linkAccount",
  "getAccount",
  "getAuthenticator",
  "createAuthenticator",
  "listAuthenticatorsByUserId",
  "updateAuthenticatorCounter"
];
function assertConfig(request3, options) {
  const { url } = request3;
  const warnings = [];
  if (!warned && options.debug)
    warnings.push("debug-enabled");
  if (!options.trustHost) {
    return new UntrustedHost(`Host must be trusted. URL was: ${request3.url}`);
  }
  if (!options.secret?.length) {
    return new MissingSecret("Please define a `secret`");
  }
  const callbackUrlParam = request3.query?.callbackUrl;
  if (callbackUrlParam && !isValidHttpUrl(callbackUrlParam, url.origin)) {
    return new InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlParam}`);
  }
  const { callbackUrl: defaultCallbackUrl } = defaultCookies(options.useSecureCookies ?? url.protocol === "https:");
  const callbackUrlCookie = request3.cookies?.[options.cookies?.callbackUrl?.name ?? defaultCallbackUrl.name];
  if (callbackUrlCookie && !isValidHttpUrl(callbackUrlCookie, url.origin)) {
    return new InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlCookie}`);
  }
  let hasConditionalUIProvider = false;
  for (const p5 of options.providers) {
    const provider = typeof p5 === "function" ? p5() : p5;
    if ((provider.type === "oauth" || provider.type === "oidc") && !(provider.issuer ?? provider.options?.issuer)) {
      const { authorization: a4, token: t2, userinfo: u3 } = provider;
      let key;
      if (typeof a4 !== "string" && !a4?.url)
        key = "authorization";
      else if (typeof t2 !== "string" && !t2?.url)
        key = "token";
      else if (typeof u3 !== "string" && !u3?.url)
        key = "userinfo";
      if (key) {
        return new InvalidEndpoints(`Provider "${provider.id}" is missing both \`issuer\` and \`${key}\` endpoint config. At least one of them is required`);
      }
    }
    if (provider.type === "credentials")
      hasCredentials = true;
    else if (provider.type === "email")
      hasEmail = true;
    else if (provider.type === "webauthn") {
      hasWebAuthn = true;
      if (provider.simpleWebAuthnBrowserVersion && !isSemverString(provider.simpleWebAuthnBrowserVersion)) {
        return new AuthError(`Invalid provider config for "${provider.id}": simpleWebAuthnBrowserVersion "${provider.simpleWebAuthnBrowserVersion}" must be a valid semver string.`);
      }
      if (provider.enableConditionalUI) {
        if (hasConditionalUIProvider) {
          return new DuplicateConditionalUI(`Multiple webauthn providers have 'enableConditionalUI' set to True. Only one provider can have this option enabled at a time`);
        }
        hasConditionalUIProvider = true;
        const hasWebauthnFormField = Object.values(provider.formFields).some((f4) => f4.autocomplete && f4.autocomplete.toString().indexOf("webauthn") > -1);
        if (!hasWebauthnFormField) {
          return new MissingWebAuthnAutocomplete(`Provider "${provider.id}" has 'enableConditionalUI' set to True, but none of its formFields have 'webauthn' in their autocomplete param`);
        }
      }
    }
  }
  if (hasCredentials) {
    const dbStrategy = options.session?.strategy === "database";
    const onlyCredentials = !options.providers.some((p5) => (typeof p5 === "function" ? p5() : p5).type !== "credentials");
    if (dbStrategy && onlyCredentials) {
      return new UnsupportedStrategy("Signing in with credentials only supported if JWT strategy is enabled");
    }
    const credentialsNoAuthorize = options.providers.some((p5) => {
      const provider = typeof p5 === "function" ? p5() : p5;
      return provider.type === "credentials" && !provider.authorize;
    });
    if (credentialsNoAuthorize) {
      return new MissingAuthorize("Must define an authorize() handler to use credentials authentication provider");
    }
  }
  const { adapter, session: session2 } = options;
  const requiredMethods = [];
  if (hasEmail || session2?.strategy === "database" || !session2?.strategy && adapter) {
    if (hasEmail) {
      if (!adapter)
        return new MissingAdapter("Email login requires an adapter");
      requiredMethods.push(...emailMethods);
    } else {
      if (!adapter)
        return new MissingAdapter("Database session requires an adapter");
      requiredMethods.push(...sessionMethods);
    }
  }
  if (hasWebAuthn) {
    if (options.experimental?.enableWebAuthn) {
      warnings.push("experimental-webauthn");
    } else {
      return new ExperimentalFeatureNotEnabled("WebAuthn is an experimental feature. To enable it, set `experimental.enableWebAuthn` to `true` in your config");
    }
    if (!adapter)
      return new MissingAdapter("WebAuthn requires an adapter");
    requiredMethods.push(...webauthnMethods);
  }
  if (adapter) {
    const missing = requiredMethods.filter((m5) => !(m5 in adapter));
    if (missing.length) {
      return new MissingAdapterMethods(`Required adapter methods were missing: ${missing.join(", ")}`);
    }
  }
  if (!warned)
    warned = true;
  return warnings;
}
__name(assertConfig, "assertConfig");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/init.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/jwt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@panva+hkdf@1.2.1/node_modules/@panva/hkdf/dist/web/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@panva+hkdf@1.2.1/node_modules/@panva/hkdf/dist/web/runtime/hkdf.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var getGlobal2 = /* @__PURE__ */ __name(() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  throw new Error("unable to locate global object");
}, "getGlobal");
var hkdf_default = /* @__PURE__ */ __name(async (digest2, ikm, salt, info3, keylen) => {
  const { crypto: { subtle: subtle3 } } = getGlobal2();
  return new Uint8Array(await subtle3.deriveBits({
    name: "HKDF",
    hash: `SHA-${digest2.substr(3)}`,
    salt,
    info: info3
  }, await subtle3.importKey("raw", ikm, "HKDF", false, ["deriveBits"]), keylen << 3));
}, "default");

// node_modules/.pnpm/@panva+hkdf@1.2.1/node_modules/@panva/hkdf/dist/web/index.js
function normalizeDigest(digest2) {
  switch (digest2) {
    case "sha256":
    case "sha384":
    case "sha512":
    case "sha1":
      return digest2;
    default:
      throw new TypeError('unsupported "digest" value');
  }
}
__name(normalizeDigest, "normalizeDigest");
function normalizeUint8Array(input, label) {
  if (typeof input === "string")
    return new TextEncoder().encode(input);
  if (!(input instanceof Uint8Array))
    throw new TypeError(`"${label}"" must be an instance of Uint8Array or a string`);
  return input;
}
__name(normalizeUint8Array, "normalizeUint8Array");
function normalizeIkm(input) {
  const ikm = normalizeUint8Array(input, "ikm");
  if (!ikm.byteLength)
    throw new TypeError(`"ikm" must be at least one byte in length`);
  return ikm;
}
__name(normalizeIkm, "normalizeIkm");
function normalizeInfo(input) {
  const info3 = normalizeUint8Array(input, "info");
  if (info3.byteLength > 1024) {
    throw TypeError('"info" must not contain more than 1024 bytes');
  }
  return info3;
}
__name(normalizeInfo, "normalizeInfo");
function normalizeKeylen(input, digest2) {
  if (typeof input !== "number" || !Number.isInteger(input) || input < 1) {
    throw new TypeError('"keylen" must be a positive integer');
  }
  const hashlen = parseInt(digest2.substr(3), 10) >> 3 || 20;
  if (input > 255 * hashlen) {
    throw new TypeError('"keylen" too large');
  }
  return input;
}
__name(normalizeKeylen, "normalizeKeylen");
async function hkdf3(digest2, ikm, salt, info3, keylen) {
  return hkdf_default(normalizeDigest(digest2), normalizeIkm(ikm), normalizeUint8Array(salt, "salt"), normalizeInfo(info3), normalizeKeylen(keylen, digest2));
}
__name(hkdf3, "hkdf");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/compact/decrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/flattened/decrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/base64url.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/buffer_utils.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/digest.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/webcrypto.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var webcrypto_default = crypto;
var isCryptoKey = /* @__PURE__ */ __name((key) => key instanceof CryptoKey, "isCryptoKey");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/digest.js
var digest = /* @__PURE__ */ __name(async (algorithm, data) => {
  const subtleDigest = `SHA-${algorithm.slice(-3)}`;
  return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
}, "digest");
var digest_default = digest;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf2 = new Uint8Array(size);
  let i3 = 0;
  for (const buffer of buffers) {
    buf2.set(buffer, i3);
    i3 += buffer.length;
  }
  return buf2;
}
__name(concat, "concat");
function p2s(alg2, p2sInput) {
  return concat(encoder.encode(alg2), new Uint8Array([0]), p2sInput);
}
__name(p2s, "p2s");
function writeUInt32BE(buf2, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf2.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
__name(writeUInt32BE, "writeUInt32BE");
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf2 = new Uint8Array(8);
  writeUInt32BE(buf2, high, 0);
  writeUInt32BE(buf2, low, 4);
  return buf2;
}
__name(uint64be, "uint64be");
function uint32be(value) {
  const buf2 = new Uint8Array(4);
  writeUInt32BE(buf2, value);
  return buf2;
}
__name(uint32be, "uint32be");
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
__name(lengthAndInput, "lengthAndInput");
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf2 = new Uint8Array(4 + secret.length + value.length);
    buf2.set(uint32be(iter + 1));
    buf2.set(secret, 4);
    buf2.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf2), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
__name(concatKdf, "concatKdf");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = /* @__PURE__ */ __name((input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE3 = 32768;
  const arr = [];
  for (let i3 = 0; i3 < unencoded.length; i3 += CHUNK_SIZE3) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i3, i3 + CHUNK_SIZE3)));
  }
  return btoa(arr.join(""));
}, "encodeBase64");
var encode2 = /* @__PURE__ */ __name((input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}, "encode");
var decodeBase64 = /* @__PURE__ */ __name((encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i3 = 0; i3 < binary.length; i3++) {
    bytes[i3] = binary.charCodeAt(i3);
  }
  return bytes;
}, "decodeBase64");
var decode2 = /* @__PURE__ */ __name((input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}, "decode");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/decrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/check_iv_length.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/util/errors.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
__name(JOSEError, "JOSEError");
var JWTClaimValidationFailed = class extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
__name(JWTClaimValidationFailed, "JWTClaimValidationFailed");
var JWTExpired = class extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
__name(JWTExpired, "JWTExpired");
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
__name(JOSEAlgNotAllowed, "JOSEAlgNotAllowed");
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
__name(JOSENotSupported, "JOSENotSupported");
var JWEDecryptionFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
    this.message = "decryption operation failed";
  }
  static get code() {
    return "ERR_JWE_DECRYPTION_FAILED";
  }
};
__name(JWEDecryptionFailed, "JWEDecryptionFailed");
var JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
  static get code() {
    return "ERR_JWE_INVALID";
  }
};
__name(JWEInvalid, "JWEInvalid");
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
__name(JWTInvalid, "JWTInvalid");
var JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
  static get code() {
    return "ERR_JWK_INVALID";
  }
};
__name(JWKInvalid, "JWKInvalid");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/iv.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/random.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg2) {
  switch (alg2) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg2}`);
  }
}
__name(bitLength, "bitLength");
var iv_default = /* @__PURE__ */ __name((alg2) => random_default(new Uint8Array(bitLength(alg2) >> 3)), "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength = /* @__PURE__ */ __name((enc2, iv) => {
  if (iv.length << 3 !== bitLength(enc2)) {
    throw new JWEInvalid("Invalid Initialization Vector length");
  }
}, "checkIvLength");
var check_iv_length_default = checkIvLength;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/check_cek_length.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var checkCekLength = /* @__PURE__ */ __name((cek, expected) => {
  const actual = cek.byteLength << 3;
  if (actual !== expected) {
    throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
  }
}, "checkCekLength");
var check_cek_length_default = checkCekLength;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/timing_safe_equal.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var timingSafeEqual3 = /* @__PURE__ */ __name((a4, b3) => {
  if (!(a4 instanceof Uint8Array)) {
    throw new TypeError("First argument must be a buffer");
  }
  if (!(b3 instanceof Uint8Array)) {
    throw new TypeError("Second argument must be a buffer");
  }
  if (a4.length !== b3.length) {
    throw new TypeError("Input buffers must have the same length");
  }
  const len = a4.length;
  let out = 0;
  let i3 = -1;
  while (++i3 < len) {
    out |= a4[i3] ^ b3[i3];
  }
  return out === 0;
}, "timingSafeEqual");
var timing_safe_equal_default = timingSafeEqual3;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/crypto_key.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
__name(unusable, "unusable");
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
__name(isAlgorithm, "isAlgorithm");
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
__name(getHashLength, "getHashLength");
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
__name(checkUsage, "checkUsage");
function checkEncCryptoKey(key, alg2, ...usages) {
  switch (alg2) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg2.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg2.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg2.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
__name(checkEncCryptoKey, "checkEncCryptoKey");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/invalid_key_input.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function message(msg, actual, ...types2) {
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
__name(message, "message");
var invalid_key_input_default = /* @__PURE__ */ __name((actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
}, "default");
function withAlg(alg2, actual, ...types2) {
  return message(`Key for the ${alg2} algorithm must be `, actual, ...types2);
}
__name(withAlg, "withAlg");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/is_key_like.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var is_key_like_default = /* @__PURE__ */ __name((key) => {
  if (isCryptoKey(key)) {
    return true;
  }
  return key?.[Symbol.toStringTag] === "KeyObject";
}, "default");
var types = ["CryptoKey"];

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc2, cek, ciphertext, iv, tag2, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc2.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag2, expectedTag);
  } catch {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
__name(cbcDecrypt, "cbcDecrypt");
async function gcmDecrypt(enc2, cek, ciphertext, iv, tag2, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc2, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag2)));
  } catch {
    throw new JWEDecryptionFailed();
  }
}
__name(gcmDecrypt, "gcmDecrypt");
var decrypt = /* @__PURE__ */ __name(async (enc2, cek, ciphertext, iv, tag2, aad) => {
  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
  }
  if (!iv) {
    throw new JWEInvalid("JWE Initialization Vector missing");
  }
  if (!tag2) {
    throw new JWEInvalid("JWE Authentication Tag missing");
  }
  check_iv_length_default(enc2, iv);
  switch (enc2) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      if (cek instanceof Uint8Array)
        check_cek_length_default(cek, parseInt(enc2.slice(-3), 10));
      return cbcDecrypt(enc2, cek, ciphertext, iv, tag2, aad);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      if (cek instanceof Uint8Array)
        check_cek_length_default(cek, parseInt(enc2.slice(1, 4), 10));
      return gcmDecrypt(enc2, cek, ciphertext, iv, tag2, aad);
    default:
      throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
  }
}, "decrypt");
var decrypt_default = decrypt;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/is_disjoint.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var isDisjoint = /* @__PURE__ */ __name((...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}, "isDisjoint");
var is_disjoint_default = isDisjoint;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/is_object.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
__name(isObjectLike, "isObjectLike");
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
__name(isObject, "isObject");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/decrypt_key_management.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/aeskw.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/bogus.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var bogusWebCrypto = [
  { hash: "SHA-256", name: "HMAC" },
  true,
  ["sign"]
];
var bogus_default = bogusWebCrypto;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg2) {
  if (key.algorithm.length !== parseInt(alg2.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg2}`);
  }
}
__name(checkKeySize, "checkKeySize");
function getCryptoKey(key, alg2, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg2, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
__name(getCryptoKey, "getCryptoKey");
var wrap = /* @__PURE__ */ __name(async (alg2, key, cek) => {
  const cryptoKey = await getCryptoKey(key, alg2, "wrapKey");
  checkKeySize(cryptoKey, alg2);
  const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
  return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
}, "wrap");
var unwrap = /* @__PURE__ */ __name(async (alg2, key, encryptedKey) => {
  const cryptoKey = await getCryptoKey(key, alg2, "unwrapKey");
  checkKeySize(cryptoKey, alg2);
  const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
  return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
}, "unwrap");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/ecdhes.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
__name(deriveKey, "deriveKey");
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
__name(generateEpk, "generateEpk");
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
__name(ecdhAllowed, "ecdhAllowed");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/pbes2kw.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/check_p2s.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
__name(checkP2s, "checkP2s");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg2) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg2, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
__name(getCryptoKey2, "getCryptoKey");
async function deriveKey2(p2s2, alg2, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg2, p2s2);
  const keylen = parseInt(alg2.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg2.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg2);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
__name(deriveKey2, "deriveKey");
var encrypt = /* @__PURE__ */ __name(async (alg2, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
  const derived = await deriveKey2(p2s2, alg2, p2c, key);
  const encryptedKey = await wrap(alg2.slice(-6), derived, cek);
  return { encryptedKey, p2c, p2s: encode2(p2s2) };
}, "encrypt");
var decrypt2 = /* @__PURE__ */ __name(async (alg2, key, encryptedKey, p2c, p2s2) => {
  const derived = await deriveKey2(p2s2, alg2, p2c, key);
  return unwrap(alg2.slice(-6), derived, encryptedKey);
}, "decrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/rsaes.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/subtle_rsaes.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function subtleRsaEs(alg2) {
  switch (alg2) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg2} is not supported either by JOSE or your javascript runtime`);
  }
}
__name(subtleRsaEs, "subtleRsaEs");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/check_key_length.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var check_key_length_default = /* @__PURE__ */ __name((alg2, key) => {
  if (alg2.startsWith("RS") || alg2.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg2} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}, "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2 = /* @__PURE__ */ __name(async (alg2, key, cek) => {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  checkEncCryptoKey(key, alg2, "encrypt", "wrapKey");
  check_key_length_default(alg2, key);
  if (key.usages.includes("encrypt")) {
    return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg2), key, cek));
  }
  if (key.usages.includes("wrapKey")) {
    const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
    return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg2)));
  }
  throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
}, "encrypt");
var decrypt3 = /* @__PURE__ */ __name(async (alg2, key, encryptedKey) => {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  checkEncCryptoKey(key, alg2, "decrypt", "unwrapKey");
  check_key_length_default(alg2, key);
  if (key.usages.includes("decrypt")) {
    return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg2), key, encryptedKey));
  }
  if (key.usages.includes("unwrapKey")) {
    const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg2), ...bogus_default);
    return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
  }
  throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
}, "decrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/normalize_key.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/is_jwk.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function isJWK(key) {
  return isObject(key) && typeof key.kty === "string";
}
__name(isJWK, "isJWK");
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
__name(isPrivateJWK, "isPrivateJWK");
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
__name(isPublicJWK, "isPublicJWK");
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}
__name(isSecretJWK, "isSecretJWK");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/jwk_to_key.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
__name(subtleMapping, "subtleMapping");
var parse2 = /* @__PURE__ */ __name(async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    jwk.ext ?? false,
    jwk.key_ops ?? keyUsages
  ];
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
}, "parse");
var jwk_to_key_default = parse2;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/normalize_key.js
var exportKeyValue = /* @__PURE__ */ __name((k3) => decode2(k3), "exportKeyValue");
var privCache;
var pubCache;
var isKeyObject = /* @__PURE__ */ __name((key) => {
  return key?.[Symbol.toStringTag] === "KeyObject";
}, "isKeyObject");
var importAndCache = /* @__PURE__ */ __name(async (cache, key, jwk, alg2, freeze = false) => {
  let cached = cache.get(key);
  if (cached?.[alg2]) {
    return cached[alg2];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg: alg2 });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache.set(key, { [alg2]: cryptoKey });
  } else {
    cached[alg2] = cryptoKey;
  }
  return cryptoKey;
}, "importAndCache");
var normalizePublicKey = /* @__PURE__ */ __name((key, alg2) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    delete jwk.d;
    delete jwk.dp;
    delete jwk.dq;
    delete jwk.p;
    delete jwk.q;
    delete jwk.qi;
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(pubCache, key, jwk, alg2);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode2(key.k);
    pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
    const cryptoKey = importAndCache(pubCache, key, key, alg2, true);
    return cryptoKey;
  }
  return key;
}, "normalizePublicKey");
var normalizePrivateKey = /* @__PURE__ */ __name((key, alg2) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    privCache || (privCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(privCache, key, jwk, alg2);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode2(key.k);
    privCache || (privCache = /* @__PURE__ */ new WeakMap());
    const cryptoKey = importAndCache(privCache, key, key, alg2, true);
    return cryptoKey;
  }
  return key;
}, "normalizePrivateKey");
var normalize_key_default = { normalizePublicKey, normalizePrivateKey };

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/cek.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function bitLength2(alg2) {
  switch (alg2) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg2}`);
  }
}
__name(bitLength2, "bitLength");
var cek_default = /* @__PURE__ */ __name((alg2) => random_default(new Uint8Array(bitLength2(alg2) >> 3)), "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/key/import.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function importJWK(jwk, alg2) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg2 || (alg2 = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode2(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg: alg2 });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
__name(importJWK, "importJWK");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/check_key_type.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var tag = /* @__PURE__ */ __name((key) => key?.[Symbol.toStringTag], "tag");
var jwkMatchesOp = /* @__PURE__ */ __name((alg2, key, usage) => {
  if (key.use !== void 0 && key.use !== "sig") {
    throw new TypeError("Invalid key for this operation, when present its use must be sig");
  }
  if (key.key_ops !== void 0 && key.key_ops.includes?.(usage) !== true) {
    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
  }
  if (key.alg !== void 0 && key.alg !== alg2) {
    throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg2}`);
  }
  return true;
}, "jwkMatchesOp");
var symmetricTypeCheck = /* @__PURE__ */ __name((alg2, key, usage, allowJwk) => {
  if (key instanceof Uint8Array)
    return;
  if (allowJwk && isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg2, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg2, key, ...types, "Uint8Array", allowJwk ? "JSON Web Key" : null));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
}, "symmetricTypeCheck");
var asymmetricTypeCheck = /* @__PURE__ */ __name((alg2, key, usage, allowJwk) => {
  if (allowJwk && isJWK(key)) {
    switch (usage) {
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg2, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg2, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg2, key, ...types, allowJwk ? "JSON Web Key" : null));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
}, "asymmetricTypeCheck");
function checkKeyType(allowJwk, alg2, key, usage) {
  const symmetric = alg2.startsWith("HS") || alg2 === "dir" || alg2.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg2);
  if (symmetric) {
    symmetricTypeCheck(alg2, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg2, key, usage, allowJwk);
  }
}
__name(checkKeyType, "checkKeyType");
var check_key_type_default = checkKeyType.bind(void 0, false);
var checkKeyTypeWithJwk = checkKeyType.bind(void 0, true);

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/aesgcmkw.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/encrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function cbcEncrypt(enc2, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc2.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag2 = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag: tag2, iv };
}
__name(cbcEncrypt, "cbcEncrypt");
async function gcmEncrypt(enc2, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc2, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag2 = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag: tag2, iv };
}
__name(gcmEncrypt, "gcmEncrypt");
var encrypt3 = /* @__PURE__ */ __name(async (enc2, plaintext, cek, iv, aad) => {
  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
  }
  if (iv) {
    check_iv_length_default(enc2, iv);
  } else {
    iv = iv_default(enc2);
  }
  switch (enc2) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      if (cek instanceof Uint8Array) {
        check_cek_length_default(cek, parseInt(enc2.slice(-3), 10));
      }
      return cbcEncrypt(enc2, plaintext, cek, iv, aad);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      if (cek instanceof Uint8Array) {
        check_cek_length_default(cek, parseInt(enc2.slice(1, 4), 10));
      }
      return gcmEncrypt(enc2, plaintext, cek, iv, aad);
    default:
      throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
  }
}, "encrypt");
var encrypt_default = encrypt3;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg2, key, cek, iv) {
  const jweAlgorithm = alg2.slice(0, 7);
  const wrapped = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return {
    encryptedKey: wrapped.ciphertext,
    iv: encode2(wrapped.iv),
    tag: encode2(wrapped.tag)
  };
}
__name(wrap2, "wrap");
async function unwrap2(alg2, key, encryptedKey, iv, tag2) {
  const jweAlgorithm = alg2.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag2, new Uint8Array(0));
}
__name(unwrap2, "unwrap");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg2, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg2, key, "decrypt");
  key = await normalize_key_default.normalizePrivateKey?.(key, alg2) || key;
  switch (alg2) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg2);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode2(joseHeader.apu);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode2(joseHeader.apv);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg2 === "ECDH-ES" ? joseHeader.enc : alg2, alg2 === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg2.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg2 === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg2.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg2, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = options?.maxPBES2Count || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode2(joseHeader.p2s);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg2, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg2, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode2(joseHeader.iv);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag2;
      try {
        tag2 = decode2(joseHeader.tag);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg2, key, encryptedKey, iv, tag2);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
__name(decryptKeyManagement, "decryptKeyManagement");
var decrypt_key_management_default = decryptKeyManagement;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/validate_crit.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
__name(validateCrit, "validateCrit");
var validate_crit_default = validateCrit;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/validate_algorithms.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var validateAlgorithms = /* @__PURE__ */ __name((option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s3) => typeof s3 !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
}, "validateAlgorithms");
var validate_algorithms_default = validateAlgorithms;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (jwe.iv !== void 0 && typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (jwe.tag !== void 0 && typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode2(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options?.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
  }
  const { alg: alg2, enc: enc2 } = joseHeader;
  if (typeof alg2 !== "string" || !alg2) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc2 !== "string" || !enc2) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg2) || !keyManagementAlgorithms && alg2.startsWith("PBES2")) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc2)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter value not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode2(jwe.encrypted_key);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg2, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc2);
  }
  let iv;
  let tag2;
  if (jwe.iv !== void 0) {
    try {
      iv = decode2(jwe.iv);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the iv");
    }
  }
  if (jwe.tag !== void 0) {
    try {
      tag2 = decode2(jwe.tag);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the tag");
    }
  }
  const protectedHeader = encoder.encode(jwe.protected ?? "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode2(jwe.ciphertext);
  } catch {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  const plaintext = await decrypt_default(enc2, cek, ciphertext, iv, tag2, additionalData);
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode2(jwe.aad);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
__name(flattenedDecrypt, "flattenedDecrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag2, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader,
    tag: tag2 || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
__name(compactDecrypt, "compactDecrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/flattened/encrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/private_symbols.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var unprotected = Symbol();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/encrypt_key_management.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/key/export.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/runtime/key_to_jwk.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var keyToJWK = /* @__PURE__ */ __name(async (key) => {
  if (key instanceof Uint8Array) {
    return {
      kty: "oct",
      k: encode2(key)
    };
  }
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
  }
  if (!key.extractable) {
    throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
  }
  const { ext, key_ops, alg: alg2, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
  return jwk;
}, "keyToJWK");
var key_to_jwk_default = keyToJWK;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/key/export.js
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
__name(exportJWK, "exportJWK");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg2, enc2, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg2, key, "encrypt");
  key = await normalize_key_default.normalizePublicKey?.(key, alg2) || key;
  switch (alg2) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x: x3, y: y3, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg2 === "ECDH-ES" ? enc2 : alg2, alg2 === "ECDH-ES" ? bitLength2(enc2) : parseInt(alg2.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x: x3, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y3;
      if (apu)
        parameters.apu = encode2(apu);
      if (apv)
        parameters.apv = encode2(apv);
      if (alg2 === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc2);
      const kwAlg = alg2.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc2);
      encryptedKey = await encrypt2(alg2, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc2);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg2, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc2);
      encryptedKey = await wrap(alg2, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc2);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg2, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
__name(encryptKeyManagement, "encryptKeyManagement");
var encrypt_key_management_default = encryptKeyManagement;

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var FlattenedEncrypt = class {
  constructor(plaintext) {
    if (!(plaintext instanceof Uint8Array)) {
      throw new TypeError("plaintext must be an instance of Uint8Array");
    }
    this._plaintext = plaintext;
  }
  setKeyManagementParameters(parameters) {
    if (this._keyManagementParameters) {
      throw new TypeError("setKeyManagementParameters can only be called once");
    }
    this._keyManagementParameters = parameters;
    return this;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setSharedUnprotectedHeader(sharedUnprotectedHeader) {
    if (this._sharedUnprotectedHeader) {
      throw new TypeError("setSharedUnprotectedHeader can only be called once");
    }
    this._sharedUnprotectedHeader = sharedUnprotectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  setAdditionalAuthenticatedData(aad) {
    this._aad = aad;
    return this;
  }
  setContentEncryptionKey(cek) {
    if (this._cek) {
      throw new TypeError("setContentEncryptionKey can only be called once");
    }
    this._cek = cek;
    return this;
  }
  setInitializationVector(iv) {
    if (this._iv) {
      throw new TypeError("setInitializationVector can only be called once");
    }
    this._iv = iv;
    return this;
  }
  async encrypt(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
      throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
      throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader,
      ...this._sharedUnprotectedHeader
    };
    validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options?.crit, this._protectedHeader, joseHeader);
    if (joseHeader.zip !== void 0) {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
    }
    const { alg: alg2, enc: enc2 } = joseHeader;
    if (typeof alg2 !== "string" || !alg2) {
      throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
    }
    if (typeof enc2 !== "string" || !enc2) {
      throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
    }
    let encryptedKey;
    if (this._cek && (alg2 === "dir" || alg2 === "ECDH-ES")) {
      throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${alg2}`);
    }
    let cek;
    {
      let parameters;
      ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg2, enc2, key, this._cek, this._keyManagementParameters));
      if (parameters) {
        if (options && unprotected in options) {
          if (!this._unprotectedHeader) {
            this.setUnprotectedHeader(parameters);
          } else {
            this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
          }
        } else if (!this._protectedHeader) {
          this.setProtectedHeader(parameters);
        } else {
          this._protectedHeader = { ...this._protectedHeader, ...parameters };
        }
      }
    }
    let additionalData;
    let protectedHeader;
    let aadMember;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    if (this._aad) {
      aadMember = encode2(this._aad);
      additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
    } else {
      additionalData = protectedHeader;
    }
    const { ciphertext, tag: tag2, iv } = await encrypt_default(enc2, this._plaintext, cek, this._iv, additionalData);
    const jwe = {
      ciphertext: encode2(ciphertext)
    };
    if (iv) {
      jwe.iv = encode2(iv);
    }
    if (tag2) {
      jwe.tag = encode2(tag2);
    }
    if (encryptedKey) {
      jwe.encrypted_key = encode2(encryptedKey);
    }
    if (aadMember) {
      jwe.aad = aadMember;
    }
    if (this._protectedHeader) {
      jwe.protected = decoder.decode(protectedHeader);
    }
    if (this._sharedUnprotectedHeader) {
      jwe.unprotected = this._sharedUnprotectedHeader;
    }
    if (this._unprotectedHeader) {
      jwe.header = this._unprotectedHeader;
    }
    return jwe;
  }
};
__name(FlattenedEncrypt, "FlattenedEncrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/jwt_claims_set.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/epoch.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var epoch_default = /* @__PURE__ */ __name((date) => Math.floor(date.getTime() / 1e3), "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/secs.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = /* @__PURE__ */ __name((str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}, "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = /* @__PURE__ */ __name((value) => value.toLowerCase().replace(/^application\//, ""), "normalizeTyp");
var checkAudiencePresence = /* @__PURE__ */ __name((audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
}, "checkAudiencePresence");
var jwt_claims_set_default = /* @__PURE__ */ __name((protectedHeader, encodedPayload, options = {}) => {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now2 = epoch_default(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now2 + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now2 - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now2 - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}, "default");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwt/decrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function jwtDecrypt(jwt2, key, options) {
  const decrypted = await compactDecrypt(jwt2, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', payload, "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', payload, "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', payload, "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
__name(jwtDecrypt, "jwtDecrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwe/compact/encrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var CompactEncrypt = class {
  constructor(plaintext) {
    this._flattened = new FlattenedEncrypt(plaintext);
  }
  setContentEncryptionKey(cek) {
    this._flattened.setContentEncryptionKey(cek);
    return this;
  }
  setInitializationVector(iv) {
    this._flattened.setInitializationVector(iv);
    return this;
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  setKeyManagementParameters(parameters) {
    this._flattened.setKeyManagementParameters(parameters);
    return this;
  }
  async encrypt(key, options) {
    const jwe = await this._flattened.encrypt(key, options);
    return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
  }
};
__name(CompactEncrypt, "CompactEncrypt");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwt/produce.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
__name(validateInput, "validateInput");
var ProduceJWT = class {
  constructor(payload = {}) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
    } else if (typeof input === "string") {
      this._payload = {
        ...this._payload,
        iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
      };
    } else {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
    }
    return this;
  }
};
__name(ProduceJWT, "ProduceJWT");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwt/encrypt.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var EncryptJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setKeyManagementParameters(parameters) {
    if (this._keyManagementParameters) {
      throw new TypeError("setKeyManagementParameters can only be called once");
    }
    this._keyManagementParameters = parameters;
    return this;
  }
  setContentEncryptionKey(cek) {
    if (this._cek) {
      throw new TypeError("setContentEncryptionKey can only be called once");
    }
    this._cek = cek;
    return this;
  }
  setInitializationVector(iv) {
    if (this._iv) {
      throw new TypeError("setInitializationVector can only be called once");
    }
    this._iv = iv;
    return this;
  }
  replicateIssuerAsHeader() {
    this._replicateIssuerAsHeader = true;
    return this;
  }
  replicateSubjectAsHeader() {
    this._replicateSubjectAsHeader = true;
    return this;
  }
  replicateAudienceAsHeader() {
    this._replicateAudienceAsHeader = true;
    return this;
  }
  async encrypt(key, options) {
    const enc2 = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
    if (this._replicateIssuerAsHeader) {
      this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
    }
    if (this._replicateSubjectAsHeader) {
      this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
    }
    if (this._replicateAudienceAsHeader) {
      this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
    }
    enc2.setProtectedHeader(this._protectedHeader);
    if (this._iv) {
      enc2.setInitializationVector(this._iv);
    }
    if (this._cek) {
      enc2.setContentEncryptionKey(this._cek);
    }
    if (this._keyManagementParameters) {
      enc2.setKeyManagementParameters(this._keyManagementParameters);
    }
    return enc2.encrypt(key, options);
  }
};
__name(EncryptJWT, "EncryptJWT");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/jwk/thumbprint.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var check = /* @__PURE__ */ __name((value, description) => {
  if (typeof value !== "string" || !value) {
    throw new JWKInvalid(`${description} missing or invalid`);
  }
}, "check");
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm ?? (digestAlgorithm = "sha256");
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode2(await digest_default(digestAlgorithm, data));
}
__name(calculateJwkThumbprint, "calculateJwkThumbprint");

// node_modules/.pnpm/jose@5.9.3/node_modules/jose/dist/browser/util/base64url.js
var base64url_exports = {};
__export(base64url_exports, {
  decode: () => decode3,
  encode: () => encode3
});
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var encode3 = encode2;
var decode3 = decode2;

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/jwt.js
var import_cookie3 = __toESM(require_cookie(), 1);
var DEFAULT_MAX_AGE = 30 * 24 * 60 * 60;
var now = /* @__PURE__ */ __name(() => Date.now() / 1e3 | 0, "now");
var alg = "dir";
var enc = "A256CBC-HS512";
async function encode4(params) {
  const { token = {}, secret, maxAge = DEFAULT_MAX_AGE, salt } = params;
  const secrets = Array.isArray(secret) ? secret : [secret];
  const encryptionSecret = await getDerivedEncryptionKey(enc, secrets[0], salt);
  const thumbprint = await calculateJwkThumbprint({ kty: "oct", k: base64url_exports.encode(encryptionSecret) }, `sha${encryptionSecret.byteLength << 3}`);
  return await new EncryptJWT(token).setProtectedHeader({ alg, enc, kid: thumbprint }).setIssuedAt().setExpirationTime(now() + maxAge).setJti(crypto.randomUUID()).encrypt(encryptionSecret);
}
__name(encode4, "encode");
async function decode4(params) {
  const { token, secret, salt } = params;
  const secrets = Array.isArray(secret) ? secret : [secret];
  if (!token)
    return null;
  const { payload } = await jwtDecrypt(token, async ({ kid, enc: enc2 }) => {
    for (const secret2 of secrets) {
      const encryptionSecret = await getDerivedEncryptionKey(enc2, secret2, salt);
      if (kid === void 0)
        return encryptionSecret;
      const thumbprint = await calculateJwkThumbprint({ kty: "oct", k: base64url_exports.encode(encryptionSecret) }, `sha${encryptionSecret.byteLength << 3}`);
      if (kid === thumbprint)
        return encryptionSecret;
    }
    throw new Error("no matching decryption secret");
  }, {
    clockTolerance: 15,
    keyManagementAlgorithms: [alg],
    contentEncryptionAlgorithms: [enc, "A256GCM"]
  });
  return payload;
}
__name(decode4, "decode");
async function getDerivedEncryptionKey(enc2, keyMaterial, salt) {
  let length;
  switch (enc2) {
    case "A256CBC-HS512":
      length = 64;
      break;
    case "A256GCM":
      length = 32;
      break;
    default:
      throw new Error("Unsupported JWT Content Encryption Algorithm");
  }
  return await hkdf3("sha256", keyMaterial, salt, `Auth.js Generated Encryption Key (${salt})`, length);
}
__name(getDerivedEncryptionKey, "getDerivedEncryptionKey");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/callback-url.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function createCallbackUrl({ options, paramValue, cookieValue }) {
  const { url, callbacks } = options;
  let callbackUrl = url.origin;
  if (paramValue) {
    callbackUrl = await callbacks.redirect({
      url: paramValue,
      baseUrl: url.origin
    });
  } else if (cookieValue) {
    callbackUrl = await callbacks.redirect({
      url: cookieValue,
      baseUrl: url.origin
    });
  }
  return {
    callbackUrl,
    // Save callback URL in a cookie so that it can be used for subsequent requests in signin/signout/callback flow
    callbackUrlCookie: callbackUrl !== cookieValue ? callbackUrl : void 0
  };
}
__name(createCallbackUrl, "createCallbackUrl");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/csrf-token.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/web.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var import_cookie4 = __toESM(require_cookie(), 1);

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/logger.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var red = "\x1B[31m";
var yellow = "\x1B[33m";
var grey = "\x1B[90m";
var reset = "\x1B[0m";
var defaultLogger = {
  error(error4) {
    const name = error4 instanceof AuthError ? error4.type : error4.name;
    console.error(`${red}[auth][error]${reset} ${name}: ${error4.message}`);
    if (error4.cause && typeof error4.cause === "object" && "err" in error4.cause && error4.cause.err instanceof Error) {
      const { err, ...data } = error4.cause;
      console.error(`${red}[auth][cause]${reset}:`, err.stack);
      if (data)
        console.error(`${red}[auth][details]${reset}:`, JSON.stringify(data, null, 2));
    } else if (error4.stack) {
      console.error(error4.stack.replace(/.*/, "").substring(1));
    }
  },
  warn(code) {
    const url = `https://warnings.authjs.dev#${code}`;
    console.warn(`${yellow}[auth][warn][${code}]${reset}`, `Read more: ${url}`);
  },
  debug(message2, metadata) {
    console.log(`${grey}[auth][debug]:${reset} ${message2}`, JSON.stringify(metadata, null, 2));
  }
};
function setLogger(config2) {
  const newLogger = {
    ...defaultLogger
  };
  if (!config2.debug)
    newLogger.debug = () => {
    };
  if (config2.logger?.error)
    newLogger.error = config2.logger.error;
  if (config2.logger?.warn)
    newLogger.warn = config2.logger.warn;
  if (config2.logger?.debug)
    newLogger.debug = config2.logger.debug;
  config2.logger ?? (config2.logger = newLogger);
  return newLogger;
}
__name(setLogger, "setLogger");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/actions.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var actions = [
  "providers",
  "session",
  "csrf",
  "signin",
  "signout",
  "callback",
  "verify-request",
  "error",
  "webauthn-options"
];
function isAuthAction(action) {
  return actions.includes(action);
}
__name(isAuthAction, "isAuthAction");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/web.js
async function getBody(req) {
  if (!("body" in req) || !req.body || req.method !== "POST")
    return;
  const contentType = req.headers.get("content-type");
  if (contentType?.includes("application/json")) {
    return await req.json();
  } else if (contentType?.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams(await req.text());
    return Object.fromEntries(params);
  }
}
__name(getBody, "getBody");
async function toInternalRequest(req, config2) {
  try {
    if (req.method !== "GET" && req.method !== "POST")
      throw new UnknownAction("Only GET and POST requests are supported");
    config2.basePath ?? (config2.basePath = "/auth");
    const url = new URL(req.url);
    const { action, providerId } = parseActionAndProviderId(url.pathname, config2.basePath);
    return {
      url,
      action,
      providerId,
      method: req.method,
      headers: Object.fromEntries(req.headers),
      body: req.body ? await getBody(req) : void 0,
      cookies: (0, import_cookie4.parse)(req.headers.get("cookie") ?? "") ?? {},
      error: url.searchParams.get("error") ?? void 0,
      query: Object.fromEntries(url.searchParams)
    };
  } catch (e2) {
    const logger2 = setLogger(config2);
    logger2.error(e2);
    logger2.debug("request", req);
  }
}
__name(toInternalRequest, "toInternalRequest");
function toRequest(request3) {
  return new Request(request3.url, {
    headers: request3.headers,
    method: request3.method,
    body: request3.method === "POST" ? JSON.stringify(request3.body ?? {}) : void 0
  });
}
__name(toRequest, "toRequest");
function toResponse(res) {
  const headers = new Headers(res.headers);
  res.cookies?.forEach((cookie) => {
    const { name, value, options } = cookie;
    const cookieHeader = (0, import_cookie4.serialize)(name, value, options);
    if (headers.has("Set-Cookie"))
      headers.append("Set-Cookie", cookieHeader);
    else
      headers.set("Set-Cookie", cookieHeader);
  });
  let body = res.body;
  if (headers.get("content-type") === "application/json")
    body = JSON.stringify(res.body);
  else if (headers.get("content-type") === "application/x-www-form-urlencoded")
    body = new URLSearchParams(res.body).toString();
  const status = res.redirect ? 302 : res.status ?? 200;
  const response = new Response(body, { headers, status });
  if (res.redirect)
    response.headers.set("Location", res.redirect);
  return response;
}
__name(toResponse, "toResponse");
async function createHash3(message2) {
  const data = new TextEncoder().encode(message2);
  const hash2 = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hash2)).map((b3) => b3.toString(16).padStart(2, "0")).join("").toString();
}
__name(createHash3, "createHash");
function randomString(size) {
  const i2hex = /* @__PURE__ */ __name((i3) => ("0" + i3.toString(16)).slice(-2), "i2hex");
  const r3 = /* @__PURE__ */ __name((a4, i3) => a4 + i2hex(i3), "r");
  const bytes = crypto.getRandomValues(new Uint8Array(size));
  return Array.from(bytes).reduce(r3, "");
}
__name(randomString, "randomString");
function parseActionAndProviderId(pathname, base2) {
  const a4 = pathname.match(new RegExp(`^${base2}(.+)`));
  if (a4 === null)
    throw new UnknownAction(`Cannot parse action at ${pathname}`);
  const actionAndProviderId = a4.at(-1);
  const b3 = actionAndProviderId.replace(/^\//, "").split("/").filter(Boolean);
  if (b3.length !== 1 && b3.length !== 2)
    throw new UnknownAction(`Cannot parse action at ${pathname}`);
  const [action, providerId] = b3;
  if (!isAuthAction(action))
    throw new UnknownAction(`Cannot parse action at ${pathname}`);
  if (providerId && !["signin", "callback", "webauthn-options"].includes(action))
    throw new UnknownAction(`Cannot parse action at ${pathname}`);
  return { action, providerId };
}
__name(parseActionAndProviderId, "parseActionAndProviderId");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/csrf-token.js
async function createCSRFToken({ options, cookieValue, isPost, bodyValue }) {
  if (cookieValue) {
    const [csrfToken2, csrfTokenHash2] = cookieValue.split("|");
    const expectedCsrfTokenHash = await createHash3(`${csrfToken2}${options.secret}`);
    if (csrfTokenHash2 === expectedCsrfTokenHash) {
      const csrfTokenVerified = isPost && csrfToken2 === bodyValue;
      return { csrfTokenVerified, csrfToken: csrfToken2 };
    }
  }
  const csrfToken = randomString(32);
  const csrfTokenHash = await createHash3(`${csrfToken}${options.secret}`);
  const cookie = `${csrfToken}|${csrfTokenHash}`;
  return { cookie, csrfToken };
}
__name(createCSRFToken, "createCSRFToken");
function validateCSRF(action, verified) {
  if (verified)
    return;
  throw new MissingCSRF(`CSRF token was missing during an action ${action}`);
}
__name(validateCSRF, "validateCSRF");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/providers.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/merge.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function isObject2(item) {
  return item !== null && typeof item === "object";
}
__name(isObject2, "isObject");
function merge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject2(target) && isObject2(source)) {
    for (const key in source) {
      if (isObject2(source[key])) {
        if (!isObject2(target[key]))
          target[key] = Array.isArray(source[key]) ? [] : {};
        merge(target[key], source[key]);
      } else if (source[key] !== void 0)
        target[key] = source[key];
    }
  }
  return merge(target, ...sources);
}
__name(merge, "merge");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/providers.js
function parseProviders(params) {
  const { providerId, options } = params;
  const url = new URL(options.basePath ?? "/auth", params.url.origin);
  const providers = params.providers.map((p5) => {
    const provider = typeof p5 === "function" ? p5() : p5;
    const { options: userOptions, ...defaults } = provider;
    const id = userOptions?.id ?? defaults.id;
    const merged = merge(defaults, userOptions, {
      signinUrl: `${url}/signin/${id}`,
      callbackUrl: `${url}/callback/${id}`
    });
    if (provider.type === "oauth" || provider.type === "oidc") {
      merged.redirectProxyUrl ?? (merged.redirectProxyUrl = options.redirectProxyUrl);
      return normalizeOAuth(merged);
    }
    return merged;
  });
  return {
    providers,
    provider: providers.find(({ id }) => id === providerId)
  };
}
__name(parseProviders, "parseProviders");
function normalizeOAuth(c4) {
  if (c4.issuer)
    c4.wellKnown ?? (c4.wellKnown = `${c4.issuer}/.well-known/openid-configuration`);
  const authorization = normalizeEndpoint(c4.authorization, c4.issuer);
  if (authorization && !authorization.url?.searchParams.has("scope")) {
    authorization.url.searchParams.set("scope", "openid profile email");
  }
  const token = normalizeEndpoint(c4.token, c4.issuer);
  const userinfo = normalizeEndpoint(c4.userinfo, c4.issuer);
  const checks = c4.checks ?? ["pkce"];
  if (c4.redirectProxyUrl) {
    if (!checks.includes("state"))
      checks.push("state");
    c4.redirectProxyUrl = `${c4.redirectProxyUrl}/callback/${c4.id}`;
  }
  return {
    ...c4,
    authorization,
    token,
    checks,
    userinfo,
    profile: c4.profile ?? defaultProfile,
    account: c4.account ?? defaultAccount
  };
}
__name(normalizeOAuth, "normalizeOAuth");
var defaultProfile = /* @__PURE__ */ __name((profile3) => {
  return stripUndefined({
    id: profile3.sub ?? profile3.id ?? crypto.randomUUID(),
    name: profile3.name ?? profile3.nickname ?? profile3.preferred_username,
    email: profile3.email,
    image: profile3.picture
  });
}, "defaultProfile");
var defaultAccount = /* @__PURE__ */ __name((account) => {
  return stripUndefined({
    access_token: account.access_token,
    id_token: account.id_token,
    refresh_token: account.refresh_token,
    expires_at: account.expires_at,
    scope: account.scope,
    token_type: account.token_type,
    session_state: account.session_state
  });
}, "defaultAccount");
function stripUndefined(o4) {
  const result = {};
  for (const [k3, v4] of Object.entries(o4)) {
    if (v4 !== void 0)
      result[k3] = v4;
  }
  return result;
}
__name(stripUndefined, "stripUndefined");
function normalizeEndpoint(e2, issuer) {
  if (!e2 && issuer)
    return;
  if (typeof e2 === "string") {
    return { url: new URL(e2) };
  }
  const url = new URL(e2?.url ?? "https://authjs.dev");
  if (e2?.params != null) {
    for (let [key, value] of Object.entries(e2.params)) {
      if (key === "claims") {
        value = JSON.stringify(value);
      }
      url.searchParams.set(key, String(value));
    }
  }
  return {
    url,
    request: e2?.request,
    conform: e2?.conform,
    ...e2?.clientPrivateKey ? { clientPrivateKey: e2?.clientPrivateKey } : null
  };
}
__name(normalizeEndpoint, "normalizeEndpoint");
function isOIDCProvider(provider) {
  return provider.type === "oidc";
}
__name(isOIDCProvider, "isOIDCProvider");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/init.js
var defaultCallbacks = {
  signIn() {
    return true;
  },
  redirect({ url, baseUrl }) {
    if (url.startsWith("/"))
      return `${baseUrl}${url}`;
    else if (new URL(url).origin === baseUrl)
      return url;
    return baseUrl;
  },
  session({ session: session2 }) {
    return {
      user: {
        name: session2.user?.name,
        email: session2.user?.email,
        image: session2.user?.image
      },
      expires: session2.expires?.toISOString?.() ?? session2.expires
    };
  },
  jwt({ token }) {
    return token;
  }
};
async function init2({ authOptions, providerId, action, url, cookies: reqCookies, callbackUrl: reqCallbackUrl, csrfToken: reqCsrfToken, csrfDisabled, isPost }) {
  const logger2 = setLogger(authOptions);
  const { providers, provider } = parseProviders({
    providers: authOptions.providers,
    url,
    providerId,
    options: authOptions
  });
  const maxAge = 30 * 24 * 60 * 60;
  let isOnRedirectProxy = false;
  if ((provider?.type === "oauth" || provider?.type === "oidc") && provider.redirectProxyUrl) {
    try {
      isOnRedirectProxy = new URL(provider.redirectProxyUrl).origin === url.origin;
    } catch {
      throw new TypeError(`redirectProxyUrl must be a valid URL. Received: ${provider.redirectProxyUrl}`);
    }
  }
  const options = {
    debug: false,
    pages: {},
    theme: {
      colorScheme: "auto",
      logo: "",
      brandColor: "",
      buttonText: ""
    },
    // Custom options override defaults
    ...authOptions,
    // These computed settings can have values in userOptions but we override them
    // and are request-specific.
    url,
    action,
    // @ts-expect-errors
    provider,
    cookies: merge(defaultCookies(authOptions.useSecureCookies ?? url.protocol === "https:"), authOptions.cookies),
    providers,
    // Session options
    session: {
      // If no adapter specified, force use of JSON Web Tokens (stateless)
      strategy: authOptions.adapter ? "database" : "jwt",
      maxAge,
      updateAge: 24 * 60 * 60,
      generateSessionToken: () => crypto.randomUUID(),
      ...authOptions.session
    },
    // JWT options
    jwt: {
      secret: authOptions.secret,
      // Asserted in assert.ts
      maxAge: authOptions.session?.maxAge ?? maxAge,
      // default to same as `session.maxAge`
      encode: encode4,
      decode: decode4,
      ...authOptions.jwt
    },
    // Event messages
    events: eventsErrorHandler(authOptions.events ?? {}, logger2),
    adapter: adapterErrorHandler(authOptions.adapter, logger2),
    // Callback functions
    callbacks: { ...defaultCallbacks, ...authOptions.callbacks },
    logger: logger2,
    callbackUrl: url.origin,
    isOnRedirectProxy,
    experimental: {
      ...authOptions.experimental
    }
  };
  const cookies = [];
  if (csrfDisabled) {
    options.csrfTokenVerified = true;
  } else {
    const { csrfToken, cookie: csrfCookie, csrfTokenVerified } = await createCSRFToken({
      options,
      cookieValue: reqCookies?.[options.cookies.csrfToken.name],
      isPost,
      bodyValue: reqCsrfToken
    });
    options.csrfToken = csrfToken;
    options.csrfTokenVerified = csrfTokenVerified;
    if (csrfCookie) {
      cookies.push({
        name: options.cookies.csrfToken.name,
        value: csrfCookie,
        options: options.cookies.csrfToken.options
      });
    }
  }
  const { callbackUrl, callbackUrlCookie } = await createCallbackUrl({
    options,
    cookieValue: reqCookies?.[options.cookies.callbackUrl.name],
    paramValue: reqCallbackUrl
  });
  options.callbackUrl = callbackUrl;
  if (callbackUrlCookie) {
    cookies.push({
      name: options.cookies.callbackUrl.name,
      value: callbackUrlCookie,
      options: options.cookies.callbackUrl.options
    });
  }
  return { options, cookies };
}
__name(init2, "init");
function eventsErrorHandler(methods, logger2) {
  return Object.keys(methods).reduce((acc, name) => {
    acc[name] = async (...args) => {
      try {
        const method = methods[name];
        return await method(...args);
      } catch (e2) {
        logger2.error(new EventError(e2));
      }
    };
    return acc;
  }, {});
}
__name(eventsErrorHandler, "eventsErrorHandler");
function adapterErrorHandler(adapter, logger2) {
  if (!adapter)
    return;
  return Object.keys(adapter).reduce((acc, name) => {
    acc[name] = async (...args) => {
      try {
        logger2.debug(`adapter_${name}`, { args });
        const method = adapter[name];
        return await method(...args);
      } catch (e2) {
        const error4 = new AdapterError(e2);
        logger2.error(error4);
        throw error4;
      }
    };
    return acc;
  }, {});
}
__name(adapterErrorHandler, "adapterErrorHandler");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/preact-render-to-string@5.2.3_preact@10.11.3/node_modules/preact-render-to-string/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/preact@10.11.3/node_modules/preact/dist/preact.module.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var n;
var l;
var u;
var i;
var t;
var o;
var r;
var f2 = {};
var e = [];
var c2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n3, l3) {
  for (var u3 in l3)
    n3[u3] = l3[u3];
  return n3;
}
__name(s, "s");
function a2(n3) {
  var l3 = n3.parentNode;
  l3 && l3.removeChild(n3);
}
__name(a2, "a");
function v2(n3, i3, t2, o4, r3) {
  var f4 = { type: n3, props: i3, key: t2, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r3 ? ++u : r3 };
  return null == r3 && null != l.vnode && l.vnode(f4), f4;
}
__name(v2, "v");
function p3(n3) {
  return n3.children;
}
__name(p3, "p");
function d(n3, l3) {
  this.props = n3, this.context = l3;
}
__name(d, "d");
function _2(n3, l3) {
  if (null == l3)
    return n3.__ ? _2(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u3; l3 < n3.__k.length; l3++)
    if (null != (u3 = n3.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n3.type ? _2(n3) : null;
}
__name(_2, "_");
function k(n3) {
  var l3, u3;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++)
      if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
        n3.__e = n3.__c.base = u3.__e;
        break;
      }
    return k(n3);
  }
}
__name(k, "k");
function b(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !g2.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g2);
}
__name(b, "b");
function g2() {
  for (var n3; g2.__r = t.length; )
    n3 = t.sort(function(n4, l3) {
      return n4.__v.__b - l3.__v.__b;
    }), t = [], n3.some(function(n4) {
      var l3, u3, i3, t2, o4, r3;
      n4.__d && (o4 = (t2 = (l3 = n4).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = s({}, t2)).__v = t2.__v + 1, j(r3, t2, i3, l3.__n, void 0 !== r3.ownerSVGElement, null != t2.__h ? [o4] : null, u3, null == o4 ? _2(t2) : o4, t2.__h), z3(u3, t2), t2.__e != o4 && k(t2)));
    });
}
__name(g2, "g");
function w(n3, l3, u3, i3, t2, o4, r3, c4, s3, a4) {
  var h2, y3, d3, k3, b3, g4, w3, x3 = i3 && i3.__k || e, C3 = x3.length;
  for (u3.__k = [], h2 = 0; h2 < l3.length; h2++)
    if (null != (k3 = u3.__k[h2] = null == (k3 = l3[h2]) || "boolean" == typeof k3 ? null : "string" == typeof k3 || "number" == typeof k3 || "bigint" == typeof k3 ? v2(null, k3, null, null, k3) : Array.isArray(k3) ? v2(p3, { children: k3 }, null, null, null) : k3.__b > 0 ? v2(k3.type, k3.props, k3.key, k3.ref ? k3.ref : null, k3.__v) : k3)) {
      if (k3.__ = u3, k3.__b = u3.__b + 1, null === (d3 = x3[h2]) || d3 && k3.key == d3.key && k3.type === d3.type)
        x3[h2] = void 0;
      else
        for (y3 = 0; y3 < C3; y3++) {
          if ((d3 = x3[y3]) && k3.key == d3.key && k3.type === d3.type) {
            x3[y3] = void 0;
            break;
          }
          d3 = null;
        }
      j(n3, k3, d3 = d3 || f2, t2, o4, r3, c4, s3, a4), b3 = k3.__e, (y3 = k3.ref) && d3.ref != y3 && (w3 || (w3 = []), d3.ref && w3.push(d3.ref, null, k3), w3.push(y3, k3.__c || b3, k3)), null != b3 ? (null == g4 && (g4 = b3), "function" == typeof k3.type && k3.__k === d3.__k ? k3.__d = s3 = m3(k3, s3, n3) : s3 = A(n3, k3, d3, x3, b3, s3), "function" == typeof u3.type && (u3.__d = s3)) : s3 && d3.__e == s3 && s3.parentNode != n3 && (s3 = _2(d3));
    }
  for (u3.__e = g4, h2 = C3; h2--; )
    null != x3[h2] && N2(x3[h2], x3[h2]);
  if (w3)
    for (h2 = 0; h2 < w3.length; h2++)
      M(w3[h2], w3[++h2], w3[++h2]);
}
__name(w, "w");
function m3(n3, l3, u3) {
  for (var i3, t2 = n3.__k, o4 = 0; t2 && o4 < t2.length; o4++)
    (i3 = t2[o4]) && (i3.__ = n3, l3 = "function" == typeof i3.type ? m3(i3, l3, u3) : A(u3, i3, i3, t2, i3.__e, l3));
  return l3;
}
__name(m3, "m");
function A(n3, l3, u3, i3, t2, o4) {
  var r3, f4, e2;
  if (void 0 !== l3.__d)
    r3 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t2 != o4 || null == t2.parentNode)
    n:
      if (null == o4 || o4.parentNode !== n3)
        n3.appendChild(t2), r3 = null;
      else {
        for (f4 = o4, e2 = 0; (f4 = f4.nextSibling) && e2 < i3.length; e2 += 1)
          if (f4 == t2)
            break n;
        n3.insertBefore(t2, o4), r3 = o4;
      }
  return void 0 !== r3 ? r3 : t2.nextSibling;
}
__name(A, "A");
function C(n3, l3, u3, i3, t2) {
  var o4;
  for (o4 in u3)
    "children" === o4 || "key" === o4 || o4 in l3 || H(n3, o4, null, u3[o4], i3);
  for (o4 in l3)
    t2 && "function" != typeof l3[o4] || "children" === o4 || "key" === o4 || "value" === o4 || "checked" === o4 || u3[o4] === l3[o4] || H(n3, o4, l3[o4], u3[o4], i3);
}
__name(C, "C");
function $(n3, l3, u3) {
  "-" === l3[0] ? n3.setProperty(l3, u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || c2.test(l3) ? u3 : u3 + "px";
}
__name($, "$");
function H(n3, l3, u3, i3, t2) {
  var o4;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n3.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n3.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || $(n3.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || $(n3.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      o4 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + o4] = u3, u3 ? i3 || n3.addEventListener(l3, o4 ? T : I2, o4) : n3.removeEventListener(l3, o4 ? T : I2, o4);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t2)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n3)
        try {
          n3[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n4) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n3.removeAttribute(l3) : n3.setAttribute(l3, u3));
    }
}
__name(H, "H");
function I2(n3) {
  this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
__name(I2, "I");
function T(n3) {
  this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
__name(T, "T");
function j(n3, u3, i3, t2, o4, r3, f4, e2, c4) {
  var a4, h2, v4, y3, _5, k3, b3, g4, m5, x3, A2, C3, $2, H2, I3, T2 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c4 = i3.__h, e2 = u3.__e = i3.__e, u3.__h = null, r3 = [e2]), (a4 = l.__b) && a4(u3);
  try {
    n:
      if ("function" == typeof T2) {
        if (g4 = u3.props, m5 = (a4 = T2.contextType) && t2[a4.__c], x3 = a4 ? m5 ? m5.props.value : a4.__ : t2, i3.__c ? b3 = (h2 = u3.__c = i3.__c).__ = h2.__E : ("prototype" in T2 && T2.prototype.render ? u3.__c = h2 = new T2(g4, x3) : (u3.__c = h2 = new d(g4, x3), h2.constructor = T2, h2.render = O), m5 && m5.sub(h2), h2.props = g4, h2.state || (h2.state = {}), h2.context = x3, h2.__n = t2, v4 = h2.__d = true, h2.__h = [], h2._sb = []), null == h2.__s && (h2.__s = h2.state), null != T2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = s({}, h2.__s)), s(h2.__s, T2.getDerivedStateFromProps(g4, h2.__s))), y3 = h2.props, _5 = h2.state, v4)
          null == T2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
        else {
          if (null == T2.getDerivedStateFromProps && g4 !== y3 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(g4, x3), !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(g4, h2.__s, x3) || u3.__v === i3.__v) {
            for (h2.props = g4, h2.state = h2.__s, u3.__v !== i3.__v && (h2.__d = false), h2.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n4) {
              n4 && (n4.__ = u3);
            }), A2 = 0; A2 < h2._sb.length; A2++)
              h2.__h.push(h2._sb[A2]);
            h2._sb = [], h2.__h.length && f4.push(h2);
            break n;
          }
          null != h2.componentWillUpdate && h2.componentWillUpdate(g4, h2.__s, x3), null != h2.componentDidUpdate && h2.__h.push(function() {
            h2.componentDidUpdate(y3, _5, k3);
          });
        }
        if (h2.context = x3, h2.props = g4, h2.__v = u3, h2.__P = n3, C3 = l.__r, $2 = 0, "prototype" in T2 && T2.prototype.render) {
          for (h2.state = h2.__s, h2.__d = false, C3 && C3(u3), a4 = h2.render(h2.props, h2.state, h2.context), H2 = 0; H2 < h2._sb.length; H2++)
            h2.__h.push(h2._sb[H2]);
          h2._sb = [];
        } else
          do {
            h2.__d = false, C3 && C3(u3), a4 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
          } while (h2.__d && ++$2 < 25);
        h2.state = h2.__s, null != h2.getChildContext && (t2 = s(s({}, t2), h2.getChildContext())), v4 || null == h2.getSnapshotBeforeUpdate || (k3 = h2.getSnapshotBeforeUpdate(y3, _5)), I3 = null != a4 && a4.type === p3 && null == a4.key ? a4.props.children : a4, w(n3, Array.isArray(I3) ? I3 : [I3], u3, i3, t2, o4, r3, f4, e2, c4), h2.base = u3.__e, u3.__h = null, h2.__h.length && f4.push(h2), b3 && (h2.__E = h2.__ = null), h2.__e = false;
      } else
        null == r3 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = L(i3.__e, u3, i3, t2, o4, r3, f4, c4);
    (a4 = l.diffed) && a4(u3);
  } catch (n4) {
    u3.__v = null, (c4 || null != r3) && (u3.__e = e2, u3.__h = !!c4, r3[r3.indexOf(e2)] = null), l.__e(n4, u3, i3);
  }
}
__name(j, "j");
function z3(n3, u3) {
  l.__c && l.__c(u3, n3), n3.some(function(u4) {
    try {
      n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
        n4.call(u4);
      });
    } catch (n4) {
      l.__e(n4, u4.__v);
    }
  });
}
__name(z3, "z");
function L(l3, u3, i3, t2, o4, r3, e2, c4) {
  var s3, h2, v4, y3 = i3.props, p5 = u3.props, d3 = u3.type, k3 = 0;
  if ("svg" === d3 && (o4 = true), null != r3) {
    for (; k3 < r3.length; k3++)
      if ((s3 = r3[k3]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : 3 === s3.nodeType)) {
        l3 = s3, r3[k3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d3)
      return document.createTextNode(p5);
    l3 = o4 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p5.is && p5), r3 = null, c4 = false;
  }
  if (null === d3)
    y3 === p5 || c4 && l3.data === p5 || (l3.data = p5);
  else {
    if (r3 = r3 && n.call(l3.childNodes), h2 = (y3 = i3.props || f2).dangerouslySetInnerHTML, v4 = p5.dangerouslySetInnerHTML, !c4) {
      if (null != r3)
        for (y3 = {}, k3 = 0; k3 < l3.attributes.length; k3++)
          y3[l3.attributes[k3].name] = l3.attributes[k3].value;
      (v4 || h2) && (v4 && (h2 && v4.__html == h2.__html || v4.__html === l3.innerHTML) || (l3.innerHTML = v4 && v4.__html || ""));
    }
    if (C(l3, p5, y3, o4, c4), v4)
      u3.__k = [];
    else if (k3 = u3.props.children, w(l3, Array.isArray(k3) ? k3 : [k3], u3, i3, t2, o4 && "foreignObject" !== d3, r3, e2, r3 ? r3[0] : i3.__k && _2(i3, 0), c4), null != r3)
      for (k3 = r3.length; k3--; )
        null != r3[k3] && a2(r3[k3]);
    c4 || ("value" in p5 && void 0 !== (k3 = p5.value) && (k3 !== l3.value || "progress" === d3 && !k3 || "option" === d3 && k3 !== y3.value) && H(l3, "value", k3, y3.value, false), "checked" in p5 && void 0 !== (k3 = p5.checked) && k3 !== l3.checked && H(l3, "checked", k3, y3.checked, false));
  }
  return l3;
}
__name(L, "L");
function M(n3, u3, i3) {
  try {
    "function" == typeof n3 ? n3(u3) : n3.current = u3;
  } catch (n4) {
    l.__e(n4, i3);
  }
}
__name(M, "M");
function N2(n3, u3, i3) {
  var t2, o4;
  if (l.unmount && l.unmount(n3), (t2 = n3.ref) && (t2.current && t2.current !== n3.__e || M(t2, null, u3)), null != (t2 = n3.__c)) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u3);
      }
    t2.base = t2.__P = null, n3.__c = void 0;
  }
  if (t2 = n3.__k)
    for (o4 = 0; o4 < t2.length; o4++)
      t2[o4] && N2(t2[o4], u3, i3 || "function" != typeof n3.type);
  i3 || null == n3.__e || a2(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
__name(N2, "N");
function O(n3, l3, u3) {
  return this.constructor(n3, u3);
}
__name(O, "O");
n = e.slice, l = { __e: function(n3, l3, u3, i3) {
  for (var t2, o4, r3; l3 = l3.__; )
    if ((t2 = l3.__c) && !t2.__)
      try {
        if ((o4 = t2.constructor) && null != o4.getDerivedStateFromError && (t2.setState(o4.getDerivedStateFromError(n3)), r3 = t2.__d), null != t2.componentDidCatch && (t2.componentDidCatch(n3, i3 || {}), r3 = t2.__d), r3)
          return t2.__E = t2;
      } catch (l4) {
        n3 = l4;
      }
  throw n3;
} }, u = 0, i = /* @__PURE__ */ __name(function(n3) {
  return null != n3 && void 0 === n3.constructor;
}, "i"), d.prototype.setState = function(n3, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n3 && (n3 = n3(s({}, u3), this.props)), n3 && s(u3, n3), null != n3 && this.__v && (l3 && this._sb.push(l3), b(this));
}, d.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), b(this));
}, d.prototype.render = p3, t = [], g2.__r = 0, r = 0;

// node_modules/.pnpm/preact-render-to-string@5.2.3_preact@10.11.3/node_modules/preact-render-to-string/dist/index.mjs
var r2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;
var n2 = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;
var o2 = /[\s\n\\/='"\0<>]/;
var i2 = /^xlink:?./;
var a3 = /["&<]/;
function l2(e2) {
  if (false === a3.test(e2 += ""))
    return e2;
  for (var t2 = 0, r3 = 0, n3 = "", o4 = ""; r3 < e2.length; r3++) {
    switch (e2.charCodeAt(r3)) {
      case 34:
        o4 = "&quot;";
        break;
      case 38:
        o4 = "&amp;";
        break;
      case 60:
        o4 = "&lt;";
        break;
      default:
        continue;
    }
    r3 !== t2 && (n3 += e2.slice(t2, r3)), n3 += o4, t2 = r3 + 1;
  }
  return r3 !== t2 && (n3 += e2.slice(t2, r3)), n3;
}
__name(l2, "l");
var s2 = /* @__PURE__ */ __name(function(e2, t2) {
  return String(e2).replace(/(\n+)/g, "$1" + (t2 || "	"));
}, "s");
var f3 = /* @__PURE__ */ __name(function(e2, t2, r3) {
  return String(e2).length > (t2 || 40) || !r3 && -1 !== String(e2).indexOf("\n") || -1 !== String(e2).indexOf("<");
}, "f");
var c3 = {};
var u2 = /([A-Z])/g;
function p4(e2) {
  var t2 = "";
  for (var n3 in e2) {
    var o4 = e2[n3];
    null != o4 && "" !== o4 && (t2 && (t2 += " "), t2 += "-" == n3[0] ? n3 : c3[n3] || (c3[n3] = n3.replace(u2, "-$1").toLowerCase()), t2 = "number" == typeof o4 && false === r2.test(n3) ? t2 + ": " + o4 + "px;" : t2 + ": " + o4 + ";");
  }
  return t2 || void 0;
}
__name(p4, "p");
function _3(e2, t2) {
  return Array.isArray(t2) ? t2.reduce(_3, e2) : null != t2 && false !== t2 && e2.push(t2), e2;
}
__name(_3, "_");
function d2() {
  this.__d = true;
}
__name(d2, "d");
function v3(e2, t2) {
  return { __v: e2, context: t2, props: e2.props, setState: d2, forceUpdate: d2, __d: true, __h: [] };
}
__name(v3, "v");
function h(e2, t2) {
  var r3 = e2.contextType, n3 = r3 && t2[r3.__c];
  return null != r3 ? n3 ? n3.props.value : r3.__ : t2;
}
__name(h, "h");
var g3 = [];
function y2(r3, a4, c4, u3, d3, m5) {
  if (null == r3 || "boolean" == typeof r3)
    return "";
  if ("object" != typeof r3)
    return l2(r3);
  var b3 = c4.pretty, x3 = b3 && "string" == typeof b3 ? b3 : "	";
  if (Array.isArray(r3)) {
    for (var k3 = "", S3 = 0; S3 < r3.length; S3++)
      b3 && S3 > 0 && (k3 += "\n"), k3 += y2(r3[S3], a4, c4, u3, d3, m5);
    return k3;
  }
  var w3, C3 = r3.type, O3 = r3.props, j3 = false;
  if ("function" == typeof C3) {
    if (j3 = true, !c4.shallow || !u3 && false !== c4.renderRootComponent) {
      if (C3 === p3) {
        var A2 = [];
        return _3(A2, r3.props.children), y2(A2, a4, c4, false !== c4.shallowHighOrder, d3, m5);
      }
      var F, H2 = r3.__c = v3(r3, a4);
      l.__b && l.__b(r3);
      var M2 = l.__r;
      if (C3.prototype && "function" == typeof C3.prototype.render) {
        var L2 = h(C3, a4);
        (H2 = r3.__c = new C3(O3, L2)).__v = r3, H2._dirty = H2.__d = true, H2.props = O3, null == H2.state && (H2.state = {}), null == H2._nextState && null == H2.__s && (H2._nextState = H2.__s = H2.state), H2.context = L2, C3.getDerivedStateFromProps ? H2.state = Object.assign({}, H2.state, C3.getDerivedStateFromProps(H2.props, H2.state)) : H2.componentWillMount && (H2.componentWillMount(), H2.state = H2._nextState !== H2.state ? H2._nextState : H2.__s !== H2.state ? H2.__s : H2.state), M2 && M2(r3), F = H2.render(H2.props, H2.state, H2.context);
      } else
        for (var T2 = h(C3, a4), E2 = 0; H2.__d && E2++ < 25; )
          H2.__d = false, M2 && M2(r3), F = C3.call(r3.__c, O3, T2);
      return H2.getChildContext && (a4 = Object.assign({}, a4, H2.getChildContext())), l.diffed && l.diffed(r3), y2(F, a4, c4, false !== c4.shallowHighOrder, d3, m5);
    }
    C3 = (w3 = C3).displayName || w3 !== Function && w3.name || function(e2) {
      var t2 = (Function.prototype.toString.call(e2).match(/^\s*function\s+([^( ]+)/) || "")[1];
      if (!t2) {
        for (var r4 = -1, n3 = g3.length; n3--; )
          if (g3[n3] === e2) {
            r4 = n3;
            break;
          }
        r4 < 0 && (r4 = g3.push(e2) - 1), t2 = "UnnamedComponent" + r4;
      }
      return t2;
    }(w3);
  }
  var $2, D, N3 = "<" + C3;
  if (O3) {
    var P = Object.keys(O3);
    c4 && true === c4.sortAttributes && P.sort();
    for (var W = 0; W < P.length; W++) {
      var I3 = P[W], R = O3[I3];
      if ("children" !== I3) {
        if (!o2.test(I3) && (c4 && c4.allAttributes || "key" !== I3 && "ref" !== I3 && "__self" !== I3 && "__source" !== I3)) {
          if ("defaultValue" === I3)
            I3 = "value";
          else if ("defaultChecked" === I3)
            I3 = "checked";
          else if ("defaultSelected" === I3)
            I3 = "selected";
          else if ("className" === I3) {
            if (void 0 !== O3.class)
              continue;
            I3 = "class";
          } else
            d3 && i2.test(I3) && (I3 = I3.toLowerCase().replace(/^xlink:?/, "xlink:"));
          if ("htmlFor" === I3) {
            if (O3.for)
              continue;
            I3 = "for";
          }
          "style" === I3 && R && "object" == typeof R && (R = p4(R)), "a" === I3[0] && "r" === I3[1] && "boolean" == typeof R && (R = String(R));
          var U2 = c4.attributeHook && c4.attributeHook(I3, R, a4, c4, j3);
          if (U2 || "" === U2)
            N3 += U2;
          else if ("dangerouslySetInnerHTML" === I3)
            D = R && R.__html;
          else if ("textarea" === C3 && "value" === I3)
            $2 = R;
          else if ((R || 0 === R || "" === R) && "function" != typeof R) {
            if (!(true !== R && "" !== R || (R = I3, c4 && c4.xml))) {
              N3 = N3 + " " + I3;
              continue;
            }
            if ("value" === I3) {
              if ("select" === C3) {
                m5 = R;
                continue;
              }
              "option" === C3 && m5 == R && void 0 === O3.selected && (N3 += " selected");
            }
            N3 = N3 + " " + I3 + '="' + l2(R) + '"';
          }
        }
      } else
        $2 = R;
    }
  }
  if (b3) {
    var V = N3.replace(/\n\s*/, " ");
    V === N3 || ~V.indexOf("\n") ? b3 && ~N3.indexOf("\n") && (N3 += "\n") : N3 = V;
  }
  if (N3 += ">", o2.test(C3))
    throw new Error(C3 + " is not a valid HTML tag name in " + N3);
  var q, z4 = n2.test(C3) || c4.voidElements && c4.voidElements.test(C3), Z = [];
  if (D)
    b3 && f3(D) && (D = "\n" + x3 + s2(D, x3)), N3 += D;
  else if (null != $2 && _3(q = [], $2).length) {
    for (var B = b3 && ~N3.indexOf("\n"), G = false, J = 0; J < q.length; J++) {
      var K = q[J];
      if (null != K && false !== K) {
        var Q = y2(K, a4, c4, true, "svg" === C3 || "foreignObject" !== C3 && d3, m5);
        if (b3 && !B && f3(Q) && (B = true), Q)
          if (b3) {
            var X = Q.length > 0 && "<" != Q[0];
            G && X ? Z[Z.length - 1] += Q : Z.push(Q), G = X;
          } else
            Z.push(Q);
      }
    }
    if (b3 && B)
      for (var Y = Z.length; Y--; )
        Z[Y] = "\n" + x3 + s2(Z[Y], x3);
  }
  if (Z.length || D)
    N3 += Z.join("");
  else if (c4 && c4.xml)
    return N3.substring(0, N3.length - 1) + " />";
  return !z4 || q || D ? (b3 && ~N3.indexOf("\n") && (N3 += "\n"), N3 = N3 + "</" + C3 + ">") : N3 = N3.replace(/>$/, " />"), N3;
}
__name(y2, "y");
var m4 = { shallow: true };
k2.render = k2;
var b2 = /* @__PURE__ */ __name(function(e2, t2) {
  return k2(e2, t2, m4);
}, "b");
var x2 = [];
function k2(e2, r3, n3) {
  r3 = r3 || {};
  var o4, i3 = l.__s;
  return l.__s = true, o4 = n3 && (n3.pretty || n3.voidElements || n3.sortAttributes || n3.shallow || n3.allAttributes || n3.xml || n3.attributeHook) ? y2(e2, r3, n3) : j2(e2, r3, false, void 0), l.__c && l.__c(e2, x2), l.__s = i3, x2.length = 0, o4;
}
__name(k2, "k");
function S2(e2, t2) {
  return "className" === e2 ? "class" : "htmlFor" === e2 ? "for" : "defaultValue" === e2 ? "value" : "defaultChecked" === e2 ? "checked" : "defaultSelected" === e2 ? "selected" : t2 && i2.test(e2) ? e2.toLowerCase().replace(/^xlink:?/, "xlink:") : e2;
}
__name(S2, "S");
function w2(e2, t2) {
  return "style" === e2 && null != t2 && "object" == typeof t2 ? p4(t2) : "a" === e2[0] && "r" === e2[1] && "boolean" == typeof t2 ? String(t2) : t2;
}
__name(w2, "w");
var C2 = Array.isArray;
var O2 = Object.assign;
function j2(r3, i3, a4, s3) {
  if (null == r3 || true === r3 || false === r3 || "" === r3)
    return "";
  if ("object" != typeof r3)
    return l2(r3);
  if (C2(r3)) {
    for (var f4 = "", c4 = 0; c4 < r3.length; c4++)
      f4 += j2(r3[c4], i3, a4, s3);
    return f4;
  }
  l.__b && l.__b(r3);
  var u3 = r3.type, p5 = r3.props;
  if ("function" == typeof u3) {
    if (u3 === p3)
      return j2(r3.props.children, i3, a4, s3);
    var _5;
    _5 = u3.prototype && "function" == typeof u3.prototype.render ? function(e2, r4) {
      var n3 = e2.type, o4 = h(n3, r4), i4 = new n3(e2.props, o4);
      e2.__c = i4, i4.__v = e2, i4.__d = true, i4.props = e2.props, null == i4.state && (i4.state = {}), null == i4.__s && (i4.__s = i4.state), i4.context = o4, n3.getDerivedStateFromProps ? i4.state = O2({}, i4.state, n3.getDerivedStateFromProps(i4.props, i4.state)) : i4.componentWillMount && (i4.componentWillMount(), i4.state = i4.__s !== i4.state ? i4.__s : i4.state);
      var a5 = l.__r;
      return a5 && a5(e2), i4.render(i4.props, i4.state, i4.context);
    }(r3, i3) : function(e2, r4) {
      var n3, o4 = v3(e2, r4), i4 = h(e2.type, r4);
      e2.__c = o4;
      for (var a5 = l.__r, l3 = 0; o4.__d && l3++ < 25; )
        o4.__d = false, a5 && a5(e2), n3 = e2.type.call(o4, e2.props, i4);
      return n3;
    }(r3, i3);
    var d3 = r3.__c;
    d3.getChildContext && (i3 = O2({}, i3, d3.getChildContext()));
    var g4 = j2(_5, i3, a4, s3);
    return l.diffed && l.diffed(r3), g4;
  }
  var y3, m5, b3 = "<";
  if (b3 += u3, p5)
    for (var x3 in y3 = p5.children, p5) {
      var k3 = p5[x3];
      if (!("key" === x3 || "ref" === x3 || "__self" === x3 || "__source" === x3 || "children" === x3 || "className" === x3 && "class" in p5 || "htmlFor" === x3 && "for" in p5 || o2.test(x3))) {
        if (k3 = w2(x3 = S2(x3, a4), k3), "dangerouslySetInnerHTML" === x3)
          m5 = k3 && k3.__html;
        else if ("textarea" === u3 && "value" === x3)
          y3 = k3;
        else if ((k3 || 0 === k3 || "" === k3) && "function" != typeof k3) {
          if (true === k3 || "" === k3) {
            k3 = x3, b3 = b3 + " " + x3;
            continue;
          }
          if ("value" === x3) {
            if ("select" === u3) {
              s3 = k3;
              continue;
            }
            "option" !== u3 || s3 != k3 || "selected" in p5 || (b3 += " selected");
          }
          b3 = b3 + " " + x3 + '="' + l2(k3) + '"';
        }
      }
    }
  var A2 = b3;
  if (b3 += ">", o2.test(u3))
    throw new Error(u3 + " is not a valid HTML tag name in " + b3);
  var F = "", H2 = false;
  if (m5)
    F += m5, H2 = true;
  else if ("string" == typeof y3)
    F += l2(y3), H2 = true;
  else if (C2(y3))
    for (var M2 = 0; M2 < y3.length; M2++) {
      var L2 = y3[M2];
      if (null != L2 && false !== L2) {
        var T2 = j2(L2, i3, "svg" === u3 || "foreignObject" !== u3 && a4, s3);
        T2 && (F += T2, H2 = true);
      }
    }
  else if (null != y3 && false !== y3 && true !== y3) {
    var E2 = j2(y3, i3, "svg" === u3 || "foreignObject" !== u3 && a4, s3);
    E2 && (F += E2, H2 = true);
  }
  if (l.diffed && l.diffed(r3), H2)
    b3 += F;
  else if (n2.test(u3))
    return A2 + " />";
  return b3 + "</" + u3 + ">";
}
__name(j2, "j");
k2.shallowRender = b2;

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/error.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/preact@10.11.3/node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var _4 = 0;
function o3(o4, e2, n3, t2, f4) {
  var l3, s3, u3 = {};
  for (s3 in e2)
    "ref" == s3 ? l3 = e2[s3] : u3[s3] = e2[s3];
  var a4 = { type: o4, props: u3, key: n3, ref: l3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: --_4, __source: f4, __self: t2 };
  if ("function" == typeof o4 && (l3 = o4.defaultProps))
    for (s3 in l3)
      void 0 === u3[s3] && (u3[s3] = l3[s3]);
  return l.vnode && l.vnode(a4), a4;
}
__name(o3, "o");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/error.js
function ErrorPage(props) {
  const { url, error: error4 = "default", theme } = props;
  const signinPageUrl = `${url}/signin`;
  const errors2 = {
    default: {
      status: 200,
      heading: "Error",
      message: o3("p", { children: o3("a", { className: "site", href: url?.origin, children: url?.host }) })
    },
    Configuration: {
      status: 500,
      heading: "Server error",
      message: o3("div", { children: [o3("p", { children: "There is a problem with the server configuration." }), o3("p", { children: "Check the server logs for more information." })] })
    },
    AccessDenied: {
      status: 403,
      heading: "Access Denied",
      message: o3("div", { children: [o3("p", { children: "You do not have permission to sign in." }), o3("p", { children: o3("a", { className: "button", href: signinPageUrl, children: "Sign in" }) })] })
    },
    Verification: {
      status: 403,
      heading: "Unable to sign in",
      message: o3("div", { children: [o3("p", { children: "The sign in link is no longer valid." }), o3("p", { children: "It may have been used already or it may have expired." })] }),
      signin: o3("a", { className: "button", href: signinPageUrl, children: "Sign in" })
    }
  };
  const { status, heading, message: message2, signin } = errors2[error4] ?? errors2.default;
  return {
    status,
    html: o3("div", { className: "error", children: [theme?.brandColor && o3("style", { dangerouslySetInnerHTML: {
      __html: `
        :root {
          --brand-color: ${theme?.brandColor}
        }
      `
    } }), o3("div", { className: "card", children: [theme?.logo && o3("img", { src: theme?.logo, alt: "Logo", className: "logo" }), o3("h1", { children: heading }), o3("div", { className: "message", children: message2 }), signin] })] })
  };
}
__name(ErrorPage, "ErrorPage");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/signin.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/webauthn-client.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function webauthnScript(authURL, providerID) {
  const WebAuthnBrowser = window.SimpleWebAuthnBrowser;
  async function fetchOptions(action) {
    const url = new URL(`${authURL}/webauthn-options/${providerID}`);
    if (action)
      url.searchParams.append("action", action);
    const formFields = getFormFields();
    formFields.forEach((field) => {
      url.searchParams.append(field.name, field.value);
    });
    const res = await fetch(url);
    if (!res.ok) {
      console.error("Failed to fetch options", res);
      return;
    }
    return res.json();
  }
  __name(fetchOptions, "fetchOptions");
  function getForm() {
    const formID = `#${providerID}-form`;
    const form = document.querySelector(formID);
    if (!form)
      throw new Error(`Form '${formID}' not found`);
    return form;
  }
  __name(getForm, "getForm");
  function getFormFields() {
    const form = getForm();
    const formFields = Array.from(form.querySelectorAll("input[data-form-field]"));
    return formFields;
  }
  __name(getFormFields, "getFormFields");
  async function submitForm(action, data) {
    const form = getForm();
    if (action) {
      const actionInput = document.createElement("input");
      actionInput.type = "hidden";
      actionInput.name = "action";
      actionInput.value = action;
      form.appendChild(actionInput);
    }
    if (data) {
      const dataInput = document.createElement("input");
      dataInput.type = "hidden";
      dataInput.name = "data";
      dataInput.value = JSON.stringify(data);
      form.appendChild(dataInput);
    }
    return form.submit();
  }
  __name(submitForm, "submitForm");
  async function authenticationFlow(options, autofill) {
    const authResp = await WebAuthnBrowser.startAuthentication(options, autofill);
    return await submitForm("authenticate", authResp);
  }
  __name(authenticationFlow, "authenticationFlow");
  async function registrationFlow(options) {
    const formFields = getFormFields();
    formFields.forEach((field) => {
      if (field.required && !field.value) {
        throw new Error(`Missing required field: ${field.name}`);
      }
    });
    const regResp = await WebAuthnBrowser.startRegistration(options);
    return await submitForm("register", regResp);
  }
  __name(registrationFlow, "registrationFlow");
  async function autofillAuthentication() {
    if (!WebAuthnBrowser.browserSupportsWebAuthnAutofill())
      return;
    const res = await fetchOptions("authenticate");
    if (!res) {
      console.error("Failed to fetch option for autofill authentication");
      return;
    }
    try {
      await authenticationFlow(res.options, true);
    } catch (e2) {
      console.error(e2);
    }
  }
  __name(autofillAuthentication, "autofillAuthentication");
  async function setupForm() {
    const form = getForm();
    if (!WebAuthnBrowser.browserSupportsWebAuthn()) {
      form.style.display = "none";
      return;
    }
    if (form) {
      form.addEventListener("submit", async (e2) => {
        e2.preventDefault();
        const res = await fetchOptions(void 0);
        if (!res) {
          console.error("Failed to fetch options for form submission");
          return;
        }
        if (res.action === "authenticate") {
          try {
            await authenticationFlow(res.options, false);
          } catch (e3) {
            console.error(e3);
          }
        } else if (res.action === "register") {
          try {
            await registrationFlow(res.options);
          } catch (e3) {
            console.error(e3);
          }
        }
      });
    }
  }
  __name(setupForm, "setupForm");
  setupForm();
  autofillAuthentication();
}
__name(webauthnScript, "webauthnScript");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/signin.js
var signinErrors = {
  default: "Unable to sign in.",
  Signin: "Try signing in with a different account.",
  OAuthSignin: "Try signing in with a different account.",
  OAuthCallbackError: "Try signing in with a different account.",
  OAuthCreateAccount: "Try signing in with a different account.",
  EmailCreateAccount: "Try signing in with a different account.",
  Callback: "Try signing in with a different account.",
  OAuthAccountNotLinked: "To confirm your identity, sign in with the same account you used originally.",
  EmailSignin: "The e-mail could not be sent.",
  CredentialsSignin: "Sign in failed. Check the details you provided are correct.",
  SessionRequired: "Please sign in to access this page."
};
function ConditionalUIScript(providerID) {
  const startConditionalUIScript = `
const currentURL = window.location.href;
const authURL = currentURL.substring(0, currentURL.lastIndexOf('/'));
(${webauthnScript})(authURL, "${providerID}");
`;
  return o3(p3, { children: o3("script", { dangerouslySetInnerHTML: { __html: startConditionalUIScript } }) });
}
__name(ConditionalUIScript, "ConditionalUIScript");
function SigninPage(props) {
  const { csrfToken, providers = [], callbackUrl, theme, email, error: errorType } = props;
  if (typeof document !== "undefined" && theme?.brandColor) {
    document.documentElement.style.setProperty("--brand-color", theme.brandColor);
  }
  if (typeof document !== "undefined" && theme?.buttonText) {
    document.documentElement.style.setProperty("--button-text-color", theme.buttonText);
  }
  const error4 = errorType && (signinErrors[errorType] ?? signinErrors.default);
  const providerLogoPath = "https://authjs.dev/img/providers";
  const conditionalUIProviderID = providers.find((provider) => provider.type === "webauthn" && provider.enableConditionalUI)?.id;
  return o3("div", { className: "signin", children: [theme?.brandColor && o3("style", { dangerouslySetInnerHTML: {
    __html: `:root {--brand-color: ${theme.brandColor}}`
  } }), theme?.buttonText && o3("style", { dangerouslySetInnerHTML: {
    __html: `
        :root {
          --button-text-color: ${theme.buttonText}
        }
      `
  } }), o3("div", { className: "card", children: [error4 && o3("div", { className: "error", children: o3("p", { children: error4 }) }), theme?.logo && o3("img", { src: theme.logo, alt: "Logo", className: "logo" }), providers.map((provider, i3) => {
    let bg, brandColor, logo;
    if (provider.type === "oauth" || provider.type === "oidc") {
      ;
      ({
        bg = "#fff",
        brandColor,
        logo = `${providerLogoPath}/${provider.id}.svg`
      } = provider.style ?? {});
    }
    const color = brandColor ?? bg ?? "#fff";
    return o3("div", { className: "provider", children: [provider.type === "oauth" || provider.type === "oidc" ? o3("form", { action: provider.signinUrl, method: "POST", children: [o3("input", { type: "hidden", name: "csrfToken", value: csrfToken }), callbackUrl && o3("input", { type: "hidden", name: "callbackUrl", value: callbackUrl }), o3("button", { type: "submit", className: "button", style: {
      "--provider-bg": "#fff",
      "--provider-bg-hover": `color-mix(in srgb, ${color} 30%, #fff)`,
      "--provider-dark-bg": "#161b22",
      "--provider-dark-bg-hover": `color-mix(in srgb, ${color} 30%, #000)`
    }, tabIndex: 0, children: [o3("span", { style: {
      filter: "invert(1) grayscale(1) brightness(1.3) contrast(9000)",
      "mix-blend-mode": "luminosity",
      opacity: 0.95
    }, children: ["Sign in with ", provider.name] }), logo && o3("img", { loading: "lazy", height: 24, src: logo })] })] }) : null, (provider.type === "email" || provider.type === "credentials" || provider.type === "webauthn") && i3 > 0 && providers[i3 - 1].type !== "email" && providers[i3 - 1].type !== "credentials" && providers[i3 - 1].type !== "webauthn" && o3("hr", {}), provider.type === "email" && o3("form", { action: provider.signinUrl, method: "POST", children: [o3("input", { type: "hidden", name: "csrfToken", value: csrfToken }), o3("label", { className: "section-header", htmlFor: `input-email-for-${provider.id}-provider`, children: "Email" }), o3("input", { id: `input-email-for-${provider.id}-provider`, autoFocus: true, type: "email", name: "email", value: email, placeholder: "email@example.com", required: true }), o3("button", { id: "submitButton", type: "submit", tabIndex: 0, children: ["Sign in with ", provider.name] })] }), provider.type === "credentials" && o3("form", { action: provider.callbackUrl, method: "POST", children: [o3("input", { type: "hidden", name: "csrfToken", value: csrfToken }), Object.keys(provider.credentials).map((credential) => {
      return o3("div", { children: [o3("label", { className: "section-header", htmlFor: `input-${credential}-for-${provider.id}-provider`, children: provider.credentials[credential].label ?? credential }), o3("input", { name: credential, id: `input-${credential}-for-${provider.id}-provider`, type: provider.credentials[credential].type ?? "text", placeholder: provider.credentials[credential].placeholder ?? "", ...provider.credentials[credential] })] }, `input-group-${provider.id}`);
    }), o3("button", { id: "submitButton", type: "submit", tabIndex: 0, children: ["Sign in with ", provider.name] })] }), provider.type === "webauthn" && o3("form", { action: provider.callbackUrl, method: "POST", id: `${provider.id}-form`, children: [o3("input", { type: "hidden", name: "csrfToken", value: csrfToken }), Object.keys(provider.formFields).map((field) => {
      return o3("div", { children: [o3("label", { className: "section-header", htmlFor: `input-${field}-for-${provider.id}-provider`, children: provider.formFields[field].label ?? field }), o3("input", { name: field, "data-form-field": true, id: `input-${field}-for-${provider.id}-provider`, type: provider.formFields[field].type ?? "text", placeholder: provider.formFields[field].placeholder ?? "", ...provider.formFields[field] })] }, `input-group-${provider.id}`);
    }), o3("button", { id: `submitButton-${provider.id}`, type: "submit", tabIndex: 0, children: ["Sign in with ", provider.name] })] }), (provider.type === "email" || provider.type === "credentials" || provider.type === "webauthn") && i3 + 1 < providers.length && o3("hr", {})] }, provider.id);
  })] }), conditionalUIProviderID && ConditionalUIScript(conditionalUIProviderID)] });
}
__name(SigninPage, "SigninPage");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/signout.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function SignoutPage(props) {
  const { url, csrfToken, theme } = props;
  return o3("div", { className: "signout", children: [theme?.brandColor && o3("style", { dangerouslySetInnerHTML: {
    __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
  } }), theme?.buttonText && o3("style", { dangerouslySetInnerHTML: {
    __html: `
        :root {
          --button-text-color: ${theme.buttonText}
        }
      `
  } }), o3("div", { className: "card", children: [theme?.logo && o3("img", { src: theme.logo, alt: "Logo", className: "logo" }), o3("h1", { children: "Signout" }), o3("p", { children: "Are you sure you want to sign out?" }), o3("form", { action: url?.toString(), method: "POST", children: [o3("input", { type: "hidden", name: "csrfToken", value: csrfToken }), o3("button", { id: "submitButton", type: "submit", children: "Sign out" })] })] })] });
}
__name(SignoutPage, "SignoutPage");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/styles.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var styles_default = `:root {
  --border-width: 1px;
  --border-radius: 0.5rem;
  --color-error: #c94b4b;
  --color-info: #157efb;
  --color-info-hover: #0f6ddb;
  --color-info-text: #fff;
}

.__next-auth-theme-auto,
.__next-auth-theme-light {
  --color-background: #ececec;
  --color-background-hover: rgba(236, 236, 236, 0.8);
  --color-background-card: #fff;
  --color-text: #000;
  --color-primary: #444;
  --color-control-border: #bbb;
  --color-button-active-background: #f9f9f9;
  --color-button-active-border: #aaa;
  --color-separator: #ccc;
}

.__next-auth-theme-dark {
  --color-background: #161b22;
  --color-background-hover: rgba(22, 27, 34, 0.8);
  --color-background-card: #0d1117;
  --color-text: #fff;
  --color-primary: #ccc;
  --color-control-border: #555;
  --color-button-active-background: #060606;
  --color-button-active-border: #666;
  --color-separator: #444;
}

@media (prefers-color-scheme: dark) {
  .__next-auth-theme-auto {
    --color-background: #161b22;
    --color-background-hover: rgba(22, 27, 34, 0.8);
    --color-background-card: #0d1117;
    --color-text: #fff;
    --color-primary: #ccc;
    --color-control-border: #555;
    --color-button-active-background: #060606;
    --color-button-active-border: #666;
    --color-separator: #444;
  }

  button,
  a.button {
    color: var(--provider-dark-color, var(--color-primary)) !important;
    background-color: var(
      --provider-dark-bg,
      var(--color-background)
    ) !important;
  }

    :is(button,a.button):hover {
      background-color: var(
        --provider-dark-bg-hover,
        var(--color-background-hover)
      ) !important;
    }

    :is(button,a.button) span {
      color: var(--provider-dark-bg) !important;
    }
}

html {
  box-sizing: border-box;
}

*,
*:before,
*:after {
  box-sizing: inherit;
  margin: 0;
  padding: 0;
}

body {
  background-color: var(--color-background);
  margin: 0;
  padding: 0;
  font-family:
    ui-sans-serif,
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    "Helvetica Neue",
    Arial,
    "Noto Sans",
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol",
    "Noto Color Emoji";
}

h1 {
  margin-bottom: 1.5rem;
  padding: 0 1rem;
  font-weight: 400;
  color: var(--color-text);
}

p {
  margin-bottom: 1.5rem;
  padding: 0 1rem;
  color: var(--color-text);
}

form {
  margin: 0;
  padding: 0;
}

label {
  font-weight: 500;
  text-align: left;
  margin-bottom: 0.25rem;
  display: block;
  color: var(--color-text);
}

input[type] {
  box-sizing: border-box;
  display: block;
  width: 100%;
  padding: 0.5rem 1rem;
  border: var(--border-width) solid var(--color-control-border);
  background: var(--color-background-card);
  font-size: 1rem;
  border-radius: var(--border-radius);
  color: var(--color-text);
}

p {
  font-size: 1.1rem;
  line-height: 2rem;
}

a.button {
  text-decoration: none;
  line-height: 1rem;
}

a.button:link,
  a.button:visited {
    background-color: var(--color-background);
    color: var(--color-primary);
  }

button,
a.button {
  padding: 0.75rem 1rem;
  color: var(--provider-color, var(--color-primary));
  background-color: var(--provider-bg, var(--color-background));
  border: 1px solid #00000031;
  font-size: 0.9rem;
  height: 50px;
  border-radius: var(--border-radius);
  transition: background-color 250ms ease-in-out;
  font-weight: 300;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

:is(button,a.button):hover {
    background-color: var(--provider-bg-hover, var(--color-background-hover));
    cursor: pointer;
  }

:is(button,a.button):active {
    cursor: pointer;
  }

:is(button,a.button) span {
    color: #fff;
  }

#submitButton {
  color: var(--button-text-color, var(--color-info-text));
  background-color: var(--brand-color, var(--color-info));
  width: 100%;
}

#submitButton:hover {
    background-color: var(
      --button-hover-bg,
      var(--color-info-hover)
    ) !important;
  }

a.site {
  color: var(--color-primary);
  text-decoration: none;
  font-size: 1rem;
  line-height: 2rem;
}

a.site:hover {
    text-decoration: underline;
  }

.page {
  position: absolute;
  width: 100%;
  height: 100%;
  display: grid;
  place-items: center;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.page > div {
    text-align: center;
  }

.error a.button {
    padding-left: 2rem;
    padding-right: 2rem;
    margin-top: 0.5rem;
  }

.error .message {
    margin-bottom: 1.5rem;
  }

.signin input[type="text"] {
    margin-left: auto;
    margin-right: auto;
    display: block;
  }

.signin hr {
    display: block;
    border: 0;
    border-top: 1px solid var(--color-separator);
    margin: 2rem auto 1rem auto;
    overflow: visible;
  }

.signin hr::before {
      content: "or";
      background: var(--color-background-card);
      color: #888;
      padding: 0 0.4rem;
      position: relative;
      top: -0.7rem;
    }

.signin .error {
    background: #f5f5f5;
    font-weight: 500;
    border-radius: 0.3rem;
    background: var(--color-error);
  }

.signin .error p {
      text-align: left;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      line-height: 1.2rem;
      color: var(--color-info-text);
    }

.signin > div,
  .signin form {
    display: block;
  }

.signin > div input[type], .signin form input[type] {
      margin-bottom: 0.5rem;
    }

.signin > div button, .signin form button {
      width: 100%;
    }

.signin .provider + .provider {
    margin-top: 1rem;
  }

.logo {
  display: inline-block;
  max-width: 150px;
  margin: 1.25rem 0;
  max-height: 70px;
}

.card {
  background-color: var(--color-background-card);
  border-radius: 1rem;
  padding: 1.25rem 2rem;
}

.card .header {
    color: var(--color-primary);
  }

.card input[type]::-moz-placeholder {
    color: color-mix(
      in srgb,
      var(--color-text) 20%,
      var(--color-button-active-background)
    );
  }

.card input[type]::placeholder {
    color: color-mix(
      in srgb,
      var(--color-text) 20%,
      var(--color-button-active-background)
    );
  }

.card input[type] {
    background: color-mix(in srgb, var(--color-background-card) 95%, black);
  }

.section-header {
  color: var(--color-text);
}

@media screen and (min-width: 450px) {
  .card {
    margin: 2rem 0;
    width: 368px;
  }
}

@media screen and (max-width: 450px) {
  .card {
    margin: 1rem 0;
    width: 343px;
  }
}
`;

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/verify-request.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function VerifyRequestPage(props) {
  const { url, theme } = props;
  return o3("div", { className: "verify-request", children: [theme.brandColor && o3("style", { dangerouslySetInnerHTML: {
    __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
  } }), o3("div", { className: "card", children: [theme.logo && o3("img", { src: theme.logo, alt: "Logo", className: "logo" }), o3("h1", { children: "Check your email" }), o3("p", { children: "A sign in link has been sent to your email address." }), o3("p", { children: o3("a", { className: "site", href: url.origin, children: url.host }) })] })] });
}
__name(VerifyRequestPage, "VerifyRequestPage");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/pages/index.js
function send({ html, title: title2, status, cookies, theme, headTags }) {
  return {
    cookies,
    status,
    headers: { "Content-Type": "text/html" },
    body: `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>${styles_default}</style><title>${title2}</title>${headTags ?? ""}</head><body class="__next-auth-theme-${theme?.colorScheme ?? "auto"}"><div class="page">${k2(html)}</div></body></html>`
  };
}
__name(send, "send");
function renderPage(params) {
  const { url, theme, query, cookies, pages, providers } = params;
  return {
    csrf(skip, options, cookies2) {
      if (!skip) {
        return {
          headers: { "Content-Type": "application/json" },
          body: { csrfToken: options.csrfToken },
          cookies: cookies2
        };
      }
      options.logger.warn("csrf-disabled");
      cookies2.push({
        name: options.cookies.csrfToken.name,
        value: "",
        options: { ...options.cookies.csrfToken.options, maxAge: 0 }
      });
      return { status: 404, cookies: cookies2 };
    },
    providers(providers2) {
      return {
        headers: { "Content-Type": "application/json" },
        body: providers2.reduce((acc, { id, name, type: type2, signinUrl, callbackUrl }) => {
          acc[id] = { id, name, type: type2, signinUrl, callbackUrl };
          return acc;
        }, {})
      };
    },
    signin(providerId, error4) {
      if (providerId)
        throw new UnknownAction("Unsupported action");
      if (pages?.signIn) {
        let signinUrl = `${pages.signIn}${pages.signIn.includes("?") ? "&" : "?"}${new URLSearchParams({ callbackUrl: params.callbackUrl ?? "/" })}`;
        if (error4)
          signinUrl = `${signinUrl}&${new URLSearchParams({ error: error4 })}`;
        return { redirect: signinUrl, cookies };
      }
      const webauthnProvider = providers?.find((p5) => p5.type === "webauthn" && p5.enableConditionalUI && !!p5.simpleWebAuthnBrowserVersion);
      let simpleWebAuthnBrowserScript = "";
      if (webauthnProvider) {
        const { simpleWebAuthnBrowserVersion } = webauthnProvider;
        simpleWebAuthnBrowserScript = `<script src="https://unpkg.com/@simplewebauthn/browser@${simpleWebAuthnBrowserVersion}/dist/bundle/index.umd.min.js" crossorigin="anonymous"><\/script>`;
      }
      return send({
        cookies,
        theme,
        html: SigninPage({
          csrfToken: params.csrfToken,
          // We only want to render providers
          providers: params.providers?.filter((provider) => (
            // Always render oauth and email type providers
            ["email", "oauth", "oidc"].includes(provider.type) || // Only render credentials type provider if credentials are defined
            provider.type === "credentials" && provider.credentials || // Only render webauthn type provider if formFields are defined
            provider.type === "webauthn" && provider.formFields || // Don't render other provider types
            false
          )),
          callbackUrl: params.callbackUrl,
          theme: params.theme,
          error: error4,
          ...query
        }),
        title: "Sign In",
        headTags: simpleWebAuthnBrowserScript
      });
    },
    signout() {
      if (pages?.signOut)
        return { redirect: pages.signOut, cookies };
      return send({
        cookies,
        theme,
        html: SignoutPage({ csrfToken: params.csrfToken, url, theme }),
        title: "Sign Out"
      });
    },
    verifyRequest(props) {
      if (pages?.verifyRequest)
        return { redirect: pages.verifyRequest, cookies };
      return send({
        cookies,
        theme,
        html: VerifyRequestPage({ url, theme, ...props }),
        title: "Verify Request"
      });
    },
    error(error4) {
      if (pages?.error) {
        return {
          redirect: `${pages.error}${pages.error.includes("?") ? "&" : "?"}error=${error4}`,
          cookies
        };
      }
      return send({
        cookies,
        theme,
        // @ts-expect-error fix error type
        ...ErrorPage({ url, theme, error: error4 }),
        title: "Error"
      });
    }
  };
}
__name(renderPage, "renderPage");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/handle-login.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/date.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function fromDate(time4, date = Date.now()) {
  return new Date(date + time4 * 1e3);
}
__name(fromDate, "fromDate");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/handle-login.js
async function handleLoginOrRegister(sessionToken, _profile, _account, options) {
  if (!_account?.providerAccountId || !_account.type)
    throw new Error("Missing or invalid provider account");
  if (!["email", "oauth", "oidc", "webauthn"].includes(_account.type))
    throw new Error("Provider not supported");
  const { adapter, jwt: jwt2, events, session: { strategy: sessionStrategy, generateSessionToken } } = options;
  if (!adapter) {
    return { user: _profile, account: _account };
  }
  const profile3 = _profile;
  let account = _account;
  const { createUser, updateUser, getUser, getUserByAccount, getUserByEmail, linkAccount, createSession, getSessionAndUser, deleteSession } = adapter;
  let session2 = null;
  let user2 = null;
  let isNewUser = false;
  const useJwtSession = sessionStrategy === "jwt";
  if (sessionToken) {
    if (useJwtSession) {
      try {
        const salt = options.cookies.sessionToken.name;
        session2 = await jwt2.decode({ ...jwt2, token: sessionToken, salt });
        if (session2 && "sub" in session2 && session2.sub) {
          user2 = await getUser(session2.sub);
        }
      } catch {
      }
    } else {
      const userAndSession = await getSessionAndUser(sessionToken);
      if (userAndSession) {
        session2 = userAndSession.session;
        user2 = userAndSession.user;
      }
    }
  }
  if (account.type === "email") {
    const userByEmail = await getUserByEmail(profile3.email);
    if (userByEmail) {
      if (user2?.id !== userByEmail.id && !useJwtSession && sessionToken) {
        await deleteSession(sessionToken);
      }
      user2 = await updateUser({
        id: userByEmail.id,
        emailVerified: /* @__PURE__ */ new Date()
      });
      await events.updateUser?.({ user: user2 });
    } else {
      user2 = await createUser({ ...profile3, emailVerified: /* @__PURE__ */ new Date() });
      await events.createUser?.({ user: user2 });
      isNewUser = true;
    }
    session2 = useJwtSession ? {} : await createSession({
      sessionToken: generateSessionToken(),
      userId: user2.id,
      expires: fromDate(options.session.maxAge)
    });
    return { session: session2, user: user2, isNewUser };
  } else if (account.type === "webauthn") {
    const userByAccount2 = await getUserByAccount({
      providerAccountId: account.providerAccountId,
      provider: account.provider
    });
    if (userByAccount2) {
      if (user2) {
        if (userByAccount2.id === user2.id) {
          const currentAccount2 = { ...account, userId: user2.id };
          return { session: session2, user: user2, isNewUser, account: currentAccount2 };
        }
        throw new AccountNotLinked("The account is already associated with another user", { provider: account.provider });
      }
      session2 = useJwtSession ? {} : await createSession({
        sessionToken: generateSessionToken(),
        userId: userByAccount2.id,
        expires: fromDate(options.session.maxAge)
      });
      const currentAccount = {
        ...account,
        userId: userByAccount2.id
      };
      return {
        session: session2,
        user: userByAccount2,
        isNewUser,
        account: currentAccount
      };
    } else {
      if (user2) {
        await linkAccount({ ...account, userId: user2.id });
        await events.linkAccount?.({ user: user2, account, profile: profile3 });
        const currentAccount2 = { ...account, userId: user2.id };
        return { session: session2, user: user2, isNewUser, account: currentAccount2 };
      }
      const userByEmail = profile3.email ? await getUserByEmail(profile3.email) : null;
      if (userByEmail) {
        throw new AccountNotLinked("Another account already exists with the same e-mail address", { provider: account.provider });
      } else {
        user2 = await createUser({ ...profile3 });
      }
      await events.createUser?.({ user: user2 });
      await linkAccount({ ...account, userId: user2.id });
      await events.linkAccount?.({ user: user2, account, profile: profile3 });
      session2 = useJwtSession ? {} : await createSession({
        sessionToken: generateSessionToken(),
        userId: user2.id,
        expires: fromDate(options.session.maxAge)
      });
      const currentAccount = { ...account, userId: user2.id };
      return { session: session2, user: user2, isNewUser: true, account: currentAccount };
    }
  }
  const userByAccount = await getUserByAccount({
    providerAccountId: account.providerAccountId,
    provider: account.provider
  });
  if (userByAccount) {
    if (user2) {
      if (userByAccount.id === user2.id) {
        return { session: session2, user: user2, isNewUser };
      }
      throw new OAuthAccountNotLinked("The account is already associated with another user", { provider: account.provider });
    }
    session2 = useJwtSession ? {} : await createSession({
      sessionToken: generateSessionToken(),
      userId: userByAccount.id,
      expires: fromDate(options.session.maxAge)
    });
    return { session: session2, user: userByAccount, isNewUser };
  } else {
    const { provider: p5 } = options;
    const { type: type2, provider, providerAccountId, userId, ...tokenSet } = account;
    const defaults = { providerAccountId, provider, type: type2, userId };
    account = Object.assign(p5.account(tokenSet) ?? {}, defaults);
    if (user2) {
      await linkAccount({ ...account, userId: user2.id });
      await events.linkAccount?.({ user: user2, account, profile: profile3 });
      return { session: session2, user: user2, isNewUser };
    }
    const userByEmail = profile3.email ? await getUserByEmail(profile3.email) : null;
    if (userByEmail) {
      const provider2 = options.provider;
      if (provider2?.allowDangerousEmailAccountLinking) {
        user2 = userByEmail;
      } else {
        throw new OAuthAccountNotLinked("Another account already exists with the same e-mail address", { provider: account.provider });
      }
    } else {
      user2 = await createUser({ ...profile3, emailVerified: null });
    }
    await events.createUser?.({ user: user2 });
    await linkAccount({ ...account, userId: user2.id });
    await events.linkAccount?.({ user: user2, account, profile: profile3 });
    session2 = useJwtSession ? {} : await createSession({
      sessionToken: generateSessionToken(),
      userId: user2.id,
      expires: fromDate(options.session.maxAge)
    });
    return { session: session2, user: user2, isNewUser: true };
  }
}
__name(handleLoginOrRegister, "handleLoginOrRegister");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/callback.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/checks.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/oauth4webapi@2.17.0/node_modules/oauth4webapi/build/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var USER_AGENT;
if (typeof navigator === "undefined" || !"Cloudflare-Workers"?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "oauth4webapi";
  const VERSION = "v2.17.0";
  USER_AGENT = `${NAME}/${VERSION}`;
}
function looseInstanceOf(input, expected) {
  if (input == null) {
    return false;
  }
  try {
    return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];
  } catch {
    return false;
  }
}
__name(looseInstanceOf, "looseInstanceOf");
var clockSkew = Symbol();
var clockTolerance = Symbol();
var customFetch = Symbol();
var modifyAssertion = Symbol();
var jweDecrypt = Symbol();
var jwksCache = Symbol();
var useMtlsAlias = Symbol();
var encoder2 = new TextEncoder();
var decoder2 = new TextDecoder();
function buf(input) {
  if (typeof input === "string") {
    return encoder2.encode(input);
  }
  return decoder2.decode(input);
}
__name(buf, "buf");
var CHUNK_SIZE2 = 32768;
function encodeBase64Url(input) {
  if (input instanceof ArrayBuffer) {
    input = new Uint8Array(input);
  }
  const arr = [];
  for (let i3 = 0; i3 < input.byteLength; i3 += CHUNK_SIZE2) {
    arr.push(String.fromCharCode.apply(null, input.subarray(i3, i3 + CHUNK_SIZE2)));
  }
  return btoa(arr.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
__name(encodeBase64Url, "encodeBase64Url");
function decodeBase64Url(input) {
  try {
    const binary = atob(input.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, ""));
    const bytes = new Uint8Array(binary.length);
    for (let i3 = 0; i3 < binary.length; i3++) {
      bytes[i3] = binary.charCodeAt(i3);
    }
    return bytes;
  } catch (cause) {
    throw new OPE("The input to be decoded is not correctly encoded.", { cause });
  }
}
__name(decodeBase64Url, "decodeBase64Url");
function b64u(input) {
  if (typeof input === "string") {
    return decodeBase64Url(input);
  }
  return encodeBase64Url(input);
}
__name(b64u, "b64u");
var LRU = class {
  constructor(maxSize) {
    this.cache = /* @__PURE__ */ new Map();
    this._cache = /* @__PURE__ */ new Map();
    this.maxSize = maxSize;
  }
  get(key) {
    let v4 = this.cache.get(key);
    if (v4) {
      return v4;
    }
    if (v4 = this._cache.get(key)) {
      this.update(key, v4);
      return v4;
    }
    return void 0;
  }
  has(key) {
    return this.cache.has(key) || this._cache.has(key);
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.set(key, value);
    } else {
      this.update(key, value);
    }
    return this;
  }
  delete(key) {
    if (this.cache.has(key)) {
      return this.cache.delete(key);
    }
    if (this._cache.has(key)) {
      return this._cache.delete(key);
    }
    return false;
  }
  update(key, value) {
    this.cache.set(key, value);
    if (this.cache.size >= this.maxSize) {
      this._cache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
};
__name(LRU, "LRU");
var UnsupportedOperationError = class extends Error {
  constructor(message2) {
    super(message2 ?? "operation not supported");
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
__name(UnsupportedOperationError, "UnsupportedOperationError");
var OperationProcessingError = class extends Error {
  constructor(message2, options) {
    super(message2, options);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
__name(OperationProcessingError, "OperationProcessingError");
var OPE = OperationProcessingError;
var dpopNonces = new LRU(100);
function isCryptoKey2(key) {
  return key instanceof CryptoKey;
}
__name(isCryptoKey2, "isCryptoKey");
function isPrivateKey(key) {
  return isCryptoKey2(key) && key.type === "private";
}
__name(isPrivateKey, "isPrivateKey");
function isPublicKey(key) {
  return isCryptoKey2(key) && key.type === "public";
}
__name(isPublicKey, "isPublicKey");
function processDpopNonce(response) {
  try {
    const nonce2 = response.headers.get("dpop-nonce");
    if (nonce2) {
      dpopNonces.set(new URL(response.url).origin, nonce2);
    }
  } catch {
  }
  return response;
}
__name(processDpopNonce, "processDpopNonce");
function isJsonObject(input) {
  if (input === null || typeof input !== "object" || Array.isArray(input)) {
    return false;
  }
  return true;
}
__name(isJsonObject, "isJsonObject");
function prepareHeaders(input) {
  if (looseInstanceOf(input, Headers)) {
    input = Object.fromEntries(input.entries());
  }
  const headers = new Headers(input);
  if (USER_AGENT && !headers.has("user-agent")) {
    headers.set("user-agent", USER_AGENT);
  }
  if (headers.has("authorization")) {
    throw new TypeError('"options.headers" must not include the "authorization" header name');
  }
  if (headers.has("dpop")) {
    throw new TypeError('"options.headers" must not include the "dpop" header name');
  }
  return headers;
}
__name(prepareHeaders, "prepareHeaders");
function signal(value) {
  if (typeof value === "function") {
    value = value();
  }
  if (!(value instanceof AbortSignal)) {
    throw new TypeError('"options.signal" must return or be an instance of AbortSignal');
  }
  return value;
}
__name(signal, "signal");
async function discoveryRequest(issuerIdentifier, options) {
  if (!(issuerIdentifier instanceof URL)) {
    throw new TypeError('"issuerIdentifier" must be an instance of URL');
  }
  if (issuerIdentifier.protocol !== "https:" && issuerIdentifier.protocol !== "http:") {
    throw new TypeError('"issuer.protocol" must be "https:" or "http:"');
  }
  const url = new URL(issuerIdentifier.href);
  switch (options?.algorithm) {
    case void 0:
    case "oidc":
      url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace("//", "/");
      break;
    case "oauth2":
      if (url.pathname === "/") {
        url.pathname = ".well-known/oauth-authorization-server";
      } else {
        url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace("//", "/");
      }
      break;
    default:
      throw new TypeError('"options.algorithm" must be "oidc" (default), or "oauth2"');
  }
  const headers = prepareHeaders(options?.headers);
  headers.set("accept", "application/json");
  return (options?.[customFetch] || fetch)(url.href, {
    headers: Object.fromEntries(headers.entries()),
    method: "GET",
    redirect: "manual",
    signal: options?.signal ? signal(options.signal) : null
  }).then(processDpopNonce);
}
__name(discoveryRequest, "discoveryRequest");
function validateString(input) {
  return typeof input === "string" && input.length !== 0;
}
__name(validateString, "validateString");
async function processDiscoveryResponse(expectedIssuerIdentifier, response) {
  if (!(expectedIssuerIdentifier instanceof URL)) {
    throw new TypeError('"expectedIssuer" must be an instance of URL');
  }
  if (!looseInstanceOf(response, Response)) {
    throw new TypeError('"response" must be an instance of Response');
  }
  if (response.status !== 200) {
    throw new OPE('"response" is not a conform Authorization Server Metadata response');
  }
  assertReadableResponse(response);
  let json2;
  try {
    json2 = await response.json();
  } catch (cause) {
    throw new OPE('failed to parse "response" body as JSON', { cause });
  }
  if (!isJsonObject(json2)) {
    throw new OPE('"response" body must be a top level object');
  }
  if (!validateString(json2.issuer)) {
    throw new OPE('"response" body "issuer" property must be a non-empty string');
  }
  if (new URL(json2.issuer).href !== expectedIssuerIdentifier.href) {
    throw new OPE('"response" body "issuer" does not match "expectedIssuer"');
  }
  return json2;
}
__name(processDiscoveryResponse, "processDiscoveryResponse");
function randomBytes3() {
  return b64u(crypto.getRandomValues(new Uint8Array(32)));
}
__name(randomBytes3, "randomBytes");
function generateRandomCodeVerifier() {
  return randomBytes3();
}
__name(generateRandomCodeVerifier, "generateRandomCodeVerifier");
function generateRandomState() {
  return randomBytes3();
}
__name(generateRandomState, "generateRandomState");
function generateRandomNonce() {
  return randomBytes3();
}
__name(generateRandomNonce, "generateRandomNonce");
async function calculatePKCECodeChallenge(codeVerifier) {
  if (!validateString(codeVerifier)) {
    throw new TypeError('"codeVerifier" must be a non-empty string');
  }
  return b64u(await crypto.subtle.digest("SHA-256", buf(codeVerifier)));
}
__name(calculatePKCECodeChallenge, "calculatePKCECodeChallenge");
function getKeyAndKid(input) {
  if (input instanceof CryptoKey) {
    return { key: input };
  }
  if (!(input?.key instanceof CryptoKey)) {
    return {};
  }
  if (input.kid !== void 0 && !validateString(input.kid)) {
    throw new TypeError('"kid" must be a non-empty string');
  }
  return {
    key: input.key,
    kid: input.kid,
    modifyAssertion: input[modifyAssertion]
  };
}
__name(getKeyAndKid, "getKeyAndKid");
function formUrlEncode(token) {
  return encodeURIComponent(token).replace(/%20/g, "+");
}
__name(formUrlEncode, "formUrlEncode");
function clientSecretBasic(clientId, clientSecret) {
  const username = formUrlEncode(clientId);
  const password = formUrlEncode(clientSecret);
  const credentials = btoa(`${username}:${password}`);
  return `Basic ${credentials}`;
}
__name(clientSecretBasic, "clientSecretBasic");
function psAlg(key) {
  switch (key.algorithm.hash.name) {
    case "SHA-256":
      return "PS256";
    case "SHA-384":
      return "PS384";
    case "SHA-512":
      return "PS512";
    default:
      throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
__name(psAlg, "psAlg");
function rsAlg(key) {
  switch (key.algorithm.hash.name) {
    case "SHA-256":
      return "RS256";
    case "SHA-384":
      return "RS384";
    case "SHA-512":
      return "RS512";
    default:
      throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
__name(rsAlg, "rsAlg");
function esAlg(key) {
  switch (key.algorithm.namedCurve) {
    case "P-256":
      return "ES256";
    case "P-384":
      return "ES384";
    case "P-521":
      return "ES512";
    default:
      throw new UnsupportedOperationError("unsupported EcKeyAlgorithm namedCurve");
  }
}
__name(esAlg, "esAlg");
function keyToJws(key) {
  switch (key.algorithm.name) {
    case "RSA-PSS":
      return psAlg(key);
    case "RSASSA-PKCS1-v1_5":
      return rsAlg(key);
    case "ECDSA":
      return esAlg(key);
    case "Ed25519":
    case "Ed448":
      return "EdDSA";
    default:
      throw new UnsupportedOperationError("unsupported CryptoKey algorithm name");
  }
}
__name(keyToJws, "keyToJws");
function getClockSkew(client) {
  const skew2 = client?.[clockSkew];
  return typeof skew2 === "number" && Number.isFinite(skew2) ? skew2 : 0;
}
__name(getClockSkew, "getClockSkew");
function getClockTolerance(client) {
  const tolerance = client?.[clockTolerance];
  return typeof tolerance === "number" && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;
}
__name(getClockTolerance, "getClockTolerance");
function epochTime() {
  return Math.floor(Date.now() / 1e3);
}
__name(epochTime, "epochTime");
function clientAssertion(as, client) {
  const now2 = epochTime() + getClockSkew(client);
  return {
    jti: randomBytes3(),
    aud: [as.issuer, as.token_endpoint],
    exp: now2 + 60,
    iat: now2,
    nbf: now2,
    iss: client.client_id,
    sub: client.client_id
  };
}
__name(clientAssertion, "clientAssertion");
async function privateKeyJwt(as, client, key, kid, modifyAssertion2) {
  const header = { alg: keyToJws(key), kid };
  const payload = clientAssertion(as, client);
  modifyAssertion2?.(header, payload);
  return jwt(header, payload, key);
}
__name(privateKeyJwt, "privateKeyJwt");
function assertAs(as) {
  if (typeof as !== "object" || as === null) {
    throw new TypeError('"as" must be an object');
  }
  if (!validateString(as.issuer)) {
    throw new TypeError('"as.issuer" property must be a non-empty string');
  }
  return true;
}
__name(assertAs, "assertAs");
function assertClient(client) {
  if (typeof client !== "object" || client === null) {
    throw new TypeError('"client" must be an object');
  }
  if (!validateString(client.client_id)) {
    throw new TypeError('"client.client_id" property must be a non-empty string');
  }
  return true;
}
__name(assertClient, "assertClient");
function assertClientSecret(clientSecret) {
  if (!validateString(clientSecret)) {
    throw new TypeError('"client.client_secret" property must be a non-empty string');
  }
  return clientSecret;
}
__name(assertClientSecret, "assertClientSecret");
function assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {
  if (clientPrivateKey !== void 0) {
    throw new TypeError(`"options.clientPrivateKey" property must not be provided when ${clientAuthMethod} client authentication method is used.`);
  }
}
__name(assertNoClientPrivateKey, "assertNoClientPrivateKey");
function assertNoClientSecret(clientAuthMethod, clientSecret) {
  if (clientSecret !== void 0) {
    throw new TypeError(`"client.client_secret" property must not be provided when ${clientAuthMethod} client authentication method is used.`);
  }
}
__name(assertNoClientSecret, "assertNoClientSecret");
async function clientAuthentication(as, client, body, headers, clientPrivateKey) {
  body.delete("client_secret");
  body.delete("client_assertion_type");
  body.delete("client_assertion");
  switch (client.token_endpoint_auth_method) {
    case void 0:
    case "client_secret_basic": {
      assertNoClientPrivateKey("client_secret_basic", clientPrivateKey);
      headers.set("authorization", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));
      break;
    }
    case "client_secret_post": {
      assertNoClientPrivateKey("client_secret_post", clientPrivateKey);
      body.set("client_id", client.client_id);
      body.set("client_secret", assertClientSecret(client.client_secret));
      break;
    }
    case "private_key_jwt": {
      assertNoClientSecret("private_key_jwt", client.client_secret);
      if (clientPrivateKey === void 0) {
        throw new TypeError('"options.clientPrivateKey" must be provided when "client.token_endpoint_auth_method" is "private_key_jwt"');
      }
      const { key, kid, modifyAssertion: modifyAssertion2 } = getKeyAndKid(clientPrivateKey);
      if (!isPrivateKey(key)) {
        throw new TypeError('"options.clientPrivateKey.key" must be a private CryptoKey');
      }
      body.set("client_id", client.client_id);
      body.set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
      body.set("client_assertion", await privateKeyJwt(as, client, key, kid, modifyAssertion2));
      break;
    }
    case "tls_client_auth":
    case "self_signed_tls_client_auth":
    case "none": {
      assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);
      assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);
      body.set("client_id", client.client_id);
      break;
    }
    default:
      throw new UnsupportedOperationError("unsupported client token_endpoint_auth_method");
  }
}
__name(clientAuthentication, "clientAuthentication");
async function jwt(header, payload, key) {
  if (!key.usages.includes("sign")) {
    throw new TypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"');
  }
  const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;
  const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));
  return `${input}.${signature}`;
}
__name(jwt, "jwt");
async function dpopProofJwt(headers, options, url, htm, clockSkew2, accessToken) {
  const { privateKey, publicKey, nonce: nonce2 = dpopNonces.get(url.origin) } = options;
  if (!isPrivateKey(privateKey)) {
    throw new TypeError('"DPoP.privateKey" must be a private CryptoKey');
  }
  if (!isPublicKey(publicKey)) {
    throw new TypeError('"DPoP.publicKey" must be a public CryptoKey');
  }
  if (nonce2 !== void 0 && !validateString(nonce2)) {
    throw new TypeError('"DPoP.nonce" must be a non-empty string or undefined');
  }
  if (!publicKey.extractable) {
    throw new TypeError('"DPoP.publicKey.extractable" must be true');
  }
  const now2 = epochTime() + clockSkew2;
  const header = {
    alg: keyToJws(privateKey),
    typ: "dpop+jwt",
    jwk: await publicJwk(publicKey)
  };
  const payload = {
    iat: now2,
    jti: randomBytes3(),
    htm,
    nonce: nonce2,
    htu: `${url.origin}${url.pathname}`,
    ath: accessToken ? b64u(await crypto.subtle.digest("SHA-256", buf(accessToken))) : void 0
  };
  options[modifyAssertion]?.(header, payload);
  headers.set("dpop", await jwt(header, payload, privateKey));
}
__name(dpopProofJwt, "dpopProofJwt");
var jwkCache;
async function getSetPublicJwkCache(key) {
  const { kty, e: e2, n: n3, x: x3, y: y3, crv } = await crypto.subtle.exportKey("jwk", key);
  const jwk = { kty, e: e2, n: n3, x: x3, y: y3, crv };
  jwkCache.set(key, jwk);
  return jwk;
}
__name(getSetPublicJwkCache, "getSetPublicJwkCache");
async function publicJwk(key) {
  jwkCache || (jwkCache = /* @__PURE__ */ new WeakMap());
  return jwkCache.get(key) || getSetPublicJwkCache(key);
}
__name(publicJwk, "publicJwk");
function validateEndpoint(value, endpoint, useMtlsAlias2) {
  if (typeof value !== "string") {
    if (useMtlsAlias2) {
      throw new TypeError(`"as.mtls_endpoint_aliases.${endpoint}" must be a string`);
    }
    throw new TypeError(`"as.${endpoint}" must be a string`);
  }
  return new URL(value);
}
__name(validateEndpoint, "validateEndpoint");
function resolveEndpoint(as, endpoint, useMtlsAlias2 = false) {
  if (useMtlsAlias2 && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {
    return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias2);
  }
  return validateEndpoint(as[endpoint], endpoint, useMtlsAlias2);
}
__name(resolveEndpoint, "resolveEndpoint");
function alias2(client, options) {
  if (client.use_mtls_endpoint_aliases || options?.[useMtlsAlias]) {
    return true;
  }
  return false;
}
__name(alias2, "alias");
function isOAuth2Error(input) {
  const value = input;
  if (typeof value !== "object" || Array.isArray(value) || value === null) {
    return false;
  }
  return value.error !== void 0;
}
__name(isOAuth2Error, "isOAuth2Error");
function unquote(value) {
  if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
    return value.slice(1, -1);
  }
  return value;
}
__name(unquote, "unquote");
var SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;
var SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\-.^_`|~]+)(?=$|[ ,])/g;
function wwwAuth(scheme, params) {
  const arr = params.split(SPLIT_REGEXP).slice(1);
  if (!arr.length) {
    return { scheme: scheme.toLowerCase(), parameters: {} };
  }
  arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, "");
  const parameters = {};
  for (let i3 = 1; i3 < arr.length; i3 += 2) {
    const idx = i3;
    if (arr[idx][0] === '"') {
      while (arr[idx].slice(-1) !== '"' && ++i3 < arr.length) {
        arr[idx] += arr[i3];
      }
    }
    const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, "").toLowerCase();
    parameters[key] = unquote(arr[idx]);
  }
  return {
    scheme: scheme.toLowerCase(),
    parameters
  };
}
__name(wwwAuth, "wwwAuth");
function parseWwwAuthenticateChallenges(response) {
  if (!looseInstanceOf(response, Response)) {
    throw new TypeError('"response" must be an instance of Response');
  }
  const header = response.headers.get("www-authenticate");
  if (header === null) {
    return void 0;
  }
  const result = [];
  for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)) {
    result.push([scheme, index]);
  }
  if (!result.length) {
    return void 0;
  }
  const challenges = result.map(([scheme, indexOf], i3, others) => {
    const next = others[i3 + 1];
    let parameters;
    if (next) {
      parameters = header.slice(indexOf, next[1]);
    } else {
      parameters = header.slice(indexOf);
    }
    return wwwAuth(scheme, parameters);
  });
  return challenges;
}
__name(parseWwwAuthenticateChallenges, "parseWwwAuthenticateChallenges");
async function protectedResourceRequest(accessToken, method, url, headers, body, options) {
  if (!validateString(accessToken)) {
    throw new TypeError('"accessToken" must be a non-empty string');
  }
  if (!(url instanceof URL)) {
    throw new TypeError('"url" must be an instance of URL');
  }
  headers = prepareHeaders(headers);
  if (options?.DPoP === void 0) {
    headers.set("authorization", `Bearer ${accessToken}`);
  } else {
    await dpopProofJwt(headers, options.DPoP, url, method.toUpperCase(), getClockSkew({ [clockSkew]: options?.[clockSkew] }), accessToken);
    headers.set("authorization", `DPoP ${accessToken}`);
  }
  return (options?.[customFetch] || fetch)(url.href, {
    body,
    headers: Object.fromEntries(headers.entries()),
    method,
    redirect: "manual",
    signal: options?.signal ? signal(options.signal) : null
  }).then(processDpopNonce);
}
__name(protectedResourceRequest, "protectedResourceRequest");
async function userInfoRequest(as, client, accessToken, options) {
  assertAs(as);
  assertClient(client);
  const url = resolveEndpoint(as, "userinfo_endpoint", alias2(client, options));
  const headers = prepareHeaders(options?.headers);
  if (client.userinfo_signed_response_alg) {
    headers.set("accept", "application/jwt");
  } else {
    headers.set("accept", "application/json");
    headers.append("accept", "application/jwt");
  }
  return protectedResourceRequest(accessToken, "GET", url, headers, null, {
    ...options,
    [clockSkew]: getClockSkew(client)
  });
}
__name(userInfoRequest, "userInfoRequest");
var skipSubjectCheck = Symbol();
function getContentType(response) {
  return response.headers.get("content-type")?.split(";")[0];
}
__name(getContentType, "getContentType");
async function processUserInfoResponse(as, client, expectedSubject, response) {
  assertAs(as);
  assertClient(client);
  if (!looseInstanceOf(response, Response)) {
    throw new TypeError('"response" must be an instance of Response');
  }
  if (response.status !== 200) {
    throw new OPE('"response" is not a conform UserInfo Endpoint response');
  }
  let json2;
  if (getContentType(response) === "application/jwt") {
    assertReadableResponse(response);
    const { claims, jwt: jwt2 } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(void 0, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt]).then(validateOptionalAudience.bind(void 0, client.client_id)).then(validateOptionalIssuer.bind(void 0, as.issuer));
    jwtResponseBodies.set(response, jwt2);
    json2 = claims;
  } else {
    if (client.userinfo_signed_response_alg) {
      throw new OPE("JWT UserInfo Response expected");
    }
    assertReadableResponse(response);
    try {
      json2 = await response.json();
    } catch (cause) {
      throw new OPE('failed to parse "response" body as JSON', { cause });
    }
  }
  if (!isJsonObject(json2)) {
    throw new OPE('"response" body must be a top level object');
  }
  if (!validateString(json2.sub)) {
    throw new OPE('"response" body "sub" property must be a non-empty string');
  }
  switch (expectedSubject) {
    case skipSubjectCheck:
      break;
    default:
      if (!validateString(expectedSubject)) {
        throw new OPE('"expectedSubject" must be a non-empty string');
      }
      if (json2.sub !== expectedSubject) {
        throw new OPE('unexpected "response" body "sub" value');
      }
  }
  return json2;
}
__name(processUserInfoResponse, "processUserInfoResponse");
async function authenticatedRequest(as, client, method, url, body, headers, options) {
  await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);
  headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
  return (options?.[customFetch] || fetch)(url.href, {
    body,
    headers: Object.fromEntries(headers.entries()),
    method,
    redirect: "manual",
    signal: options?.signal ? signal(options.signal) : null
  }).then(processDpopNonce);
}
__name(authenticatedRequest, "authenticatedRequest");
async function tokenEndpointRequest(as, client, grantType, parameters, options) {
  const url = resolveEndpoint(as, "token_endpoint", alias2(client, options));
  parameters.set("grant_type", grantType);
  const headers = prepareHeaders(options?.headers);
  headers.set("accept", "application/json");
  if (options?.DPoP !== void 0) {
    await dpopProofJwt(headers, options.DPoP, url, "POST", getClockSkew(client));
  }
  return authenticatedRequest(as, client, "POST", url, parameters, headers, options);
}
__name(tokenEndpointRequest, "tokenEndpointRequest");
var idTokenClaims = /* @__PURE__ */ new WeakMap();
var jwtResponseBodies = /* @__PURE__ */ new WeakMap();
function getValidatedIdTokenClaims(ref) {
  if (!ref.id_token) {
    return void 0;
  }
  const claims = idTokenClaims.get(ref);
  if (!claims) {
    throw new TypeError('"ref" was already garbage collected or did not resolve from the proper sources');
  }
  return claims[0];
}
__name(getValidatedIdTokenClaims, "getValidatedIdTokenClaims");
async function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {
  assertAs(as);
  assertClient(client);
  if (!looseInstanceOf(response, Response)) {
    throw new TypeError('"response" must be an instance of Response');
  }
  if (response.status !== 200) {
    let err;
    if (err = await handleOAuthBodyError(response)) {
      return err;
    }
    throw new OPE('"response" is not a conform Token Endpoint response');
  }
  assertReadableResponse(response);
  let json2;
  try {
    json2 = await response.json();
  } catch (cause) {
    throw new OPE('failed to parse "response" body as JSON', { cause });
  }
  if (!isJsonObject(json2)) {
    throw new OPE('"response" body must be a top level object');
  }
  if (!validateString(json2.access_token)) {
    throw new OPE('"response" body "access_token" property must be a non-empty string');
  }
  if (!validateString(json2.token_type)) {
    throw new OPE('"response" body "token_type" property must be a non-empty string');
  }
  json2.token_type = json2.token_type.toLowerCase();
  if (json2.token_type !== "dpop" && json2.token_type !== "bearer") {
    throw new UnsupportedOperationError("unsupported `token_type` value");
  }
  if (json2.expires_in !== void 0 && (typeof json2.expires_in !== "number" || json2.expires_in <= 0)) {
    throw new OPE('"response" body "expires_in" property must be a positive number');
  }
  if (!ignoreRefreshToken && json2.refresh_token !== void 0 && !validateString(json2.refresh_token)) {
    throw new OPE('"response" body "refresh_token" property must be a non-empty string');
  }
  if (json2.scope !== void 0 && typeof json2.scope !== "string") {
    throw new OPE('"response" body "scope" property must be a string');
  }
  if (!ignoreIdToken) {
    if (json2.id_token !== void 0 && !validateString(json2.id_token)) {
      throw new OPE('"response" body "id_token" property must be a non-empty string');
    }
    if (json2.id_token) {
      const { claims, jwt: jwt2 } = await validateJwt(json2.id_token, checkSigningAlgorithm.bind(void 0, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt]).then(validatePresence.bind(void 0, ["aud", "exp", "iat", "iss", "sub"])).then(validateIssuer.bind(void 0, as.issuer)).then(validateAudience.bind(void 0, client.client_id));
      if (Array.isArray(claims.aud) && claims.aud.length !== 1) {
        if (claims.azp === void 0) {
          throw new OPE('ID Token "aud" (audience) claim includes additional untrusted audiences');
        }
        if (claims.azp !== client.client_id) {
          throw new OPE('unexpected ID Token "azp" (authorized party) claim value');
        }
      }
      if (claims.auth_time !== void 0 && (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {
        throw new OPE('ID Token "auth_time" (authentication time) must be a positive number');
      }
      idTokenClaims.set(json2, [claims, jwt2]);
    }
  }
  return json2;
}
__name(processGenericAccessTokenResponse, "processGenericAccessTokenResponse");
function validateOptionalAudience(expected, result) {
  if (result.claims.aud !== void 0) {
    return validateAudience(expected, result);
  }
  return result;
}
__name(validateOptionalAudience, "validateOptionalAudience");
function validateAudience(expected, result) {
  if (Array.isArray(result.claims.aud)) {
    if (!result.claims.aud.includes(expected)) {
      throw new OPE('unexpected JWT "aud" (audience) claim value');
    }
  } else if (result.claims.aud !== expected) {
    throw new OPE('unexpected JWT "aud" (audience) claim value');
  }
  return result;
}
__name(validateAudience, "validateAudience");
function validateOptionalIssuer(expected, result) {
  if (result.claims.iss !== void 0) {
    return validateIssuer(expected, result);
  }
  return result;
}
__name(validateOptionalIssuer, "validateOptionalIssuer");
function validateIssuer(expected, result) {
  if (result.claims.iss !== expected) {
    throw new OPE('unexpected JWT "iss" (issuer) claim value');
  }
  return result;
}
__name(validateIssuer, "validateIssuer");
var branded = /* @__PURE__ */ new WeakSet();
function brand(searchParams) {
  branded.add(searchParams);
  return searchParams;
}
__name(brand, "brand");
async function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {
  assertAs(as);
  assertClient(client);
  if (!branded.has(callbackParameters)) {
    throw new TypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()');
  }
  if (!validateString(redirectUri)) {
    throw new TypeError('"redirectUri" must be a non-empty string');
  }
  if (!validateString(codeVerifier)) {
    throw new TypeError('"codeVerifier" must be a non-empty string');
  }
  const code = getURLSearchParameter(callbackParameters, "code");
  if (!code) {
    throw new OPE('no authorization code in "callbackParameters"');
  }
  const parameters = new URLSearchParams(options?.additionalParameters);
  parameters.set("redirect_uri", redirectUri);
  parameters.set("code_verifier", codeVerifier);
  parameters.set("code", code);
  return tokenEndpointRequest(as, client, "authorization_code", parameters, options);
}
__name(authorizationCodeGrantRequest, "authorizationCodeGrantRequest");
var jwtClaimNames = {
  aud: "audience",
  c_hash: "code hash",
  client_id: "client id",
  exp: "expiration time",
  iat: "issued at",
  iss: "issuer",
  jti: "jwt id",
  nonce: "nonce",
  s_hash: "state hash",
  sub: "subject",
  ath: "access token hash",
  htm: "http method",
  htu: "http uri",
  cnf: "confirmation"
};
function validatePresence(required, result) {
  for (const claim of required) {
    if (result.claims[claim] === void 0) {
      throw new OPE(`JWT "${claim}" (${jwtClaimNames[claim]}) claim missing`);
    }
  }
  return result;
}
__name(validatePresence, "validatePresence");
var expectNoNonce = Symbol();
var skipAuthTimeCheck = Symbol();
async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {
  const result = await processGenericAccessTokenResponse(as, client, response);
  if (isOAuth2Error(result)) {
    return result;
  }
  if (!validateString(result.id_token)) {
    throw new OPE('"response" body "id_token" property must be a non-empty string');
  }
  maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);
  const claims = getValidatedIdTokenClaims(result);
  if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === void 0) {
    throw new OPE('ID Token "auth_time" (authentication time) claim missing');
  }
  if (maxAge !== skipAuthTimeCheck) {
    if (typeof maxAge !== "number" || maxAge < 0) {
      throw new TypeError('"maxAge" must be a non-negative number');
    }
    const now2 = epochTime() + getClockSkew(client);
    const tolerance = getClockTolerance(client);
    if (claims.auth_time + maxAge < now2 - tolerance) {
      throw new OPE("too much time has elapsed since the last End-User authentication");
    }
  }
  switch (expectedNonce) {
    case void 0:
    case expectNoNonce:
      if (claims.nonce !== void 0) {
        throw new OPE('unexpected ID Token "nonce" claim value');
      }
      break;
    default:
      if (!validateString(expectedNonce)) {
        throw new TypeError('"expectedNonce" must be a non-empty string');
      }
      if (claims.nonce === void 0) {
        throw new OPE('ID Token "nonce" claim missing');
      }
      if (claims.nonce !== expectedNonce) {
        throw new OPE('unexpected ID Token "nonce" claim value');
      }
  }
  return result;
}
__name(processAuthorizationCodeOpenIDResponse, "processAuthorizationCodeOpenIDResponse");
async function processAuthorizationCodeOAuth2Response(as, client, response) {
  const result = await processGenericAccessTokenResponse(as, client, response, true);
  if (isOAuth2Error(result)) {
    return result;
  }
  if (result.id_token !== void 0) {
    if (typeof result.id_token === "string" && result.id_token.length) {
      throw new OPE("Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing");
    }
    delete result.id_token;
  }
  return result;
}
__name(processAuthorizationCodeOAuth2Response, "processAuthorizationCodeOAuth2Response");
function assertReadableResponse(response) {
  if (response.bodyUsed) {
    throw new TypeError('"response" body has been used already');
  }
}
__name(assertReadableResponse, "assertReadableResponse");
async function handleOAuthBodyError(response) {
  if (response.status > 399 && response.status < 500) {
    assertReadableResponse(response);
    try {
      const json2 = await response.json();
      if (isJsonObject(json2) && typeof json2.error === "string" && json2.error.length) {
        if (json2.error_description !== void 0 && typeof json2.error_description !== "string") {
          delete json2.error_description;
        }
        if (json2.error_uri !== void 0 && typeof json2.error_uri !== "string") {
          delete json2.error_uri;
        }
        if (json2.algs !== void 0 && typeof json2.algs !== "string") {
          delete json2.algs;
        }
        if (json2.scope !== void 0 && typeof json2.scope !== "string") {
          delete json2.scope;
        }
        return json2;
      }
    } catch {
    }
  }
  return void 0;
}
__name(handleOAuthBodyError, "handleOAuthBodyError");
function checkRsaKeyAlgorithm(algorithm) {
  if (typeof algorithm.modulusLength !== "number" || algorithm.modulusLength < 2048) {
    throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);
  }
}
__name(checkRsaKeyAlgorithm, "checkRsaKeyAlgorithm");
function ecdsaHashName(namedCurve) {
  switch (namedCurve) {
    case "P-256":
      return "SHA-256";
    case "P-384":
      return "SHA-384";
    case "P-521":
      return "SHA-512";
    default:
      throw new UnsupportedOperationError();
  }
}
__name(ecdsaHashName, "ecdsaHashName");
function keyToSubtle(key) {
  switch (key.algorithm.name) {
    case "ECDSA":
      return {
        name: key.algorithm.name,
        hash: ecdsaHashName(key.algorithm.namedCurve)
      };
    case "RSA-PSS": {
      checkRsaKeyAlgorithm(key.algorithm);
      switch (key.algorithm.hash.name) {
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
          return {
            name: key.algorithm.name,
            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3
          };
        default:
          throw new UnsupportedOperationError();
      }
    }
    case "RSASSA-PKCS1-v1_5":
      checkRsaKeyAlgorithm(key.algorithm);
      return key.algorithm.name;
    case "Ed448":
    case "Ed25519":
      return key.algorithm.name;
  }
  throw new UnsupportedOperationError();
}
__name(keyToSubtle, "keyToSubtle");
var noSignatureCheck = Symbol();
async function validateJwsSignature(protectedHeader, payload, key, signature) {
  const input = `${protectedHeader}.${payload}`;
  const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));
  if (!verified) {
    throw new OPE("JWT signature verification failed");
  }
}
__name(validateJwsSignature, "validateJwsSignature");
async function validateJwt(jws, checkAlg, getKey, clockSkew2, clockTolerance2, decryptJwt) {
  let { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(".");
  if (length === 5) {
    if (decryptJwt !== void 0) {
      jws = await decryptJwt(jws);
      ({ 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split("."));
    } else {
      throw new UnsupportedOperationError("JWE structure JWTs are not supported");
    }
  }
  if (length !== 3) {
    throw new OPE("Invalid JWT");
  }
  let header;
  try {
    header = JSON.parse(buf(b64u(protectedHeader)));
  } catch (cause) {
    throw new OPE("failed to parse JWT Header body as base64url encoded JSON", { cause });
  }
  if (!isJsonObject(header)) {
    throw new OPE("JWT Header must be a top level object");
  }
  checkAlg(header);
  if (header.crit !== void 0) {
    throw new OPE('unexpected JWT "crit" header parameter');
  }
  const signature = b64u(encodedSignature);
  let key;
  if (getKey !== noSignatureCheck) {
    key = await getKey(header);
    await validateJwsSignature(protectedHeader, payload, key, signature);
  }
  let claims;
  try {
    claims = JSON.parse(buf(b64u(payload)));
  } catch (cause) {
    throw new OPE("failed to parse JWT Payload body as base64url encoded JSON", { cause });
  }
  if (!isJsonObject(claims)) {
    throw new OPE("JWT Payload must be a top level object");
  }
  const now2 = epochTime() + clockSkew2;
  if (claims.exp !== void 0) {
    if (typeof claims.exp !== "number") {
      throw new OPE('unexpected JWT "exp" (expiration time) claim type');
    }
    if (claims.exp <= now2 - clockTolerance2) {
      throw new OPE('unexpected JWT "exp" (expiration time) claim value, timestamp is <= now()');
    }
  }
  if (claims.iat !== void 0) {
    if (typeof claims.iat !== "number") {
      throw new OPE('unexpected JWT "iat" (issued at) claim type');
    }
  }
  if (claims.iss !== void 0) {
    if (typeof claims.iss !== "string") {
      throw new OPE('unexpected JWT "iss" (issuer) claim type');
    }
  }
  if (claims.nbf !== void 0) {
    if (typeof claims.nbf !== "number") {
      throw new OPE('unexpected JWT "nbf" (not before) claim type');
    }
    if (claims.nbf > now2 + clockTolerance2) {
      throw new OPE('unexpected JWT "nbf" (not before) claim value, timestamp is > now()');
    }
  }
  if (claims.aud !== void 0) {
    if (typeof claims.aud !== "string" && !Array.isArray(claims.aud)) {
      throw new OPE('unexpected JWT "aud" (audience) claim type');
    }
  }
  return { header, claims, signature, key, jwt: jws };
}
__name(validateJwt, "validateJwt");
function checkSigningAlgorithm(client, issuer, header) {
  if (client !== void 0) {
    if (header.alg !== client) {
      throw new OPE('unexpected JWT "alg" header parameter');
    }
    return;
  }
  if (Array.isArray(issuer)) {
    if (!issuer.includes(header.alg)) {
      throw new OPE('unexpected JWT "alg" header parameter');
    }
    return;
  }
  if (header.alg !== "RS256") {
    throw new OPE('unexpected JWT "alg" header parameter');
  }
}
__name(checkSigningAlgorithm, "checkSigningAlgorithm");
function getURLSearchParameter(parameters, name) {
  const { 0: value, length } = parameters.getAll(name);
  if (length > 1) {
    throw new OPE(`"${name}" parameter must be provided only once`);
  }
  return value;
}
__name(getURLSearchParameter, "getURLSearchParameter");
var skipStateCheck = Symbol();
var expectNoState = Symbol();
function validateAuthResponse(as, client, parameters, expectedState) {
  assertAs(as);
  assertClient(client);
  if (parameters instanceof URL) {
    parameters = parameters.searchParams;
  }
  if (!(parameters instanceof URLSearchParams)) {
    throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');
  }
  if (getURLSearchParameter(parameters, "response")) {
    throw new OPE('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');
  }
  const iss = getURLSearchParameter(parameters, "iss");
  const state2 = getURLSearchParameter(parameters, "state");
  if (!iss && as.authorization_response_iss_parameter_supported) {
    throw new OPE('response parameter "iss" (issuer) missing');
  }
  if (iss && iss !== as.issuer) {
    throw new OPE('unexpected "iss" (issuer) response parameter value');
  }
  switch (expectedState) {
    case void 0:
    case expectNoState:
      if (state2 !== void 0) {
        throw new OPE('unexpected "state" response parameter encountered');
      }
      break;
    case skipStateCheck:
      break;
    default:
      if (!validateString(expectedState)) {
        throw new OPE('"expectedState" must be a non-empty string');
      }
      if (state2 === void 0) {
        throw new OPE('response parameter "state" missing');
      }
      if (state2 !== expectedState) {
        throw new OPE('unexpected "state" response parameter value');
      }
  }
  const error4 = getURLSearchParameter(parameters, "error");
  if (error4) {
    return {
      error: error4,
      error_description: getURLSearchParameter(parameters, "error_description"),
      error_uri: getURLSearchParameter(parameters, "error_uri")
    };
  }
  const id_token = getURLSearchParameter(parameters, "id_token");
  const token = getURLSearchParameter(parameters, "token");
  if (id_token !== void 0 || token !== void 0) {
    throw new UnsupportedOperationError("implicit and hybrid flows are not supported");
  }
  return brand(new URLSearchParams(parameters));
}
__name(validateAuthResponse, "validateAuthResponse");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/checks.js
var COOKIE_TTL = 60 * 15;
async function sealCookie(name, payload, options) {
  const { cookies, logger: logger2 } = options;
  const cookie = cookies[name];
  const expires = /* @__PURE__ */ new Date();
  expires.setTime(expires.getTime() + COOKIE_TTL * 1e3);
  logger2.debug(`CREATE_${name.toUpperCase()}`, {
    name: cookie.name,
    payload,
    COOKIE_TTL,
    expires
  });
  const encoded = await encode4({
    ...options.jwt,
    maxAge: COOKIE_TTL,
    token: { value: payload },
    salt: cookie.name
  });
  const cookieOptions = { ...cookie.options, expires };
  return { name: cookie.name, value: encoded, options: cookieOptions };
}
__name(sealCookie, "sealCookie");
async function parseCookie2(name, value, options) {
  try {
    const { logger: logger2, cookies, jwt: jwt2 } = options;
    logger2.debug(`PARSE_${name.toUpperCase()}`, { cookie: value });
    if (!value)
      throw new InvalidCheck(`${name} cookie was missing`);
    const parsed = await decode4({
      ...jwt2,
      token: value,
      salt: cookies[name].name
    });
    if (parsed?.value)
      return parsed.value;
    throw new Error("Invalid cookie");
  } catch (error4) {
    throw new InvalidCheck(`${name} value could not be parsed`, {
      cause: error4
    });
  }
}
__name(parseCookie2, "parseCookie");
function clearCookie(name, options, resCookies) {
  const { logger: logger2, cookies } = options;
  const cookie = cookies[name];
  logger2.debug(`CLEAR_${name.toUpperCase()}`, { cookie });
  resCookies.push({
    name: cookie.name,
    value: "",
    options: { ...cookies[name].options, maxAge: 0 }
  });
}
__name(clearCookie, "clearCookie");
function useCookie(check2, name) {
  return async function(cookies, resCookies, options) {
    const { provider, logger: logger2 } = options;
    if (!provider?.checks?.includes(check2))
      return;
    const cookieValue = cookies?.[options.cookies[name].name];
    logger2.debug(`USE_${name.toUpperCase()}`, { value: cookieValue });
    const parsed = await parseCookie2(name, cookieValue, options);
    clearCookie(name, options, resCookies);
    return parsed;
  };
}
__name(useCookie, "useCookie");
var pkce = {
  /** Creates a PKCE code challenge and verifier pair. The verifier in stored in the cookie. */
  async create(options) {
    const code_verifier = generateRandomCodeVerifier();
    const value = await calculatePKCECodeChallenge(code_verifier);
    const cookie = await sealCookie("pkceCodeVerifier", code_verifier, options);
    return { cookie, value };
  },
  /**
   * Returns code_verifier if the provider is configured to use PKCE,
   * and clears the container cookie afterwards.
   * An error is thrown if the code_verifier is missing or invalid.
   */
  use: useCookie("pkce", "pkceCodeVerifier")
};
var STATE_MAX_AGE = 60 * 15;
var encodedStateSalt = "encodedState";
var state = {
  /** Creates a state cookie with an optionally encoded body. */
  async create(options, origin) {
    const { provider } = options;
    if (!provider.checks.includes("state")) {
      if (origin) {
        throw new InvalidCheck("State data was provided but the provider is not configured to use state");
      }
      return;
    }
    const payload = {
      origin,
      random: generateRandomState()
    };
    const value = await encode4({
      secret: options.jwt.secret,
      token: payload,
      salt: encodedStateSalt,
      maxAge: STATE_MAX_AGE
    });
    const cookie = await sealCookie("state", value, options);
    return { cookie, value };
  },
  /**
   * Returns state if the provider is configured to use state,
   * and clears the container cookie afterwards.
   * An error is thrown if the state is missing or invalid.
   */
  use: useCookie("state", "state"),
  /** Decodes the state. If it could not be decoded, it throws an error. */
  async decode(state2, options) {
    try {
      options.logger.debug("DECODE_STATE", { state: state2 });
      const payload = await decode4({
        secret: options.jwt.secret,
        token: state2,
        salt: encodedStateSalt
      });
      if (payload)
        return payload;
      throw new Error("Invalid state");
    } catch (error4) {
      throw new InvalidCheck("State could not be decoded", { cause: error4 });
    }
  }
};
var nonce = {
  async create(options) {
    if (!options.provider.checks.includes("nonce"))
      return;
    const value = generateRandomNonce();
    const cookie = await sealCookie("nonce", value, options);
    return { cookie, value };
  },
  /**
   * Returns nonce if the provider is configured to use nonce,
   * and clears the container cookie afterwards.
   * An error is thrown if the nonce is missing or invalid.
   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes
   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce
   */
  use: useCookie("nonce", "nonce")
};
var WEBAUTHN_CHALLENGE_MAX_AGE = 60 * 15;
var webauthnChallengeSalt = "encodedWebauthnChallenge";
var webauthnChallenge = {
  async create(options, challenge, registerData) {
    return {
      cookie: await sealCookie("webauthnChallenge", await encode4({
        secret: options.jwt.secret,
        token: { challenge, registerData },
        salt: webauthnChallengeSalt,
        maxAge: WEBAUTHN_CHALLENGE_MAX_AGE
      }), options)
    };
  },
  /** Returns WebAuthn challenge if present. */
  async use(options, cookies, resCookies) {
    const cookieValue = cookies?.[options.cookies.webauthnChallenge.name];
    const parsed = await parseCookie2("webauthnChallenge", cookieValue, options);
    const payload = await decode4({
      secret: options.jwt.secret,
      token: parsed,
      salt: webauthnChallengeSalt
    });
    clearCookie("webauthnChallenge", options, resCookies);
    if (!payload)
      throw new InvalidCheck("WebAuthn challenge was missing");
    return payload;
  }
};

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/oauth/callback.js
async function handleOAuth(params, cookies, options) {
  const { logger: logger2, provider } = options;
  let as;
  const { token, userinfo } = provider;
  if ((!token?.url || token.url.host === "authjs.dev") && (!userinfo?.url || userinfo.url.host === "authjs.dev")) {
    const issuer = new URL(provider.issuer);
    const discoveryResponse = await discoveryRequest(issuer);
    const discoveredAs = await processDiscoveryResponse(issuer, discoveryResponse);
    if (!discoveredAs.token_endpoint)
      throw new TypeError("TODO: Authorization server did not provide a token endpoint.");
    if (!discoveredAs.userinfo_endpoint)
      throw new TypeError("TODO: Authorization server did not provide a userinfo endpoint.");
    as = discoveredAs;
  } else {
    as = {
      issuer: provider.issuer ?? "https://authjs.dev",
      // TODO: review fallback issuer
      token_endpoint: token?.url.toString(),
      userinfo_endpoint: userinfo?.url.toString()
    };
  }
  const client = {
    client_id: provider.clientId,
    client_secret: provider.clientSecret,
    ...provider.client
  };
  const resCookies = [];
  const state2 = await state.use(cookies, resCookies, options);
  const codeGrantParams = validateAuthResponse(as, client, new URLSearchParams(params), provider.checks.includes("state") ? state2 : skipStateCheck);
  if (isOAuth2Error(codeGrantParams)) {
    const cause = { providerId: provider.id, ...codeGrantParams };
    logger2.debug("OAuthCallbackError", cause);
    throw new OAuthCallbackError("OAuth Provider returned an error", cause);
  }
  const codeVerifier = await pkce.use(cookies, resCookies, options);
  let redirect_uri = provider.callbackUrl;
  if (!options.isOnRedirectProxy && provider.redirectProxyUrl) {
    redirect_uri = provider.redirectProxyUrl;
  }
  let codeGrantResponse = await authorizationCodeGrantRequest(
    as,
    client,
    codeGrantParams,
    redirect_uri,
    codeVerifier ?? "auth",
    // TODO: review fallback code verifier,
    {
      [customFetch]: (...args) => {
        if (!provider.checks.includes("pkce") && args[1]?.body instanceof URLSearchParams) {
          args[1].body.delete("code_verifier");
        }
        return fetch(...args);
      },
      clientPrivateKey: provider.token?.clientPrivateKey
    }
  );
  if (provider.token?.conform) {
    codeGrantResponse = await provider.token.conform(codeGrantResponse.clone()) ?? codeGrantResponse;
  }
  let challenges;
  if (challenges = parseWwwAuthenticateChallenges(codeGrantResponse)) {
    for (const challenge of challenges) {
      console.log("challenge", challenge);
    }
    throw new Error("TODO: Handle www-authenticate challenges as needed");
  }
  let profile3 = {};
  let tokens;
  if (isOIDCProvider(provider)) {
    const nonce2 = await nonce.use(cookies, resCookies, options);
    const processedCodeResponse = await processAuthorizationCodeOpenIDResponse(as, client, codeGrantResponse, nonce2 ?? expectNoNonce);
    if (isOAuth2Error(processedCodeResponse)) {
      console.log("error", processedCodeResponse);
      throw new Error("TODO: Handle OIDC response body error");
    }
    const idTokenClaims2 = getValidatedIdTokenClaims(processedCodeResponse);
    profile3 = idTokenClaims2;
    if (provider.idToken === false) {
      const userinfoResponse = await userInfoRequest(as, client, processedCodeResponse.access_token);
      profile3 = await processUserInfoResponse(as, client, idTokenClaims2.sub, userinfoResponse);
    }
    tokens = processedCodeResponse;
  } else {
    const processedCodeResponse = await processAuthorizationCodeOAuth2Response(as, client, codeGrantResponse);
    tokens = processedCodeResponse;
    if (isOAuth2Error(processedCodeResponse)) {
      console.log("error", processedCodeResponse);
      throw new Error("TODO: Handle OAuth 2.0 response body error");
    }
    if (userinfo?.request) {
      const _profile = await userinfo.request({ tokens, provider });
      if (_profile instanceof Object)
        profile3 = _profile;
    } else if (userinfo?.url) {
      const userinfoResponse = await userInfoRequest(as, client, processedCodeResponse.access_token);
      profile3 = await userinfoResponse.json();
    } else {
      throw new TypeError("No userinfo endpoint configured");
    }
  }
  if (tokens.expires_in) {
    tokens.expires_at = Math.floor(Date.now() / 1e3) + Number(tokens.expires_in);
  }
  const profileResult = await getUserAndAccount(profile3, provider, tokens, logger2);
  return { ...profileResult, profile: profile3, cookies: resCookies };
}
__name(handleOAuth, "handleOAuth");
async function getUserAndAccount(OAuthProfile, provider, tokens, logger2) {
  try {
    const userFromProfile = await provider.profile(OAuthProfile, tokens);
    const user2 = {
      ...userFromProfile,
      id: crypto.randomUUID(),
      email: userFromProfile.email?.toLowerCase()
    };
    return {
      user: user2,
      account: {
        ...tokens,
        provider: provider.id,
        type: provider.type,
        providerAccountId: userFromProfile.id ?? crypto.randomUUID()
      }
    };
  } catch (e2) {
    logger2.debug("getProfile error details", OAuthProfile);
    logger2.error(new OAuthProfileParseError(e2, { provider: provider.id }));
  }
}
__name(getUserAndAccount, "getUserAndAccount");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/webauthn-utils.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function inferWebAuthnOptions(action, loggedIn, userInfoResponse) {
  const { user: user2, exists: exists3 = false } = userInfoResponse ?? {};
  switch (action) {
    case "authenticate": {
      return "authenticate";
    }
    case "register": {
      if (user2 && loggedIn === exists3)
        return "register";
      break;
    }
    case void 0: {
      if (!loggedIn) {
        if (user2) {
          if (exists3) {
            return "authenticate";
          } else {
            return "register";
          }
        } else {
          return "authenticate";
        }
      }
      break;
    }
  }
  return null;
}
__name(inferWebAuthnOptions, "inferWebAuthnOptions");
async function getRegistrationResponse(options, request3, user2, resCookies) {
  const regOptions = await getRegistrationOptions(options, request3, user2);
  const { cookie } = await webauthnChallenge.create(options, regOptions.challenge, user2);
  return {
    status: 200,
    cookies: [...resCookies ?? [], cookie],
    body: {
      action: "register",
      options: regOptions
    },
    headers: {
      "Content-Type": "application/json"
    }
  };
}
__name(getRegistrationResponse, "getRegistrationResponse");
async function getAuthenticationResponse(options, request3, user2, resCookies) {
  const authOptions = await getAuthenticationOptions(options, request3, user2);
  const { cookie } = await webauthnChallenge.create(options, authOptions.challenge);
  return {
    status: 200,
    cookies: [...resCookies ?? [], cookie],
    body: {
      action: "authenticate",
      options: authOptions
    },
    headers: {
      "Content-Type": "application/json"
    }
  };
}
__name(getAuthenticationResponse, "getAuthenticationResponse");
async function verifyAuthenticate(options, request3, resCookies) {
  const { adapter, provider } = options;
  const data = request3.body && typeof request3.body.data === "string" ? JSON.parse(request3.body.data) : void 0;
  if (!data || typeof data !== "object" || !("id" in data) || typeof data.id !== "string") {
    throw new AuthError("Invalid WebAuthn Authentication response");
  }
  const credentialID = toBase64(fromBase64(data.id));
  const authenticator = await adapter.getAuthenticator(credentialID);
  if (!authenticator) {
    throw new AuthError(`WebAuthn authenticator not found in database: ${JSON.stringify({
      credentialID
    })}`);
  }
  const { challenge: expectedChallenge } = await webauthnChallenge.use(options, request3.cookies, resCookies);
  let verification;
  try {
    const relayingParty = provider.getRelayingParty(options, request3);
    verification = await provider.simpleWebAuthn.verifyAuthenticationResponse({
      ...provider.verifyAuthenticationOptions,
      expectedChallenge,
      response: data,
      authenticator: fromAdapterAuthenticator(authenticator),
      expectedOrigin: relayingParty.origin,
      expectedRPID: relayingParty.id
    });
  } catch (e2) {
    throw new WebAuthnVerificationError(e2);
  }
  const { verified, authenticationInfo } = verification;
  if (!verified) {
    throw new WebAuthnVerificationError("WebAuthn authentication response could not be verified");
  }
  try {
    const { newCounter } = authenticationInfo;
    await adapter.updateAuthenticatorCounter(authenticator.credentialID, newCounter);
  } catch (e2) {
    throw new AdapterError(`Failed to update authenticator counter. This may cause future authentication attempts to fail. ${JSON.stringify({
      credentialID,
      oldCounter: authenticator.counter,
      newCounter: authenticationInfo.newCounter
    })}`, e2);
  }
  const account = await adapter.getAccount(authenticator.providerAccountId, provider.id);
  if (!account) {
    throw new AuthError(`WebAuthn account not found in database: ${JSON.stringify({
      credentialID,
      providerAccountId: authenticator.providerAccountId
    })}`);
  }
  const user2 = await adapter.getUser(account.userId);
  if (!user2) {
    throw new AuthError(`WebAuthn user not found in database: ${JSON.stringify({
      credentialID,
      providerAccountId: authenticator.providerAccountId,
      userID: account.userId
    })}`);
  }
  return {
    account,
    user: user2
  };
}
__name(verifyAuthenticate, "verifyAuthenticate");
async function verifyRegister(options, request3, resCookies) {
  const { provider } = options;
  const data = request3.body && typeof request3.body.data === "string" ? JSON.parse(request3.body.data) : void 0;
  if (!data || typeof data !== "object" || !("id" in data) || typeof data.id !== "string") {
    throw new AuthError("Invalid WebAuthn Registration response");
  }
  const { challenge: expectedChallenge, registerData: user2 } = await webauthnChallenge.use(options, request3.cookies, resCookies);
  if (!user2) {
    throw new AuthError("Missing user registration data in WebAuthn challenge cookie");
  }
  let verification;
  try {
    const relayingParty = provider.getRelayingParty(options, request3);
    verification = await provider.simpleWebAuthn.verifyRegistrationResponse({
      ...provider.verifyRegistrationOptions,
      expectedChallenge,
      response: data,
      expectedOrigin: relayingParty.origin,
      expectedRPID: relayingParty.id
    });
  } catch (e2) {
    throw new WebAuthnVerificationError(e2);
  }
  if (!verification.verified || !verification.registrationInfo) {
    throw new WebAuthnVerificationError("WebAuthn registration response could not be verified");
  }
  const account = {
    providerAccountId: toBase64(verification.registrationInfo.credentialID),
    provider: options.provider.id,
    type: provider.type
  };
  const authenticator = {
    providerAccountId: account.providerAccountId,
    counter: verification.registrationInfo.counter,
    credentialID: toBase64(verification.registrationInfo.credentialID),
    credentialPublicKey: toBase64(verification.registrationInfo.credentialPublicKey),
    credentialBackedUp: verification.registrationInfo.credentialBackedUp,
    credentialDeviceType: verification.registrationInfo.credentialDeviceType,
    transports: transportsToString(data.response.transports)
  };
  return {
    user: user2,
    account,
    authenticator
  };
}
__name(verifyRegister, "verifyRegister");
async function getAuthenticationOptions(options, request3, user2) {
  const { provider, adapter } = options;
  const authenticators = user2 && user2["id"] ? await adapter.listAuthenticatorsByUserId(user2.id) : null;
  const relayingParty = provider.getRelayingParty(options, request3);
  return await provider.simpleWebAuthn.generateAuthenticationOptions({
    ...provider.authenticationOptions,
    rpID: relayingParty.id,
    allowCredentials: authenticators?.map((a4) => ({
      id: fromBase64(a4.credentialID),
      type: "public-key",
      transports: stringToTransports(a4.transports)
    }))
  });
}
__name(getAuthenticationOptions, "getAuthenticationOptions");
async function getRegistrationOptions(options, request3, user2) {
  const { provider, adapter } = options;
  const authenticators = user2["id"] ? await adapter.listAuthenticatorsByUserId(user2.id) : null;
  const userID = randomString(32);
  const relayingParty = provider.getRelayingParty(options, request3);
  return await provider.simpleWebAuthn.generateRegistrationOptions({
    ...provider.registrationOptions,
    userID,
    userName: user2.email,
    userDisplayName: user2.name ?? void 0,
    rpID: relayingParty.id,
    rpName: relayingParty.name,
    excludeCredentials: authenticators?.map((a4) => ({
      id: fromBase64(a4.credentialID),
      type: "public-key",
      transports: stringToTransports(a4.transports)
    }))
  });
}
__name(getRegistrationOptions, "getRegistrationOptions");
function assertInternalOptionsWebAuthn(options) {
  const { provider, adapter } = options;
  if (!adapter)
    throw new MissingAdapter("An adapter is required for the WebAuthn provider");
  if (!provider || provider.type !== "webauthn") {
    throw new InvalidProvider("Provider must be WebAuthn");
  }
  return { ...options, provider, adapter };
}
__name(assertInternalOptionsWebAuthn, "assertInternalOptionsWebAuthn");
function fromAdapterAuthenticator(authenticator) {
  return {
    ...authenticator,
    credentialDeviceType: authenticator.credentialDeviceType,
    transports: stringToTransports(authenticator.transports),
    credentialID: fromBase64(authenticator.credentialID),
    credentialPublicKey: fromBase64(authenticator.credentialPublicKey)
  };
}
__name(fromAdapterAuthenticator, "fromAdapterAuthenticator");
function fromBase64(base64) {
  return new Uint8Array(Buffer.from(base64, "base64"));
}
__name(fromBase64, "fromBase64");
function toBase64(bytes) {
  return Buffer.from(bytes).toString("base64");
}
__name(toBase64, "toBase64");
function transportsToString(transports) {
  return transports?.join(",");
}
__name(transportsToString, "transportsToString");
function stringToTransports(tstring) {
  return tstring ? tstring.split(",") : void 0;
}
__name(stringToTransports, "stringToTransports");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/callback/index.js
async function callback(request3, options, sessionStore, cookies) {
  if (!options.provider)
    throw new InvalidProvider("Callback route called without provider");
  const { query, body, method, headers } = request3;
  const { provider, adapter, url, callbackUrl, pages, jwt: jwt2, events, callbacks, session: { strategy: sessionStrategy, maxAge: sessionMaxAge }, logger: logger2 } = options;
  const useJwtSession = sessionStrategy === "jwt";
  try {
    if (provider.type === "oauth" || provider.type === "oidc") {
      const params = provider.authorization?.url.searchParams.get("response_mode") === "form_post" ? body : query;
      if (options.isOnRedirectProxy && params?.state) {
        const parsedState = await state.decode(params.state, options);
        const shouldRedirect = parsedState?.origin && new URL(parsedState.origin).origin !== options.url.origin;
        if (shouldRedirect) {
          const proxyRedirect = `${parsedState.origin}?${new URLSearchParams(params)}`;
          logger2.debug("Proxy redirecting to", proxyRedirect);
          return { redirect: proxyRedirect, cookies };
        }
      }
      const authorizationResult = await handleOAuth(params, request3.cookies, options);
      if (authorizationResult.cookies.length) {
        cookies.push(...authorizationResult.cookies);
      }
      logger2.debug("authorization result", authorizationResult);
      const { user: userFromProvider, account, profile: OAuthProfile } = authorizationResult;
      if (!userFromProvider || !account || !OAuthProfile) {
        return { redirect: `${url}/signin`, cookies };
      }
      let userByAccount;
      if (adapter) {
        const { getUserByAccount } = adapter;
        userByAccount = await getUserByAccount({
          providerAccountId: account.providerAccountId,
          provider: provider.id
        });
      }
      const redirect = await handleAuthorized({
        user: userByAccount ?? userFromProvider,
        account,
        profile: OAuthProfile
      }, options);
      if (redirect)
        return { redirect, cookies };
      const { user: user2, session: session2, isNewUser } = await handleLoginOrRegister(sessionStore.value, userFromProvider, account, options);
      if (useJwtSession) {
        const defaultToken = {
          name: user2.name,
          email: user2.email,
          picture: user2.image,
          sub: user2.id?.toString()
        };
        const token = await callbacks.jwt({
          token: defaultToken,
          user: user2,
          account,
          profile: OAuthProfile,
          isNewUser,
          trigger: isNewUser ? "signUp" : "signIn"
        });
        if (token === null) {
          cookies.push(...sessionStore.clean());
        } else {
          const salt = options.cookies.sessionToken.name;
          const newToken = await jwt2.encode({ ...jwt2, token, salt });
          const cookieExpires = /* @__PURE__ */ new Date();
          cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1e3);
          const sessionCookies = sessionStore.chunk(newToken, {
            expires: cookieExpires
          });
          cookies.push(...sessionCookies);
        }
      } else {
        cookies.push({
          name: options.cookies.sessionToken.name,
          value: session2.sessionToken,
          options: {
            ...options.cookies.sessionToken.options,
            expires: session2.expires
          }
        });
      }
      await events.signIn?.({
        user: user2,
        account,
        profile: OAuthProfile,
        isNewUser
      });
      if (isNewUser && pages.newUser) {
        return {
          redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}${new URLSearchParams({ callbackUrl })}`,
          cookies
        };
      }
      return { redirect: callbackUrl, cookies };
    } else if (provider.type === "email") {
      const paramToken = query?.token;
      const paramIdentifier = query?.email;
      if (!paramToken) {
        const e2 = new TypeError("Missing token. The sign-in URL was manually opened without token or the link was not sent correctly in the email.", { cause: { hasToken: !!paramToken } });
        e2.name = "Configuration";
        throw e2;
      }
      const secret = provider.secret ?? options.secret;
      const invite = await adapter.useVerificationToken({
        // @ts-expect-error User-land adapters might decide to omit the identifier during lookup
        identifier: paramIdentifier,
        // TODO: Drop this requirement for lookup in official adapters too
        token: await createHash3(`${paramToken}${secret}`)
      });
      const hasInvite = !!invite;
      const expired = hasInvite && invite.expires.valueOf() < Date.now();
      const invalidInvite = !hasInvite || expired || // The user might have configured the link to not contain the identifier
      // so we only compare if it exists
      paramIdentifier && invite.identifier !== paramIdentifier;
      if (invalidInvite)
        throw new Verification({ hasInvite, expired });
      const { identifier } = invite;
      const user2 = await adapter.getUserByEmail(identifier) ?? {
        id: crypto.randomUUID(),
        email: identifier,
        emailVerified: null
      };
      const account = {
        providerAccountId: user2.email,
        userId: user2.id,
        type: "email",
        provider: provider.id
      };
      const redirect = await handleAuthorized({ user: user2, account }, options);
      if (redirect)
        return { redirect, cookies };
      const { user: loggedInUser, session: session2, isNewUser } = await handleLoginOrRegister(sessionStore.value, user2, account, options);
      if (useJwtSession) {
        const defaultToken = {
          name: loggedInUser.name,
          email: loggedInUser.email,
          picture: loggedInUser.image,
          sub: loggedInUser.id?.toString()
        };
        const token = await callbacks.jwt({
          token: defaultToken,
          user: loggedInUser,
          account,
          isNewUser,
          trigger: isNewUser ? "signUp" : "signIn"
        });
        if (token === null) {
          cookies.push(...sessionStore.clean());
        } else {
          const salt = options.cookies.sessionToken.name;
          const newToken = await jwt2.encode({ ...jwt2, token, salt });
          const cookieExpires = /* @__PURE__ */ new Date();
          cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1e3);
          const sessionCookies = sessionStore.chunk(newToken, {
            expires: cookieExpires
          });
          cookies.push(...sessionCookies);
        }
      } else {
        cookies.push({
          name: options.cookies.sessionToken.name,
          value: session2.sessionToken,
          options: {
            ...options.cookies.sessionToken.options,
            expires: session2.expires
          }
        });
      }
      await events.signIn?.({ user: loggedInUser, account, isNewUser });
      if (isNewUser && pages.newUser) {
        return {
          redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}${new URLSearchParams({ callbackUrl })}`,
          cookies
        };
      }
      return { redirect: callbackUrl, cookies };
    } else if (provider.type === "credentials" && method === "POST") {
      const credentials = body ?? {};
      Object.entries(query ?? {}).forEach(([k3, v4]) => url.searchParams.set(k3, v4));
      const userFromAuthorize = await provider.authorize(
        credentials,
        // prettier-ignore
        new Request(url, { headers, method, body: JSON.stringify(body) })
      );
      const user2 = userFromAuthorize;
      if (!user2)
        throw new CredentialsSignin();
      else
        user2.id = user2.id?.toString() ?? crypto.randomUUID();
      const account = {
        providerAccountId: user2.id,
        type: "credentials",
        provider: provider.id
      };
      const redirect = await handleAuthorized({ user: user2, account, credentials }, options);
      if (redirect)
        return { redirect, cookies };
      const defaultToken = {
        name: user2.name,
        email: user2.email,
        picture: user2.image,
        sub: user2.id
      };
      const token = await callbacks.jwt({
        token: defaultToken,
        user: user2,
        account,
        isNewUser: false,
        trigger: "signIn"
      });
      if (token === null) {
        cookies.push(...sessionStore.clean());
      } else {
        const salt = options.cookies.sessionToken.name;
        const newToken = await jwt2.encode({ ...jwt2, token, salt });
        const cookieExpires = /* @__PURE__ */ new Date();
        cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1e3);
        const sessionCookies = sessionStore.chunk(newToken, {
          expires: cookieExpires
        });
        cookies.push(...sessionCookies);
      }
      await events.signIn?.({ user: user2, account });
      return { redirect: callbackUrl, cookies };
    } else if (provider.type === "webauthn" && method === "POST") {
      const action = request3.body?.action;
      if (typeof action !== "string" || action !== "authenticate" && action !== "register") {
        throw new AuthError("Invalid action parameter");
      }
      const localOptions = assertInternalOptionsWebAuthn(options);
      let user2;
      let account;
      let authenticator;
      switch (action) {
        case "authenticate": {
          const verified = await verifyAuthenticate(localOptions, request3, cookies);
          user2 = verified.user;
          account = verified.account;
          break;
        }
        case "register": {
          const verified = await verifyRegister(options, request3, cookies);
          user2 = verified.user;
          account = verified.account;
          authenticator = verified.authenticator;
          break;
        }
      }
      await handleAuthorized({ user: user2, account }, options);
      const { user: loggedInUser, isNewUser, session: session2, account: currentAccount } = await handleLoginOrRegister(sessionStore.value, user2, account, options);
      if (!currentAccount) {
        throw new AuthError("Error creating or finding account");
      }
      if (authenticator && loggedInUser.id) {
        await localOptions.adapter.createAuthenticator({
          ...authenticator,
          userId: loggedInUser.id
        });
      }
      if (useJwtSession) {
        const defaultToken = {
          name: loggedInUser.name,
          email: loggedInUser.email,
          picture: loggedInUser.image,
          sub: loggedInUser.id?.toString()
        };
        const token = await callbacks.jwt({
          token: defaultToken,
          user: loggedInUser,
          account: currentAccount,
          isNewUser,
          trigger: isNewUser ? "signUp" : "signIn"
        });
        if (token === null) {
          cookies.push(...sessionStore.clean());
        } else {
          const salt = options.cookies.sessionToken.name;
          const newToken = await jwt2.encode({ ...jwt2, token, salt });
          const cookieExpires = /* @__PURE__ */ new Date();
          cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1e3);
          const sessionCookies = sessionStore.chunk(newToken, {
            expires: cookieExpires
          });
          cookies.push(...sessionCookies);
        }
      } else {
        cookies.push({
          name: options.cookies.sessionToken.name,
          value: session2.sessionToken,
          options: {
            ...options.cookies.sessionToken.options,
            expires: session2.expires
          }
        });
      }
      await events.signIn?.({
        user: loggedInUser,
        account: currentAccount,
        isNewUser
      });
      if (isNewUser && pages.newUser) {
        return {
          redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}${new URLSearchParams({ callbackUrl })}`,
          cookies
        };
      }
      return { redirect: callbackUrl, cookies };
    }
    throw new InvalidProvider(`Callback for provider type (${provider.type}) is not supported`);
  } catch (e2) {
    if (e2 instanceof AuthError)
      throw e2;
    const error4 = new CallbackRouteError(e2, { provider: provider.id });
    logger2.debug("callback route error details", { method, query, body });
    throw error4;
  }
}
__name(callback, "callback");
async function handleAuthorized(params, config2) {
  let authorized;
  const { signIn: signIn2, redirect } = config2.callbacks;
  try {
    authorized = await signIn2(params);
  } catch (e2) {
    if (e2 instanceof AuthError)
      throw e2;
    throw new AccessDenied(e2);
  }
  if (!authorized)
    throw new AccessDenied("AccessDenied");
  if (typeof authorized !== "string")
    return;
  return await redirect({ url: authorized, baseUrl: config2.url.origin });
}
__name(handleAuthorized, "handleAuthorized");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/session.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function session(options, sessionStore, cookies, isUpdate, newSession) {
  const { adapter, jwt: jwt2, events, callbacks, logger: logger2, session: { strategy: sessionStrategy, maxAge: sessionMaxAge } } = options;
  const response = {
    body: null,
    headers: { "Content-Type": "application/json" },
    cookies
  };
  const sessionToken = sessionStore.value;
  if (!sessionToken)
    return response;
  if (sessionStrategy === "jwt") {
    try {
      const salt = options.cookies.sessionToken.name;
      const payload = await jwt2.decode({ ...jwt2, token: sessionToken, salt });
      if (!payload)
        throw new Error("Invalid JWT");
      const token = await callbacks.jwt({
        token: payload,
        ...isUpdate && { trigger: "update" },
        session: newSession
      });
      const newExpires = fromDate(sessionMaxAge);
      if (token !== null) {
        const session2 = {
          user: { name: token.name, email: token.email, image: token.picture },
          expires: newExpires.toISOString()
        };
        const newSession2 = await callbacks.session({ session: session2, token });
        response.body = newSession2;
        const newToken = await jwt2.encode({ ...jwt2, token, salt });
        const sessionCookies = sessionStore.chunk(newToken, {
          expires: newExpires
        });
        response.cookies?.push(...sessionCookies);
        await events.session?.({ session: newSession2, token });
      } else {
        response.cookies?.push(...sessionStore.clean());
      }
    } catch (e2) {
      logger2.error(new JWTSessionError(e2));
      response.cookies?.push(...sessionStore.clean());
    }
    return response;
  }
  try {
    const { getSessionAndUser, deleteSession, updateSession } = adapter;
    let userAndSession = await getSessionAndUser(sessionToken);
    if (userAndSession && userAndSession.session.expires.valueOf() < Date.now()) {
      await deleteSession(sessionToken);
      userAndSession = null;
    }
    if (userAndSession) {
      const { user: user2, session: session2 } = userAndSession;
      const sessionUpdateAge = options.session.updateAge;
      const sessionIsDueToBeUpdatedDate = session2.expires.valueOf() - sessionMaxAge * 1e3 + sessionUpdateAge * 1e3;
      const newExpires = fromDate(sessionMaxAge);
      if (sessionIsDueToBeUpdatedDate <= Date.now()) {
        await updateSession({
          sessionToken,
          expires: newExpires
        });
      }
      const sessionPayload = await callbacks.session({
        // TODO: user already passed below,
        // remove from session object in https://github.com/nextauthjs/next-auth/pull/9702
        // @ts-expect-error
        session: { ...session2, user: user2 },
        user: user2,
        newSession,
        ...isUpdate ? { trigger: "update" } : {}
      });
      response.body = sessionPayload;
      response.cookies?.push({
        name: options.cookies.sessionToken.name,
        value: sessionToken,
        options: {
          ...options.cookies.sessionToken.options,
          expires: newExpires
        }
      });
      await events.session?.({ session: sessionPayload });
    } else if (sessionToken) {
      response.cookies?.push(...sessionStore.clean());
    }
  } catch (e2) {
    logger2.error(new SessionTokenError(e2));
  }
  return response;
}
__name(session, "session");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/signin/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/signin/authorization-url.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function getAuthorizationUrl(query, options) {
  const { logger: logger2, provider } = options;
  let url = provider.authorization?.url;
  let as;
  if (!url || url.host === "authjs.dev") {
    const issuer = new URL(provider.issuer);
    const discoveryResponse = await discoveryRequest(issuer);
    const as2 = await processDiscoveryResponse(issuer, discoveryResponse);
    if (!as2.authorization_endpoint) {
      throw new TypeError("Authorization server did not provide an authorization endpoint.");
    }
    url = new URL(as2.authorization_endpoint);
  }
  const authParams = url.searchParams;
  let redirect_uri = provider.callbackUrl;
  let data;
  if (!options.isOnRedirectProxy && provider.redirectProxyUrl) {
    redirect_uri = provider.redirectProxyUrl;
    data = provider.callbackUrl;
    logger2.debug("using redirect proxy", { redirect_uri, data });
  }
  const params = Object.assign({
    response_type: "code",
    // clientId can technically be undefined, should we check this in assert.ts or rely on the Authorization Server to do it?
    client_id: provider.clientId,
    redirect_uri,
    // @ts-expect-error TODO:
    ...provider.authorization?.params
  }, Object.fromEntries(provider.authorization?.url.searchParams ?? []), query);
  for (const k3 in params)
    authParams.set(k3, params[k3]);
  const cookies = [];
  const state2 = await state.create(options, data);
  if (state2) {
    authParams.set("state", state2.value);
    cookies.push(state2.cookie);
  }
  if (provider.checks?.includes("pkce")) {
    if (as && !as.code_challenge_methods_supported?.includes("S256")) {
      if (provider.type === "oidc")
        provider.checks = ["nonce"];
    } else {
      const { value, cookie } = await pkce.create(options);
      authParams.set("code_challenge", value);
      authParams.set("code_challenge_method", "S256");
      cookies.push(cookie);
    }
  }
  const nonce2 = await nonce.create(options);
  if (nonce2) {
    authParams.set("nonce", nonce2.value);
    cookies.push(nonce2.cookie);
  }
  if (provider.type === "oidc" && !url.searchParams.has("scope")) {
    url.searchParams.set("scope", "openid profile email");
  }
  logger2.debug("authorization url is ready", { url, cookies, provider });
  return { redirect: url.toString(), cookies };
}
__name(getAuthorizationUrl, "getAuthorizationUrl");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/signin/send-token.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function sendToken(request3, options) {
  const { body } = request3;
  const { provider, callbacks, adapter } = options;
  const normalizer = provider.normalizeIdentifier ?? defaultNormalizer;
  const email = normalizer(body?.email);
  const defaultUser = { id: crypto.randomUUID(), email, emailVerified: null };
  const user2 = await adapter.getUserByEmail(email) ?? defaultUser;
  const account = {
    providerAccountId: email,
    userId: user2.id,
    type: "email",
    provider: provider.id
  };
  let authorized;
  try {
    authorized = await callbacks.signIn({
      user: user2,
      account,
      email: { verificationRequest: true }
    });
  } catch (e2) {
    throw new AccessDenied(e2);
  }
  if (!authorized)
    throw new AccessDenied("AccessDenied");
  if (typeof authorized === "string") {
    return {
      redirect: await callbacks.redirect({
        url: authorized,
        baseUrl: options.url.origin
      })
    };
  }
  const { callbackUrl, theme } = options;
  const token = await provider.generateVerificationToken?.() ?? randomString(32);
  const ONE_DAY_IN_SECONDS = 86400;
  const expires = new Date(Date.now() + (provider.maxAge ?? ONE_DAY_IN_SECONDS) * 1e3);
  const secret = provider.secret ?? options.secret;
  const baseUrl = new URL(options.basePath, options.url.origin);
  const sendRequest = provider.sendVerificationRequest({
    identifier: email,
    token,
    expires,
    url: `${baseUrl}/callback/${provider.id}?${new URLSearchParams({
      callbackUrl,
      token,
      email
    })}`,
    provider,
    theme,
    request: toRequest(request3)
  });
  const createToken = adapter.createVerificationToken?.({
    identifier: email,
    token: await createHash3(`${token}${secret}`),
    expires
  });
  await Promise.all([sendRequest, createToken]);
  return {
    redirect: `${baseUrl}/verify-request?${new URLSearchParams({
      provider: provider.id,
      type: provider.type
    })}`
  };
}
__name(sendToken, "sendToken");
function defaultNormalizer(email) {
  if (!email)
    throw new Error("Missing email from request body.");
  let [local, domain2] = email.toLowerCase().trim().split("@");
  domain2 = domain2.split(",")[0];
  return `${local}@${domain2}`;
}
__name(defaultNormalizer, "defaultNormalizer");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/signin/index.js
async function signIn(request3, cookies, options) {
  const signInUrl = `${options.url.origin}${options.basePath}/signin`;
  if (!options.provider)
    return { redirect: signInUrl, cookies };
  switch (options.provider.type) {
    case "oauth":
    case "oidc": {
      const { redirect, cookies: authCookies } = await getAuthorizationUrl(request3.query, options);
      if (authCookies)
        cookies.push(...authCookies);
      return { redirect, cookies };
    }
    case "email": {
      const response = await sendToken(request3, options);
      return { ...response, cookies };
    }
    default:
      return { redirect: signInUrl, cookies };
  }
}
__name(signIn, "signIn");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/signout.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function signOut(cookies, sessionStore, options) {
  const { jwt: jwt2, events, callbackUrl: redirect, logger: logger2, session: session2 } = options;
  const sessionToken = sessionStore.value;
  if (!sessionToken)
    return { redirect, cookies };
  try {
    if (session2.strategy === "jwt") {
      const salt = options.cookies.sessionToken.name;
      const token = await jwt2.decode({ ...jwt2, token: sessionToken, salt });
      await events.signOut?.({ token });
    } else {
      const session3 = await options.adapter?.deleteSession(sessionToken);
      await events.signOut?.({ session: session3 });
    }
  } catch (e2) {
    logger2.error(new SignOutError(e2));
  }
  cookies.push(...sessionStore.clean());
  return { redirect, cookies };
}
__name(signOut, "signOut");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/webauthn-options.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/session.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function getLoggedInUser(options, sessionStore) {
  const { adapter, jwt: jwt2, session: { strategy: sessionStrategy } } = options;
  const sessionToken = sessionStore.value;
  if (!sessionToken)
    return null;
  if (sessionStrategy === "jwt") {
    const salt = options.cookies.sessionToken.name;
    const payload = await jwt2.decode({ ...jwt2, token: sessionToken, salt });
    if (payload && payload.sub) {
      return {
        id: payload.sub,
        name: payload.name,
        email: payload.email,
        image: payload.picture
      };
    }
  } else {
    const userAndSession = await adapter?.getSessionAndUser(sessionToken);
    if (userAndSession) {
      return userAndSession.user;
    }
  }
  return null;
}
__name(getLoggedInUser, "getLoggedInUser");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/actions/webauthn-options.js
async function webAuthnOptions(request3, options, sessionStore, cookies) {
  const narrowOptions = assertInternalOptionsWebAuthn(options);
  const { provider } = narrowOptions;
  const { action } = request3.query ?? {};
  if (action !== "register" && action !== "authenticate" && typeof action !== "undefined") {
    return {
      status: 400,
      body: { error: "Invalid action" },
      cookies,
      headers: {
        "Content-Type": "application/json"
      }
    };
  }
  const sessionUser = await getLoggedInUser(options, sessionStore);
  const getUserInfoResponse = sessionUser ? {
    user: sessionUser,
    exists: true
  } : await provider.getUserInfo(options, request3);
  const userInfo2 = getUserInfoResponse?.user;
  const decision = inferWebAuthnOptions(action, !!sessionUser, getUserInfoResponse);
  switch (decision) {
    case "authenticate":
      return getAuthenticationResponse(narrowOptions, request3, userInfo2, cookies);
    case "register":
      if (typeof userInfo2?.email === "string") {
        return getRegistrationResponse(narrowOptions, request3, userInfo2, cookies);
      }
      break;
    default:
      return {
        status: 400,
        body: { error: "Invalid request" },
        cookies,
        headers: {
          "Content-Type": "application/json"
        }
      };
  }
}
__name(webAuthnOptions, "webAuthnOptions");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/index.js
async function AuthInternal(request3, authOptions) {
  const { action, providerId, error: error4, method } = request3;
  const csrfDisabled = authOptions.skipCSRFCheck === skipCSRFCheck;
  const { options, cookies } = await init2({
    authOptions,
    action,
    providerId,
    url: request3.url,
    callbackUrl: request3.body?.callbackUrl ?? request3.query?.callbackUrl,
    csrfToken: request3.body?.csrfToken,
    cookies: request3.cookies,
    isPost: method === "POST",
    csrfDisabled
  });
  const sessionStore = new SessionStore(options.cookies.sessionToken, request3.cookies, options.logger);
  if (method === "GET") {
    const render = renderPage({ ...options, query: request3.query, cookies });
    switch (action) {
      case "callback":
        return await callback(request3, options, sessionStore, cookies);
      case "csrf":
        return render.csrf(csrfDisabled, options, cookies);
      case "error":
        return render.error(error4);
      case "providers":
        return render.providers(options.providers);
      case "session":
        return await session(options, sessionStore, cookies);
      case "signin":
        return render.signin(providerId, error4);
      case "signout":
        return render.signout();
      case "verify-request":
        return render.verifyRequest();
      case "webauthn-options":
        return await webAuthnOptions(request3, options, sessionStore, cookies);
      default:
    }
  } else {
    const { csrfTokenVerified } = options;
    switch (action) {
      case "callback":
        if (options.provider.type === "credentials")
          validateCSRF(action, csrfTokenVerified);
        return await callback(request3, options, sessionStore, cookies);
      case "session":
        validateCSRF(action, csrfTokenVerified);
        return await session(options, sessionStore, cookies, true, request3.body?.data);
      case "signin":
        validateCSRF(action, csrfTokenVerified);
        return await signIn(request3, cookies, options);
      case "signout":
        validateCSRF(action, csrfTokenVerified);
        return await signOut(cookies, sessionStore, options);
      default:
    }
  }
  throw new UnknownAction(`Cannot handle action: ${action}`);
}
__name(AuthInternal, "AuthInternal");
var skipCSRFCheck = Symbol("skip-csrf-check");
var raw2 = Symbol("return-type-raw");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/lib/utils/env.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
function setEnvDefaults(envObject, config2, suppressBasePathWarning = false) {
  try {
    const url = envObject.AUTH_URL;
    if (url) {
      if (config2.basePath) {
        if (!suppressBasePathWarning) {
          const logger2 = setLogger(config2);
          logger2.warn("env-url-basepath-redundant");
        }
      } else {
        config2.basePath = new URL(url).pathname;
      }
    }
  } catch {
  } finally {
    config2.basePath ?? (config2.basePath = `/auth`);
  }
  if (!config2.secret?.length) {
    config2.secret = [];
    const secret = envObject.AUTH_SECRET;
    if (secret)
      config2.secret.push(secret);
    for (const i3 of [1, 2, 3]) {
      const secret2 = envObject[`AUTH_SECRET_${i3}`];
      if (secret2)
        config2.secret.unshift(secret2);
    }
  }
  config2.redirectProxyUrl ?? (config2.redirectProxyUrl = envObject.AUTH_REDIRECT_PROXY_URL);
  config2.trustHost ?? (config2.trustHost = !!(envObject.AUTH_URL ?? envObject.AUTH_TRUST_HOST ?? envObject.VERCEL ?? envObject.CF_PAGES ?? envObject.NODE_ENV !== "production"));
  config2.providers = config2.providers.map((provider) => {
    const { id } = typeof provider === "function" ? provider({}) : provider;
    const ID = id.toUpperCase().replace(/-/g, "_");
    const clientId = envObject[`AUTH_${ID}_ID`];
    const clientSecret = envObject[`AUTH_${ID}_SECRET`];
    const issuer = envObject[`AUTH_${ID}_ISSUER`];
    const apiKey = envObject[`AUTH_${ID}_KEY`];
    const finalProvider = typeof provider === "function" ? provider({ clientId, clientSecret, issuer, apiKey }) : provider;
    if (finalProvider.type === "oauth" || finalProvider.type === "oidc") {
      finalProvider.clientId ?? (finalProvider.clientId = clientId);
      finalProvider.clientSecret ?? (finalProvider.clientSecret = clientSecret);
      finalProvider.issuer ?? (finalProvider.issuer = issuer);
    } else if (finalProvider.type === "email") {
      finalProvider.apiKey ?? (finalProvider.apiKey = apiKey);
    }
    return finalProvider;
  });
}
__name(setEnvDefaults, "setEnvDefaults");

// node_modules/.pnpm/@auth+core@0.35.3/node_modules/@auth/core/index.js
async function Auth(request3, config2) {
  const logger2 = setLogger(config2);
  const internalRequest = await toInternalRequest(request3, config2);
  if (!internalRequest)
    return Response.json(`Bad request.`, { status: 400 });
  const warningsOrError = assertConfig(internalRequest, config2);
  if (Array.isArray(warningsOrError)) {
    warningsOrError.forEach(logger2.warn);
  } else if (warningsOrError) {
    logger2.error(warningsOrError);
    const htmlPages = /* @__PURE__ */ new Set([
      "signin",
      "signout",
      "error",
      "verify-request"
    ]);
    if (!htmlPages.has(internalRequest.action) || internalRequest.method !== "GET") {
      const message2 = "There was a problem with the server configuration. Check the server logs for more information.";
      return Response.json({ message: message2 }, { status: 500 });
    }
    const { pages, theme } = config2;
    const authOnErrorPage = pages?.error && internalRequest.url.searchParams.get("callbackUrl")?.startsWith(pages.error);
    if (!pages?.error || authOnErrorPage) {
      if (authOnErrorPage) {
        logger2.error(new ErrorPageLoop(`The error page ${pages?.error} should not require authentication`));
      }
      const page = renderPage({ theme }).error("Configuration");
      return toResponse(page);
    }
    const url = `${internalRequest.url.origin}${pages.error}?error=Configuration`;
    return Response.redirect(url);
  }
  const isRedirect = request3.headers?.has("X-Auth-Return-Redirect");
  const isRaw = config2.raw === raw2;
  try {
    const internalResponse = await AuthInternal(internalRequest, config2);
    if (isRaw)
      return internalResponse;
    const response = toResponse(internalResponse);
    const url = response.headers.get("Location");
    if (!isRedirect || !url)
      return response;
    return Response.json({ url }, { headers: response.headers });
  } catch (e2) {
    const error4 = e2;
    logger2.error(error4);
    const isAuthError = error4 instanceof AuthError;
    if (isAuthError && isRaw && !isRedirect)
      throw error4;
    if (request3.method === "POST" && internalRequest.action === "session")
      return Response.json(null, { status: 400 });
    const isClientSafeErrorType = isClientError(error4);
    const type2 = isClientSafeErrorType ? error4.type : "Configuration";
    const params = new URLSearchParams({ error: type2 });
    if (error4 instanceof CredentialsSignin)
      params.set("code", error4.code);
    const pageKind = isAuthError && error4.kind || "error";
    const pagePath = config2.pages?.[pageKind] ?? `${config2.basePath}/${pageKind.toLowerCase()}`;
    const url = `${internalRequest.url.origin}${pagePath}?${params}`;
    if (isRedirect)
      return Response.json({ url });
    return Response.redirect(url);
  }
}
__name(Auth, "Auth");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/helper/adapter/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var env3 = /* @__PURE__ */ __name((c4, runtime) => {
  const global2 = globalThis;
  const globalEnv = global2?.process?.env;
  runtime ??= getRuntimeKey();
  const runtimeEnvHandlers = {
    bun: () => globalEnv,
    node: () => globalEnv,
    "edge-light": () => globalEnv,
    deno: () => {
      return Deno.env.toObject();
    },
    workerd: () => c4.env,
    fastly: () => ({}),
    other: () => ({})
  };
  return runtimeEnvHandlers[runtime]();
}, "env");
var knownUserAgents = {
  deno: "Deno",
  bun: "Bun",
  workerd: "Cloudflare-Workers",
  node: "Node.js"
};
var getRuntimeKey = /* @__PURE__ */ __name(() => {
  const global2 = globalThis;
  const userAgentSupported = typeof navigator !== "undefined" && true;
  if (userAgentSupported) {
    for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey;
      }
    }
  }
  if (typeof global2?.EdgeRuntime === "string") {
    return "edge-light";
  }
  if (global2?.fastly !== void 0) {
    return "fastly";
  }
  if (global2?.process?.release?.name === "node") {
    return "node";
  }
  return "other";
}, "getRuntimeKey");
var checkUserAgentEquals = /* @__PURE__ */ __name((platform3) => {
  const userAgent = "Cloudflare-Workers";
  return userAgent.startsWith(platform3);
}, "checkUserAgentEquals");

// node_modules/.pnpm/@hono+auth-js@1.0.11_@auth+core@0.35.3_hono@4.6.3_react@18.3.1/node_modules/@hono/auth-js/dist/index.mjs
function setEnvDefaults2(env22, config2) {
  config2.secret ??= env22.AUTH_SECRET;
  setEnvDefaults(env22, config2);
}
__name(setEnvDefaults2, "setEnvDefaults");
async function cloneRequest(input, request3, headers) {
  if (getRuntimeKey() === "bun") {
    return new Request(input, {
      method: request3.method,
      headers: headers ?? new Headers(request3.headers),
      body: request3.method === "GET" || request3.method === "HEAD" ? void 0 : await request3.blob(),
      // @ts-ignore: TS2353
      referrer: "referrer" in request3 ? request3.referrer : void 0,
      // deno-lint-ignore no-explicit-any
      referrerPolicy: request3.referrerPolicy,
      mode: request3.mode,
      credentials: request3.credentials,
      // @ts-ignore: TS2353
      cache: request3.cache,
      redirect: request3.redirect,
      integrity: request3.integrity,
      keepalive: request3.keepalive,
      signal: request3.signal
    });
  }
  return new Request(input, request3);
}
__name(cloneRequest, "cloneRequest");
async function reqWithEnvUrl(req, authUrl) {
  if (authUrl) {
    const reqUrlObj = new URL(req.url);
    const authUrlObj = new URL(authUrl);
    const props = ["hostname", "protocol", "port", "password", "username"];
    props.forEach((prop) => reqUrlObj[prop] = authUrlObj[prop]);
    return cloneRequest(reqUrlObj.href, req);
  } else {
    const url = new URL(req.url);
    const headers = new Headers(req.headers);
    const proto = headers.get("x-forwarded-proto");
    const host = headers.get("x-forwarded-host") ?? headers.get("host");
    if (proto != null)
      url.protocol = proto.endsWith(":") ? proto : proto + ":";
    if (host != null) {
      url.host = host;
      const portMatch = host.match(/:(\d+)$/);
      if (portMatch)
        url.port = portMatch[1];
      else
        url.port = "";
      headers.delete("x-forwarded-host");
      headers.delete("Host");
      headers.set("Host", host);
    }
    return cloneRequest(url.href, req, headers);
  }
}
__name(reqWithEnvUrl, "reqWithEnvUrl");
async function getAuthUser(c4) {
  const config2 = c4.get("authConfig");
  const ctxEnv = env3(c4);
  setEnvDefaults2(ctxEnv, config2);
  const authReq = await reqWithEnvUrl(c4.req.raw, ctxEnv.AUTH_URL);
  const origin = new URL(authReq.url).origin;
  const request3 = new Request(`${origin}${config2.basePath}/session`, {
    headers: { cookie: c4.req.header("cookie") ?? "" }
  });
  let authUser = {};
  const response = await Auth(request3, {
    ...config2,
    callbacks: {
      ...config2.callbacks,
      async session(...args) {
        authUser = args[0];
        const session22 = await config2.callbacks?.session?.(...args) ?? args[0].session;
        const user2 = args[0].user ?? args[0].token;
        return { user: user2, ...session22 };
      }
    }
  });
  const session2 = await response.json();
  return session2 && session2.user ? authUser : null;
}
__name(getAuthUser, "getAuthUser");
function initAuthConfig(cb) {
  return async (c4, next) => {
    const config2 = cb(c4);
    c4.set("authConfig", config2);
    await next();
  };
}
__name(initAuthConfig, "initAuthConfig");

// src/lib/utils/middlewareUtils.ts
var verifyAuth = /* @__PURE__ */ __name(async (c4, next, unAuthorizedMessage) => {
  const authUser = await getAuthUser(c4);
  const isAuth = !!authUser?.token || !!authUser?.user;
  if (!isAuth) {
    return Response.json(
      { error: unAuthorizedMessage || "Un Authorized Access" },
      {
        status: 401
      }
    );
  } else {
    if (authUser.session && authUser.session.user) {
      authUser.session.user.id = authUser.token?.sub;
    }
    c4.set("authUser", authUser);
  }
  await next();
}, "verifyAuth");

// src/controllers/user/wishlists/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/zodSchema/wishListSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var wishlistInput = z.object({
  productId: z.string().min(1).max(255),
  userId: z.string().min(1).max(255)
});

// src/controllers/user/wishlists/index.ts
var createWishlist = /* @__PURE__ */ __name(async (data) => {
  const parseData = wishlistInput.safeParse(data);
  if (parseData.error) {
    return {
      error: "Invalid fields"
      // errors: parseData.error.errors,
    };
  }
  const d3 = parseData.data;
  const [isExist] = await db.select().from(UserWishList).where(
    and(
      eq(UserWishList.productId, d3.productId),
      eq(UserWishList.userId, d3.userId)
    )
  );
  if (isExist) {
    return isExist;
  }
  const [result] = await db.insert(UserWishList).values(d3).returning();
  return result;
}, "createWishlist");
var getWishlistByIdOrProductId = /* @__PURE__ */ __name(async (id, userId) => {
  const [result] = await db.select({
    productId: UserWishList.productId
  }).from(UserWishList).where(
    and(
      eq(UserWishList.userId, userId),
      or(eq(UserWishList.id, id), eq(UserWishList.productId, id))
    )
  ).limit(1).execute();
  return result;
}, "getWishlistByIdOrProductId");
var removeWishListByIdOrProductId = /* @__PURE__ */ __name(async (id, userId) => {
  const [result] = await db.delete(UserWishList).where(
    and(
      eq(UserWishList.userId, userId),
      or(eq(UserWishList.id, id), eq(UserWishList.productId, id))
    )
  ).returning();
  return result;
}, "removeWishListByIdOrProductId");

// src/routes/wishlist.ts
var wishlist = new Hono2().get("/:id", verifyAuth, async (c4) => {
  const params = c4.req.param("id") || "";
  const wishlist2 = await getWishlistByIdOrProductId(
    params,
    c4.get("authUser").token?.sub
  );
  if (wishlist2) {
    return c4.json(wishlist2);
  }
  return c4.json({ error: "Wishlist not found" });
}).post(
  "/",
  (c4, next) => verifyAuth(c4, next, "Please login first."),
  async (c4, nex) => {
    const auth = c4.get("authUser");
    const data = await c4.req.json();
    const res = await createWishlist({ ...data, userId: auth.token?.sub });
    if ("error" in res) {
      return c4.json(res, 400);
    }
    return c4.json(res);
  }
).delete("/:id", verifyAuth, async (c4) => {
  const params = c4.req.param("id") || "";
  const wishlist2 = await removeWishListByIdOrProductId(
    params,
    c4.get("authUser").token?.sub
  );
  if (wishlist2) {
    return c4.json(wishlist2);
  }
  return c4.json({ error: "Wishlist not found" });
});
var wishlist_default = wishlist;

// src/routes/user.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/controllers/user/upsertUser.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var upsertUser = /* @__PURE__ */ __name(async (user2) => {
  const formateUser = {
    email: user2.email,
    name: user2.name,
    image: user2.image
  };
  const [upsertUserDb] = await db.insert(users).values(formateUser).onConflictDoUpdate({
    target: users.email,
    set: formateUser
  }).returning();
  return upsertUserDb;
}, "upsertUser");

// src/controllers/user/userBasicInfo.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/queries/getUserCartCount.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
async function getUserCartCount(userId) {
  const result = await db.select({
    count: count3()
    // Using the `count` function to get the total
  }).from(UserCart).where(eq(UserCart.userId, userId));
  return result[0]?.count || 0;
}
__name(getUserCartCount, "getUserCartCount");

// src/controllers/user/userBasicInfo.ts
var userBasicInfo = /* @__PURE__ */ __name(async (userId) => {
  const cartCount = await getUserCartCount(userId);
  return {
    cartCount
  };
}, "userBasicInfo");

// src/routes/user.ts
var user = new Hono2().post(
  "/",
  //  zValidator("json", upsertUserSchema),
  async (c4) => {
    const data = await c4.req.json();
    const userInfo2 = await upsertUser(data);
    return c4.json(userInfo2);
  }
).get("/user-basic-info", verifyAuth, async (c4) => {
  const auth = c4.get("authUser");
  const userId = auth?.token?.sub;
  if (!userId) {
    return c4.json(null);
  }
  const userInfo2 = await userBasicInfo(userId);
  return c4.json(userInfo2);
});
var user_default = user;

// src/routes/cart.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/controllers/user/cart/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// src/zodSchema/cartSchema.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var cartInput = z.object({
  userId: z.string(),
  productId: z.string(),
  qty: z.number().min(1)
});

// src/controllers/user/cart/index.ts
var createCartItem = /* @__PURE__ */ __name(async (data) => {
  const parseData = cartInput.safeParse(data);
  if (parseData.error) {
    return {
      error: "Invalid fields"
    };
  }
  const d3 = parseData.data;
  const [productAndCartItem] = await db.select({
    productStock: products.stock,
    cartQty: UserCart.qty
  }).from(products).leftJoin(
    UserCart,
    and(eq(products.id, UserCart.productId), eq(UserCart.userId, d3.userId))
  ).where(eq(products.id, d3.productId)).limit(1);
  if (!productAndCartItem) {
    return {
      error: "Product not found"
    };
  }
  const { productStock, cartQty } = productAndCartItem;
  const totalQty = (cartQty || 0) + d3.qty;
  const select = {
    id: UserCart.id,
    productId: UserCart.productId,
    userId: UserCart.userId,
    qty: UserCart.qty,
    updatedAt: UserCart.updatedAt
  };
  if (cartQty) {
    const [updatedCartItem] = await db.update(UserCart).set({
      qty: totalQty > productStock ? +d3.qty : totalQty
    }).where(
      and(eq(UserCart.productId, d3.productId), eq(UserCart.userId, d3.userId))
    ).returning(select);
    return updatedCartItem;
  }
  const [newCartItem] = await db.insert(UserCart).values(d3).returning(select);
  return newCartItem;
}, "createCartItem");
var getCartByIdOrProductId = /* @__PURE__ */ __name(async (id, userId) => {
  const [result] = await db.select({
    productId: UserCart.productId,
    qty: UserCart.qty
  }).from(UserCart).where(
    and(
      eq(UserCart.userId, userId),
      or(eq(UserCart.id, id), eq(UserCart.productId, id))
    )
  ).limit(1).execute();
  return result;
}, "getCartByIdOrProductId");
var removeCartItemByIdOrProductId = /* @__PURE__ */ __name(async (id, userId) => {
  const [result] = await db.delete(UserCart).where(
    and(
      eq(UserCart.userId, userId),
      or(eq(UserCart.id, id), eq(UserCart.productId, id))
    )
  ).returning();
  return result;
}, "removeCartItemByIdOrProductId");
var updateCartItemQuantity = /* @__PURE__ */ __name(async (id, userId, qty) => {
  const [result] = await db.update(UserCart).set({ qty }).where(and(eq(UserCart.userId, userId), eq(UserCart.id, id))).returning();
  return result;
}, "updateCartItemQuantity");
var getAllCartProducts = /* @__PURE__ */ __name(async (userId, paginationParams) => {
  const {
    limit = 10,
    // Default limit if not provided
    offset = 0,
    priceFilter,
    sortBy = "createdAt",
    noLimit = false
    // Additional param for checking if limit should be ignored
  } = paginationParams;
  const whereClause = and(
    eq(UserCart.userId, userId),
    // Filter by userId in the cart
    priceFilter ? lte(products.price, priceFilter.toString()) : void 0
  );
  let query = db.select({
    cartId: UserCart.id,
    productId: UserCart.productId,
    qty: UserCart.qty,
    updatedAt: UserCart.updatedAt,
    name: products.name,
    description: products.description,
    category: products.categoryName,
    price: products.price,
    discountedPrice: products.discountedPrice,
    primaryImage: products.primaryImage,
    stock: products.stock,
    total: sql`COALESCE(${UserCart.qty} * ${products.discountedPrice}, ${UserCart.qty} * ${products.price})`.as(
      "total"
    ),
    subtotal: sql`SUM(COALESCE(${UserCart.qty} * ${products.discountedPrice}, ${UserCart.qty} * ${products.price})) OVER ()`.as(
      "subtotal"
    )
  }).from(UserCart).innerJoin(products, eq(UserCart.productId, products.id)).where(whereClause).offset(offset).orderBy(desc(UserCart[sortBy] || UserCart.updatedAt)).$dynamic();
  if (!noLimit) {
    query = query.limit(limit);
  }
  const cartProducts = await query;
  let totalCount = 0;
  if (noLimit) {
    const [totalCartProducts] = await db.select({ count: count3() }).from(UserCart).innerJoin(products, eq(UserCart.productId, products.id)).where(whereClause);
    totalCount = totalCartProducts.count;
  }
  const subtotal = cartProducts.length > 0 ? Number(cartProducts[0].subtotal) : 0;
  const formateCart = cartProducts.map((i3) => ({
    ...i3,
    qty: i3.qty >= i3.stock ? i3.stock : i3.qty,
    subtotal: void 0
  }));
  return {
    subtotal,
    total: subtotal,
    products: formateCart,
    pagination: noLimit ? void 0 : {
      total: totalCount,
      limit,
      offset
    }
  };
}, "getAllCartProducts");

// node_modules/.pnpm/@hono+zod-validator@0.2.2_hono@4.6.3_zod@3.23.8/node_modules/@hono/zod-validator/dist/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/validator/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/validator/validator.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/helper/cookie/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/cookie.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse4 = /* @__PURE__ */ __name((cookie, name) => {
  const pairs = cookie.trim().split(";");
  return pairs.reduce((parsedCookie, pairStr) => {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      return parsedCookie;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      return parsedCookie;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
    }
    return parsedCookie;
  }, {});
}, "parse");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/helper/cookie/index.js
var getCookie = /* @__PURE__ */ __name((c4, key, prefix) => {
  const cookie = c4.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return void 0;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse4(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse4(cookie);
  return obj;
}, "getCookie");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/buffer.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/crypto.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/buffer.js
var bufferToFormData = /* @__PURE__ */ __name((arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
}, "bufferToFormData");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = /* @__PURE__ */ __name((target, validationFunc) => {
  return async (c4, next) => {
    let value = {};
    const contentType = c4.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c4.req.json();
        } catch {
          const message2 = "Malformed JSON in request body";
          throw new HTTPException(400, { message: message2 });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c4.req.bodyCache.formData) {
          formData = await c4.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c4.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c4.req.bodyCache.formData = formData;
          } catch (e2) {
            let message2 = "Malformed FormData request.";
            message2 += e2 instanceof Error ? ` ${e2.message}` : ` ${String(e2)}`;
            throw new HTTPException(400, { message: message2 });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            ;
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            ;
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(
          Object.entries(c4.req.queries()).map(([k3, v4]) => {
            return v4.length === 1 ? [k3, v4[0]] : [k3, v4];
          })
        );
        break;
      case "param":
        value = c4.req.param();
        break;
      case "header":
        value = c4.req.header();
        break;
      case "cookie":
        value = getCookie(c4);
        break;
    }
    const res = await validationFunc(value, c4);
    if (res instanceof Response) {
      return res;
    }
    c4.req.addValidatedData(target, res);
    await next();
  };
}, "validator");

// node_modules/.pnpm/@hono+zod-validator@0.2.2_hono@4.6.3_zod@3.23.8/node_modules/@hono/zod-validator/dist/esm/index.js
var zValidator = /* @__PURE__ */ __name((target, schema, hook) => (
  // @ts-expect-error not typed well
  validator(target, async (value, c4) => {
    const result = await schema.safeParseAsync(value);
    if (hook) {
      const hookResult = await hook({ data: value, ...result }, c4);
      if (hookResult) {
        if (hookResult instanceof Response) {
          return hookResult;
        }
        if ("response" in hookResult) {
          return hookResult.response;
        }
      }
    }
    if (!result.success) {
      return c4.json(result, 400);
    }
    return result.data;
  })
), "zValidator");

// src/lib/utils/cartRouteUtils.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var cartRouteUtils = /* @__PURE__ */ __name(async (params, userId) => {
  const limit = params.limit ? parseInt(params.limit, 10) : 10;
  const cartProducts = await getAllCartProducts(userId, {
    ...params,
    limit,
    offset: +(params.offset || 0),
    noLimit: !!params?.noLimit,
    priceFilter: +params.priceFilter,
    sortBy: params.sortBy
  });
  return cartProducts;
}, "cartRouteUtils");

// src/routes/cart.ts
var cart = new Hono2().get(
  "/",
  async (c4, next) => await verifyAuth(c4, next, "Please login first."),
  async (c4) => {
    const auth = c4.get("authUser");
    const userId = auth?.token?.sub;
    if (!userId)
      throw new HTTPException(401, { message: "User not logged in" });
    const params = c4.req.query();
    const cartProducts = await cartRouteUtils(params, userId);
    return c4.json(cartProducts);
  }
).get("/:id", verifyAuth, async (c4) => {
  const params = c4.req.param("id") || "";
  const cartItem = await getCartByIdOrProductId(
    params,
    c4.get("authUser").token?.sub
  );
  if (cartItem) {
    return c4.json(cartItem);
  }
  return c4.json({ error: "Cart item not found" });
}).post(
  "/",
  (c4, next) => verifyAuth(c4, next, "Please login first."),
  zValidator(
    "json",
    z.object({
      productId: z.string(),
      qty: z.number().positive()
    })
  ),
  async (c4) => {
    const auth = c4.get("authUser");
    const data = c4.req.valid("json");
    const res = await createCartItem({ ...data, userId: auth.token?.sub });
    if ("error" in res) {
      throw new HTTPException(401, { message: res.error });
    }
    return c4.json(res);
  }
).delete("/:id", verifyAuth, async (c4) => {
  const params = c4.req.param("id") || "";
  const cartItem = await removeCartItemByIdOrProductId(
    params,
    c4.get("authUser").token?.sub
  );
  if (cartItem) {
    return c4.json(cartItem);
  }
  throw new HTTPException(401, { message: "Cart item not found" });
}).put("/:cartId", verifyAuth, async (c4) => {
  const params = c4.req.param("cartId") || "";
  const { qty } = await c4.req.json();
  const updatedItem = await updateCartItemQuantity(
    params,
    c4.get("authUser").token?.sub,
    qty
  );
  if (updatedItem) {
    return c4.json(updatedItem);
  }
  throw new HTTPException(401, {
    message: "Failed to update cart item quantity"
  });
});
var cart_default = cart;

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/cors/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var cors = /* @__PURE__ */ __name((options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      return () => optsOrigin;
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : optsOrigin[0];
    }
  })(opts.origin);
  return /* @__PURE__ */ __name(async function cors2(c4, next) {
    function set(key, value) {
      c4.res.headers.set(key, value);
    }
    __name(set, "set");
    const allowOrigin = findAllowOrigin(c4.req.header("origin") || "", c4);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c4.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c4.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      if (opts.allowMethods?.length) {
        set("Access-Control-Allow-Methods", opts.allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c4.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c4.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c4.res.headers.delete("Content-Length");
      c4.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c4.res.headers,
        status: 204,
        statusText: c4.res.statusText
      });
    }
    await next();
  }, "cors2");
}, "cors");

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/secure-headers/index.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/secure-headers/secure-headers.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/utils/encode.js
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();

// node_modules/.pnpm/hono@4.6.3/node_modules/hono/dist/middleware/secure-headers/secure-headers.js
var HEADERS_MAP = {
  crossOriginEmbedderPolicy: ["Cross-Origin-Embedder-Policy", "require-corp"],
  crossOriginResourcePolicy: ["Cross-Origin-Resource-Policy", "same-origin"],
  crossOriginOpenerPolicy: ["Cross-Origin-Opener-Policy", "same-origin"],
  originAgentCluster: ["Origin-Agent-Cluster", "?1"],
  referrerPolicy: ["Referrer-Policy", "no-referrer"],
  strictTransportSecurity: ["Strict-Transport-Security", "max-age=15552000; includeSubDomains"],
  xContentTypeOptions: ["X-Content-Type-Options", "nosniff"],
  xDnsPrefetchControl: ["X-DNS-Prefetch-Control", "off"],
  xDownloadOptions: ["X-Download-Options", "noopen"],
  xFrameOptions: ["X-Frame-Options", "SAMEORIGIN"],
  xPermittedCrossDomainPolicies: ["X-Permitted-Cross-Domain-Policies", "none"],
  xXssProtection: ["X-XSS-Protection", "0"]
};
var DEFAULT_OPTIONS = {
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: true,
  crossOriginOpenerPolicy: true,
  originAgentCluster: true,
  referrerPolicy: true,
  strictTransportSecurity: true,
  xContentTypeOptions: true,
  xDnsPrefetchControl: true,
  xDownloadOptions: true,
  xFrameOptions: true,
  xPermittedCrossDomainPolicies: true,
  xXssProtection: true,
  removePoweredBy: true,
  permissionsPolicy: {}
};
var secureHeaders = /* @__PURE__ */ __name((customOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...customOptions };
  const headersToSet = getFilteredHeaders(options);
  const callbacks = [];
  if (options.contentSecurityPolicy) {
    const [callback2, value] = getCSPDirectives(options.contentSecurityPolicy);
    if (callback2) {
      callbacks.push(callback2);
    }
    headersToSet.push(["Content-Security-Policy", value]);
  }
  if (options.contentSecurityPolicyReportOnly) {
    const [callback2, value] = getCSPDirectives(options.contentSecurityPolicyReportOnly);
    if (callback2) {
      callbacks.push(callback2);
    }
    headersToSet.push(["Content-Security-Policy-Report-Only", value]);
  }
  if (options.permissionsPolicy && Object.keys(options.permissionsPolicy).length > 0) {
    headersToSet.push([
      "Permissions-Policy",
      getPermissionsPolicyDirectives(options.permissionsPolicy)
    ]);
  }
  if (options.reportingEndpoints) {
    headersToSet.push(["Reporting-Endpoints", getReportingEndpoints(options.reportingEndpoints)]);
  }
  if (options.reportTo) {
    headersToSet.push(["Report-To", getReportToOptions(options.reportTo)]);
  }
  return /* @__PURE__ */ __name(async function secureHeaders2(ctx, next) {
    const headersToSetForReq = callbacks.length === 0 ? headersToSet : callbacks.reduce((acc, cb) => cb(ctx, acc), headersToSet);
    await next();
    setHeaders2(ctx, headersToSetForReq);
    if (options?.removePoweredBy) {
      ctx.res.headers.delete("X-Powered-By");
    }
  }, "secureHeaders2");
}, "secureHeaders");
function getFilteredHeaders(options) {
  return Object.entries(HEADERS_MAP).filter(([key]) => options[key]).map(([key, defaultValue]) => {
    const overrideValue = options[key];
    return typeof overrideValue === "string" ? [defaultValue[0], overrideValue] : defaultValue;
  });
}
__name(getFilteredHeaders, "getFilteredHeaders");
function getCSPDirectives(contentSecurityPolicy) {
  const callbacks = [];
  const resultValues = [];
  for (const [directive, value] of Object.entries(contentSecurityPolicy)) {
    const valueArray = Array.isArray(value) ? value : [value];
    valueArray.forEach((value2, i3) => {
      if (typeof value2 === "function") {
        const index = i3 * 2 + 2 + resultValues.length;
        callbacks.push((ctx, values) => {
          values[index] = value2(ctx, directive);
        });
      }
    });
    resultValues.push(
      directive.replace(
        /[A-Z]+(?![a-z])|[A-Z]/g,
        (match, offset) => offset ? "-" + match.toLowerCase() : match.toLowerCase()
      ),
      ...valueArray.flatMap((value2) => [" ", value2]),
      "; "
    );
  }
  resultValues.pop();
  return callbacks.length === 0 ? [void 0, resultValues.join("")] : [
    (ctx, headersToSet) => headersToSet.map((values) => {
      if (values[0] === "Content-Security-Policy" || values[0] === "Content-Security-Policy-Report-Only") {
        const clone = values[1].slice();
        callbacks.forEach((cb) => {
          cb(ctx, clone);
        });
        return [values[0], clone.join("")];
      } else {
        return values;
      }
    }),
    resultValues
  ];
}
__name(getCSPDirectives, "getCSPDirectives");
function getPermissionsPolicyDirectives(policy) {
  return Object.entries(policy).map(([directive, value]) => {
    const kebabDirective = camelToKebab(directive);
    if (typeof value === "boolean") {
      return `${kebabDirective}=${value ? "*" : "none"}`;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return `${kebabDirective}=()`;
      }
      if (value.length === 1 && (value[0] === "*" || value[0] === "none")) {
        return `${kebabDirective}=${value[0]}`;
      }
      const allowlist = value.map((item) => ["self", "src"].includes(item) ? item : `"${item}"`);
      return `${kebabDirective}=(${allowlist.join(" ")})`;
    }
    return "";
  }).filter(Boolean).join(", ");
}
__name(getPermissionsPolicyDirectives, "getPermissionsPolicyDirectives");
function camelToKebab(str) {
  return str.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
__name(camelToKebab, "camelToKebab");
function getReportingEndpoints(reportingEndpoints = []) {
  return reportingEndpoints.map((endpoint) => `${endpoint.name}="${endpoint.url}"`).join(", ");
}
__name(getReportingEndpoints, "getReportingEndpoints");
function getReportToOptions(reportTo = []) {
  return reportTo.map((option) => JSON.stringify(option)).join(", ");
}
__name(getReportToOptions, "getReportToOptions");
function setHeaders2(ctx, headersToSet) {
  headersToSet.forEach(([header, value]) => {
    ctx.res.headers.set(header, value);
  });
}
__name(setHeaders2, "setHeaders");

// src/index.ts
var app = new Hono2();
app.use(logger());
app.use(secureHeaders());
app.use("*", initAuthConfig(getAuthConfig));
var port = Number(process.env.PORT || 3e3);
console.log(`Server is running on  http://localhost:${port}`);
app.use(
  "/*",
  cors({
    origin: "http://localhost:3000",
    // allowHeaders: ["X-Custom-Header", "Upgrade-Insecure-Requests"],
    allowMethods: ["POST", "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    // exposeHeaders: ["Content-Length", "X-Kuma-Revision"],
    maxAge: 600,
    credentials: true
  })
);
var routes = app.route("/test", testRoute_default).route("/api/user", user_default).route("/api/cart", cart_default).route("/api/wishlist", wishlist_default).route("/api/products", product_default).route("/api/banners", banners_default);
function getAuthConfig(c4) {
  return {
    secret: c4.env.AUTH_SECRET,
    providers: []
  };
}
__name(getAuthConfig, "getAuthConfig");
var src_default = routes;

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var drainBody = /* @__PURE__ */ __name(async (request3, env4, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request3, env4);
  } finally {
    try {
      if (request3.body !== null && !request3.bodyUsed) {
        const reader = request3.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// .wrangler/tmp/bundle-gS6WEs/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/.pnpm/wrangler@3.80.2_@cloudflare+workers-types@4.20241004.0_bufferutil@4.0.8/node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_process();
init_virtual_unenv_global_polyfill_performance();
init_virtual_unenv_global_polyfill_console();
init_virtual_unenv_global_polyfill_set_immediate();
init_virtual_unenv_global_polyfill_clear_immediate();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request3, env4, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request3, env4, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request3, env4, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request3, env4, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-gS6WEs/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
__name(__Facade_ScheduledController__, "__Facade_ScheduledController__");
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request3, env4, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request3, env4, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request3, env4, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init3) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init3.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env4, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request3, env4, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request3, env4, ctx) => {
      this.env = env4;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request3);
    };
    #dispatcher = (type2, init3) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init3.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request3) {
      return __facade_invoke__(
        request3,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

q/q.js:
  (*!
   *
   * Copyright 2009-2017 Kris Kowal under the terms of the MIT
   * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@neondatabase/serverless/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=index.js.map
