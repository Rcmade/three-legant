import { and, eq, gte, or } from "drizzle-orm/expressions";
import { db } from "@/db/db";
import { productImages, products } from "@/db/schema";
import { SubImage } from "@/types";
import { alias } from "drizzle-orm/pg-core";

export const getProductDetails = async (productId: string) => {
  const parent = alias(products, "parent");

  const productData = await db
    .select({
      id: products.id,
      name: products.name,
      description: products.description,
      sku: products.sku,
      rating: products.rating,
      categoryId: products.categoryId,
      currentVariantType: products.currentVariantType,
      variantValue: products.variantValue,
      brand: products.brand,
      parentId: products.parentId,
      primaryImage: products.primaryImage,
      stock: products.stock,
      price: products.price,
      isAvailable: products.isAvailable,
      discountedPrice: products.discountedPrice,
      sortDescription: products.sortDescription,
      createdAt: products.createdAt,
      updatedAt: products.updatedAt,
      meta: products.meta,
      subImage: {
        image: productImages.imageUrl,
      },
    })
    .from(products)
    .leftJoin(productImages, eq(productImages.productId, products.id))
    .leftJoin(parent, eq(parent.id, products.id))
    .where(
      // and(
      or(eq(products.id, productId), eq(products.parentId, productId))
      // eq(products.isAvailable, true),
      // gte(products.stock, 1)
      // )
    )
    .execute();

  if (!productData?.length) {
    return null;
  }

  let primaryProduct = productData.find((p) => p.id === productId)!;
  if (!primaryProduct) {
    return null;
  }

  // const formate =

  const copyProductData = [...productData];
  const subImage: SubImage[] = [];

  const v = new Map();
  (productData || []).forEach((p) => {
    if (p.id === productId) {
      subImage.push({ image: p.subImage?.image! });
    }

    if (p.id !== productId) {
      // console.log({ p });
      v.set(p.id, { ...p, subImage: undefined });
    }
  });

  const g = [...v.values()];
  return {
    primaryProduct: { ...primaryProduct, subImage },
    g,
    productData,
  };

  // const data = productData;
  // const identifier = productId;

  // const mainProduct = data.find(
  //   (item) => item.id === identifier || item.parentId === identifier
  // );

  // if (!mainProduct) return null;

  // // Extract subImages for the main product
  // const subImages = data
  //   .filter((item) => item.imageUrl?.productId === mainProduct.id)
  //   .map((item) => ({ imageUrl: item?.imageUrl?.imageUrl }));

  // // Find product variants related to the main product
  // const productVariants = data
  //   .filter((item) => item.parentId === mainProduct.id)
  //   .map((item) => ({
  //     ...item,
  //     subImages: data
  //       .filter((sub) => sub.imageUrl?.productId === item.id)
  //       .map((sub) => ({ imageUrl: sub.imageUrl?.imageUrl })),
  //   }));

  // // Create the response object
  // return {
  //   product: {
  //     ...mainProduct,
  //     subImages,
  //   },
  //   productVariants,
  // };
};










import { and, eq, gte, isNull, or } from "drizzle-orm/expressions";
import { db } from "@/db/db";
import { productImages, products } from "@/db/schema";
import { SubImage } from "@/types";
import { alias } from "drizzle-orm/pg-core";
export const getProductDetails = async (id: string) => {
  // const parent = alias(products, "parent");
  // const children = alias(products, "children");
  const parent = alias(products, "parent");
  const sibling = alias(products, "sibling");

  const result = await db
    .select({
      productId: products.id,
      productName: products.name,
      parent: {
        id: parent.id,
        name: parent.name,
      },
      parentName: parent.name,
      sibling: {
        id: sibling.id,
        name: sibling.name,
      },
    })
    .from(products)
    .leftJoin(parent, eq(products.parentId, parent.id)) // Get the parent of the current product
    .leftJoin(sibling, eq(sibling.parentId, parent.id)) // Get all products that share the same parentId
    .where(eq(products.id, id)); // Filter by the current product's ID

  // Filter out the current product from the sibling list in JavaScript
  const siblings = result.filter((r) => r?.sibling?.id !== id);

  const output = {
    ...result[0], // Assuming result is an array
    siblings: siblings.map((s) => ({
      id: s?.sibling?.id,
      name: s?.sibling?.name,
    })),
  };

  const all = await db.select().from(products);
  return { result, output, all };
  // // Separate the main product and its variants
  // const mainProduct = result.find(
  //   (p) => p.product.id === id || p.product.parentId === null
  // );

  // const productVariants = result.filter(
  //   (p) => p.product.parentId === mainProduct?.product.id
  // );

  // return {
  //   product: mainProduct?.product,
  //   productImages: mainProduct?.images ? [mainProduct.images] : [],
  //   productVariants: productVariants.map((variant) => ({
  //     ...variant.product,
  //     images: variant.images ? [variant.images] : [],
  //   })),
  // };
};






































































import { and, eq, gte, isNull, or, notLike, ne } from "drizzle-orm/expressions";
import { db } from "@/db/db";
import { productImages, products } from "@/db/schema";
import { SubImage } from "@/types";
import { alias } from "drizzle-orm/pg-core";
export const getProductDetails = async (id: string) => {
  // const parent = alias(products, "parent");
  // const children = alias(products, "children");
  const parent = alias(products, "parent");
  const sibling = alias(products, "sibling");

  const result = await db
    .select({
      productId: products.id,
      productName: products.name,
      parent: {
        id: parent.id,
        name: parent.name,
      },
      parentName: parent.name,
      siblingId: sibling.id,
      siblingName: sibling.name,
      imageUrl: productImages.imageUrl,
    })
    .from(products)
    .leftJoin(parent, eq(products.parentId, parent.id)) // Join with parent
    .leftJoin(
      sibling,
      and(eq(sibling.parentId, parent.id), ne(sibling.id, products.id))
    ) // Join with siblings
    .leftJoin(productImages, eq(productImages.productId, products.id)) // Join with product images
    .where(eq(products.id, id));

  // Deduplicate siblings
  const siblings = Array.from(
    new Map(
      result
        .filter((r) => r.siblingId !== null)
        .map((r) => [r.siblingId, { id: r.siblingId, name: r.siblingName }])
    ).values()
  );

  // Group images
  const images = result
    .filter((r) => r.imageUrl !== null)
    .map((r) => ({ url: r.imageUrl }));

  const output = {
    productId: result[0].productId,
    productName: result[0].productName,
    parent: {
      id: result[0].parent?.id,
      name: result[0].parent?.name,
    },
    parentName: result[0].parentName,
    siblings: siblings, // Deduplicated siblings
    images: images, // Grouped product images
  };

  const all = await db.select().from(products);
  return { output, result, all };
  // // Separate the main product and its variants
  // const mainProduct = result.find(
  //   (p) => p.product.id === id || p.product.parentId === null
  // );

  // const productVariants = result.filter(
  //   (p) => p.product.parentId === mainProduct?.product.id
  // );

  // return {
  //   product: mainProduct?.product,
  //   productImages: mainProduct?.images ? [mainProduct.images] : [],
  //   productVariants: productVariants.map((variant) => ({
  //     ...variant.product,
  //     images: variant.images ? [variant.images] : [],
  //   })),
  // };
};























import { and, eq, gte, isNull, or, notLike, ne } from "drizzle-orm/expressions";
import { db } from "@/db/db";
import { productImages, products } from "@/db/schema";
import { SubImage } from "@/types";
import { alias } from "drizzle-orm/pg-core";
export const getProductDetails = async (id: string) => {
  // const parent = alias(products, "parent");
  // const children = alias(products, "children");
  const parent = alias(products, "parent");
  const sibling = alias(products, "sibling");

const result = await db
  .select({
    productId: products.id,
    productName: products.name,
    parent: {
      id: parent.id,
      name: parent.name,
    },
    parentName: parent.name,
    siblingId: sibling.id,
    siblingName: sibling.name,
    imageUrl: productImages.imageUrl,
  })
  .from(products)
  .leftJoin(parent, eq(products.parentId, parent.id)) // Join with parent
  .leftJoin(
    sibling,
    or(
      // Find siblings where this product is a child, or where it is the parent itself
      and(
        eq(sibling.parentId, products.parentId),
        ne(sibling.id, products.id)
      ),
      eq(sibling.parentId, products.id)
    )
  ) // Join with siblings
  .leftJoin(productImages, eq(productImages.productId, products.id)) // Join with product images
  .where(eq(products.id, id));

// Deduplicate siblings
const siblings = Array.from(
  new Map(
    result
      .filter((r) => r.siblingId !== null)
      .map((r) => [r.siblingId, { id: r.siblingId, name: r.siblingName }])
  ).values()
);

// Group images
const images = result
  .filter((r) => r.imageUrl !== null)
  .map((r) => ({ url: r.imageUrl }));

const output = {
  productId: result[0].productId,
  productName: result[0].productName,
  parent: result[0].parent?.id
    ? {
        id: result[0].parent.id,
        name: result[0].parent.name,
      }
    : {}, // Handle parent being empty when it's a top-level product
  parentName: result[0].parentName ?? null,
  siblings: siblings, // Deduplicated siblings
  images: images, // Grouped product images
};

  const all = await db.select().from(products);
  return { output, result, all };
};
